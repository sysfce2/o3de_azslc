
// Generated from ../azslParser.g4 by ANTLR 4.13.2


#include "azslParserListener.h"

#include "azslParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct AzslParserStaticData final {
  AzslParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  AzslParserStaticData(const AzslParserStaticData&) = delete;
  AzslParserStaticData(AzslParserStaticData&&) = delete;
  AzslParserStaticData& operator=(const AzslParserStaticData&) = delete;
  AzslParserStaticData& operator=(AzslParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag azslparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<AzslParserStaticData> azslparserParserStaticData = nullptr;

void azslparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (azslparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(azslparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<AzslParserStaticData>(
    std::vector<std::string>{
      "compilationUnit", "topLevelDeclaration", "idExpression", "unqualifiedId", 
      "qualifiedId", "nestedNameSpecifier", "classDefinitionStatement", 
      "classDefinition", "baseList", "classMemberDeclaration", "structDefinitionStatement", 
      "structDefinition", "structMemberDeclaration", "anyStructuredTypeDefinitionStatement", 
      "enumDefinitionStatement", "enumDefinition", "enumKey", "enumeratorListDefinition", 
      "enumeratorDeclarator", "anyStructuredTypeDefinition", "interfaceDefinitionStatement", 
      "interfaceDefinition", "interfaceMemberDeclaration", "constantBufferTemplated", 
      "variableDeclarationStatement", "functionParams", "functionParam", 
      "hlslSemantic", "hlslSemanticName", "attributeArguments", "attributeArgumentList", 
      "attribute", "attributeSpecifier", "attributeSpecifierSequence", "attributeSpecifierAny", 
      "block", "statement", "forInitializer", "switchLabel", "switchSection", 
      "switchBlock", "embeddedStatement", "elseClause", "expression", "expressionExt", 
      "postfixUnaryOperator", "prefixUnaryOperator", "binaryOperator", "assignmentOperator", 
      "argumentList", "arguments", "variableDeclaration", "variableDeclarators", 
      "unnamedVariableDeclarator", "namedVariableDeclarator", "variableInitializer", 
      "standardVariableInitializer", "arrayElementInitializers", "arrayRankSpecifier", 
      "packOffsetNode", "storageFlags", "storageFlag", "type", "predefinedType", 
      "subobjectType", "otherViewResourceType", "rtxBuiltInTypes", "bufferPredefinedType", 
      "bufferType", "byteAddressBufferTypes", "patchPredefinedType", "patchType", 
      "samplerStatePredefinedType", "scalarType", "streamOutputPredefinedType", 
      "streamOutputObjectType", "structuredBufferPredefinedType", "structuredBufferName", 
      "textureType", "texturePredefinedType", "genericTexturePredefinedType", 
      "textureTypeMS", "msTexturePredefinedType", "vectorType", "genericVectorType", 
      "scalarOrVectorType", "scalarOrVectorOrMatrixType", "matrixType", 
      "genericMatrixPredefinedType", "registerAllocation", "samplerStateProperty", 
      "literal", "leadingTypeFunctionSignature", "hlslFunctionDefinition", 
      "hlslFunctionDeclaration", "userDefinedType", "associatedTypeDeclaration", 
      "typedefStatement", "typealiasStatement", "typeAliasingDefinitionStatement", 
      "typeofExpression", "genericParameterList", "genericTypeDefinition", 
      "genericConstraint", "languageDefinedConstraint", "functionDeclaration", 
      "attributedFunctionDeclaration", "functionDefinition", "attributedFunctionDefinition", 
      "compilerExtensionStatement", "srgDefinition", "attributedSrgDefinition", 
      "srgMemberDeclaration", "srgSemantic", "attributedSrgSemantic", "srgSemanticBodyDeclaration", 
      "srgSemanticMemberDeclaration", "samplerBodyDeclaration", "samplerMemberDeclaration", 
      "maxAnisotropyOption", "minFilterOption", "magFilterOption", "mipFilterOption", 
      "reductionTypeOption", "comparisonFunctionOption", "addressUOption", 
      "addressVOption", "addressWOption", "minLodOption", "maxLodOption", 
      "mipLodBiasOption", "borderColorOption", "filterModeEnum", "reductionTypeEnum", 
      "addressModeEnum", "comparisonFunctionEnum", "borderColorEnum"
    },
    std::vector<std::string>{
      "", "'AppendStructuredBuffer'", "'bool'", "'bool1'", "'bool2'", "'bool3'", 
      "'bool4'", "'bool1x1'", "'bool1x2'", "'bool1x3'", "'bool1x4'", "'bool2x1'", 
      "'bool2x2'", "'bool2x3'", "'bool2x4'", "'bool3x1'", "'bool3x2'", "'bool3x3'", 
      "'bool3x4'", "'bool4x1'", "'bool4x2'", "'bool4x3'", "'bool4x4'", "'Buffer'", 
      "'BuiltInTriangleIntersectionAttributes'", "'ByteAddressBuffer'", 
      "'break'", "'case'", "'cbuffer'", "'centroid'", "'constantbuffer'", 
      "'ConstantBuffer'", "'class'", "'column_major'", "'const'", "'ConsumeStructuredBuffer'", 
      "'continue'", "'default'", "'discard'", "'do'", "'double'", "'double1'", 
      "'double2'", "'double3'", "'double4'", "'double1x1'", "'double1x2'", 
      "'double1x3'", "'double1x4'", "'double2x1'", "'double2x2'", "'double2x3'", 
      "'double2x4'", "'double3x1'", "'double3x2'", "'double3x3'", "'double3x4'", 
      "'double4x1'", "'double4x2'", "'double4x3'", "'double4x4'", "'else'", 
      "'enum'", "'export'", "'extern'", "'FeedbackTexture2D'", "'FeedbackTexture2DArray'", 
      "'float'", "'float1'", "'float2'", "'float3'", "'float4'", "'float1x1'", 
      "'float1x2'", "'float1x3'", "'float1x4'", "'float2x1'", "'float2x2'", 
      "'float2x3'", "'float2x4'", "'float3x1'", "'float3x2'", "'float3x3'", 
      "'float3x4'", "'float4x1'", "'float4x2'", "'float4x3'", "'float4x4'", 
      "'for'", "'groupshared'", "'globallycoherent'", "'global'", "'half'", 
      "'half1'", "'half2'", "'half3'", "'half4'", "'half1x1'", "'half1x2'", 
      "'half1x3'", "'half1x4'", "'half2x1'", "'half2x2'", "'half2x3'", "'half2x4'", 
      "'half3x1'", "'half3x2'", "'half3x3'", "'half3x4'", "'half4x1'", "'half4x2'", 
      "'half4x3'", "'half4x4'", "'if'", "'in'", "'inline'", "'rootconstant'", 
      "", "'InputPatch'", "'int'", "'int16_t'", "'int32_t'", "'int64_t'", 
      "'int1'", "'int2'", "'int3'", "'int4'", "'int1x1'", "'int1x2'", "'int1x3'", 
      "'int1x4'", "'int2x1'", "'int2x2'", "'int2x3'", "'int2x4'", "'int3x1'", 
      "'int3x2'", "'int3x3'", "'int3x4'", "'int4x1'", "'int4x2'", "'int4x3'", 
      "'int4x4'", "'interface'", "'line'", "'lineadj'", "'linear'", "'LineStream'", 
      "'long'", "'matrix'", "'nointerpolation'", "'noperspective'", "'option'", 
      "'out'", "'OutputPatch'", "'override'", "'partial'", "'packoffset'", 
      "'point'", "'PointStream'", "'precise'", "'RasterizerOrderedBuffer'", 
      "'RasterizerOrderedByteAddressBuffer'", "'RasterizerOrderedStructuredBuffer'", 
      "'RasterizerOrderedTexture1D'", "'RasterizerOrderedTexture1DArray'", 
      "'RasterizerOrderedTexture2D'", "'RasterizerOrderedTexture2DArray'", 
      "'RasterizerOrderedTexture3D'", "'RayDesc'", "'RaytracingAccelerationStructure'", 
      "'register'", "'return'", "'row_major'", "'RWBuffer'", "'RWByteAddressBuffer'", 
      "'RWStructuredBuffer'", "'RWTexture1D'", "'RWTexture1DArray'", "'RWTexture2D'", 
      "'RWTexture2DArray'", "'RWTexture3D'", "'sample'", "'sampler'", "'Sampler'", 
      "'SamplerComparisonState'", "'SamplerState'", "'sampler_state'", "'shared'", 
      "'snorm'", "'static'", "'struct'", "'StructuredBuffer'", "'SubpassInput'", 
      "'SubpassInputMS'", "'switch'", "'tbuffer'", "'Texture1D'", "'Texture1DArray'", 
      "'Texture2D'", "'Texture2DArray'", "'Texture2DMS'", "'Texture2DMSArray'", 
      "'Texture3D'", "'TextureCube'", "'TextureCubeArray'", "'triangle'", 
      "'triangleadj'", "'TriangleStream'", "'uniform'", "'uint'", "'uint1'", 
      "'uint2'", "'uint3'", "'uint4'", "'uint1x1'", "'uint1x2'", "'uint1x3'", 
      "'uint1x4'", "'uint2x1'", "'uint2x2'", "'uint2x3'", "'uint2x4'", "'uint3x1'", 
      "'uint3x2'", "'uint3x3'", "'uint3x4'", "'uint4x1'", "'uint4x2'", "'uint4x3'", 
      "'uint4x4'", "'uint16_t'", "'uint32_t'", "'uint64_t'", "'unorm'", 
      "'unsigned'", "'dword'", "'dword1'", "'dword2'", "'dword3'", "'dword4'", 
      "'dword1x1'", "'dword1x2'", "'dword1x3'", "'dword1x4'", "'dword2x1'", 
      "'dword2x2'", "'dword2x3'", "'dword2x4'", "'dword3x1'", "'dword3x2'", 
      "'dword3x3'", "'dword3x4'", "'dword4x1'", "'dword4x2'", "'dword4x3'", 
      "'dword4x4'", "'vector'", "'volatile'", "'void'", "'while'", "'StateObjectConfig'", 
      "'LocalRootSignature'", "'GlobalRootSignature'", "'SubobjectToExportsAssociation'", 
      "'RaytracingShaderConfig'", "'RaytracingPipelineConfig'", "'RaytracingPipelineConfig1'", 
      "'TriangleHitGroup'", "'ProceduralPrimitiveHitGroup'", "'AddressU'", 
      "'AddressV'", "'AddressW'", "'BorderColor'", "'MinFilter'", "'MagFilter'", 
      "'MipFilter'", "'MaxAnisotropy'", "'MaxLOD'", "'MinLOD'", "'MipLODBias'", 
      "'ComparisonFunc'", "'ReductionType'", "'Point'", "'Linear'", "'Filter'", 
      "'Comparison'", "'Minimum'", "'Maximum'", "'Wrap'", "'Mirror'", "'Clamp'", 
      "'Border'", "'MirrorOnce'", "'Never'", "'Less'", "'Equal'", "'LessEqual'", 
      "'Greater'", "'NotEqual'", "'GreaterEqual'", "'Always'", "'OpaqueBlack'", 
      "'TransparentBlack'", "'OpaqueWhite'", "'('", "')'", "'['", "']'", 
      "'{'", "'}'", "'[['", "'<'", "'<='", "'>'", "'>='", "'<<'", "'>>'", 
      "'+'", "'++'", "'-'", "'--'", "'*'", "'/'", "'%'", "'&'", "'|'", "'&&'", 
      "'||'", "'^'", "'!'", "'~'", "'\\u003F'", "':'", "'::'", "';'", "','", 
      "'='", "'*='", "'/='", "'%='", "'+='", "'-='", "'<<='", "'>>='", "'&='", 
      "'^='", "'|='", "'=='", "'!='", "'.'", "'true'", "'false'", "'associatedtype'", 
      "'typealias'", "'typedef'", "'fundamental'", "'typeof'", "'FrequencyId'", 
      "'ShaderVariantFallback'", "'ShaderResourceGroupSemantic'", "'ShaderResourceGroup'", 
      "'__azslc_print_message'", "'__azslc_print_symbol'", "'__azslc_prtsym_fully_qualified'", 
      "'__azslc_prtsym_least_qualified'", "'__azslc_prtsym_constint_value'"
    },
    std::vector<std::string>{
      "", "AppendStructuredBuffer", "Bool", "Bool1", "Bool2", "Bool3", "Bool4", 
      "Bool1x1", "Bool1x2", "Bool1x3", "Bool1x4", "Bool2x1", "Bool2x2", 
      "Bool2x3", "Bool2x4", "Bool3x1", "Bool3x2", "Bool3x3", "Bool3x4", 
      "Bool4x1", "Bool4x2", "Bool4x3", "Bool4x4", "Buffer", "BuiltInTriangleIntersectionAttributes", 
      "ByteAddressBuffer", "Break", "Case", "CBuffer", "Centroid", "ConstantBuffer", 
      "ConstantBufferCamel", "Class", "ColumnMajor", "Const", "ConsumeStructuredBuffer", 
      "Continue", "Default", "Discard", "Do", "Double", "Double1", "Double2", 
      "Double3", "Double4", "Double1x1", "Double1x2", "Double1x3", "Double1x4", 
      "Double2x1", "Double2x2", "Double2x3", "Double2x4", "Double3x1", "Double3x2", 
      "Double3x3", "Double3x4", "Double4x1", "Double4x2", "Double4x3", "Double4x4", 
      "Else", "Enum", "Export", "Extern", "FeedbackTexture2D", "FeedbackTexture2DArray", 
      "Float", "Float1", "Float2", "Float3", "Float4", "Float1x1", "Float1x2", 
      "Float1x3", "Float1x4", "Float2x1", "Float2x2", "Float2x3", "Float2x4", 
      "Float3x1", "Float3x2", "Float3x3", "Float3x4", "Float4x1", "Float4x2", 
      "Float4x3", "Float4x4", "For", "Groupshared", "Globallycoherent", 
      "Global", "Half", "Half1", "Half2", "Half3", "Half4", "Half1x1", "Half1x2", 
      "Half1x3", "Half1x4", "Half2x1", "Half2x2", "Half2x3", "Half2x4", 
      "Half3x1", "Half3x2", "Half3x3", "Half3x4", "Half4x1", "Half4x2", 
      "Half4x3", "Half4x4", "If", "In", "Inline", "Rootconstant", "Inout", 
      "InputPatch", "Int", "Int16_t", "Int32_t", "Int64_t", "Int1", "Int2", 
      "Int3", "Int4", "Int1x1", "Int1x2", "Int1x3", "Int1x4", "Int2x1", 
      "Int2x2", "Int2x3", "Int2x4", "Int3x1", "Int3x2", "Int3x3", "Int3x4", 
      "Int4x1", "Int4x2", "Int4x3", "Int4x4", "Interface", "Line_", "LineAdj", 
      "Linear", "LineStream", "Long", "Matrix", "Nointerpolation", "Noperspective", 
      "Option", "Out", "OutputPatch", "Override", "Partial", "Packoffset", 
      "Point", "PointStream", "Precise", "RasterizerOrderedBuffer", "RasterizerOrderedByteAddressBuffer", 
      "RasterizerOrderedStructuredBuffer", "RasterizerOrderedTexture1D", 
      "RasterizerOrderedTexture1DArray", "RasterizerOrderedTexture2D", "RasterizerOrderedTexture2DArray", 
      "RasterizerOrderedTexture3D", "RayDesc", "RaytracingAccelerationStructure", 
      "Register", "Return", "RowMajor", "RWBuffer", "RWByteAddressBuffer", 
      "RWStructuredBuffer", "RWTexture1D", "RWTexture1DArray", "RWTexture2D", 
      "RWTexture2DArray", "RWTexture3D", "Sample", "Sampler", "SamplerCapitalS", 
      "SamplerComparisonState", "SamplerStateCamel", "SamplerState", "Shared", 
      "SNorm", "Static", "Struct", "StructuredBuffer", "SubpassInput", "SubpassInputMS", 
      "Switch", "TBuffer", "Texture1D", "Texture1DArray", "Texture2D", "Texture2DArray", 
      "Texture2DMS", "Texture2DMSArray", "Texture3D", "TextureCube", "TextureCubeArray", 
      "Triangle", "TriangleAdj", "TriangleStream", "Uniform", "Uint", "Uint1", 
      "Uint2", "Uint3", "Uint4", "Uint1x1", "Uint1x2", "Uint1x3", "Uint1x4", 
      "Uint2x1", "Uint2x2", "Uint2x3", "Uint2x4", "Uint3x1", "Uint3x2", 
      "Uint3x3", "Uint3x4", "Uint4x1", "Uint4x2", "Uint4x3", "Uint4x4", 
      "Uint16_t", "Uint32_t", "Uint64_t", "UNorm", "Unsigned", "Dword", 
      "Dword1", "Dword2", "Dword3", "Dword4", "Dword1x1", "Dword1x2", "Dword1x3", 
      "Dword1x4", "Dword2x1", "Dword2x2", "Dword2x3", "Dword2x4", "Dword3x1", 
      "Dword3x2", "Dword3x3", "Dword3x4", "Dword4x1", "Dword4x2", "Dword4x3", 
      "Dword4x4", "Vector", "Volatile", "Void", "While", "StateObjectConfig", 
      "LocalRootSignature", "GlobalRootSignature", "SubobjectToExportsAssociation", 
      "RaytracingShaderConfig", "RaytracingPipelineConfig", "RaytracingPipelineConfig1", 
      "TriangleHitGroup", "ProceduralPrimitiveHitGroup", "ADDRESS_U", "ADDRESS_V", 
      "ADDRESS_W", "BORDER_COLOR", "MIN_FILTER", "MAG_FILTER", "MIP_FILTER", 
      "MAX_ANISOTROPY", "MAX_LOD", "MIN_LOD", "MIP_LOD_BIAS", "COMPARISON_FUNC", 
      "REDUCTION_TYPE", "FILTER_MODE_POINT", "FILTER_MODE_LINEAR", "REDUCTION_TYPE_FILTER", 
      "REDUCTION_TYPE_COMPARISON", "REDUCTION_TYPE_MINIMUM", "REDUCTION_TYPE_MAXIMUM", 
      "ADDRESS_MODE_WRAP", "ADDRESS_MODE_MIRROR", "ADDRESS_MODE_CLAMP", 
      "ADDRESS_MODE_BORDER", "ADDRESS_MODE_MIRROR_ONCE", "COMPARISON_FUNCTION_NEVER", 
      "COMPARISON_FUNCTION_LESS", "COMPARISON_FUNCTION_EQUAL", "COMPARISON_FUNCTION_LESS_EQUAL", 
      "COMPARISON_FUNCTION_GREATER", "COMPARISON_FUNCTION_NOT_EQUAL", "COMPARISON_FUNCTION_GREATER_EQUAL", 
      "COMPARISON_FUNCTION_ALWAYS", "BORDER_COLOR_OPAQUE_BLACK", "BORDER_COLOR_TRANSPARENT_BLACK", 
      "BORDER_COLOR_OPAQUE_WHITE", "LeftParen", "RightParen", "LeftBracket", 
      "RightBracket", "LeftBrace", "RightBrace", "LeftDoubleBracket", "Less", 
      "LessEqual", "Greater", "GreaterEqual", "LeftShift", "RightShift", 
      "Plus", "PlusPlus", "Minus", "MinusMinus", "Star", "Div", "Mod", "And", 
      "Or", "AndAnd", "OrOr", "Caret", "Not", "Tilde", "Question", "Colon", 
      "ColonColon", "Semi", "Comma", "Assign", "StarAssign", "DivAssign", 
      "ModAssign", "PlusAssign", "MinusAssign", "LeftShiftAssign", "RightShiftAssign", 
      "AndAssign", "XorAssign", "OrAssign", "Equal", "NotEqual", "Dot", 
      "True", "False", "KW_AssociatedType", "KW_TypeAlias", "KW_Typedef", 
      "KW_Fundamental", "KW_Typeof", "FrequencyId", "ShaderVariantFallback", 
      "ShaderResourceGroupSemantic", "ShaderResourceGroup", "KW_ext_print_message", 
      "KW_ext_print_symbol", "KW_ext_prtsym_fully_qualified", "KW_ext_prtsym_least_qualified", 
      "KW_ext_prtsym_constint_value", "HLSLSemanticStream", "HLSLSemanticSystem", 
      "Identifier", "IntegerLiteral", "FloatLiteral", "StringLiteral", "PragmaDirective", 
      "LineDirective", "Whitespace", "Newline", "BlockComment", "LineComment"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,378,1269,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,1,0,5,0,276,8,0,10,0,12,0,279,9,0,1,0,1,
  	0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,293,8,1,1,2,1,2,3,2,297,
  	8,2,1,3,1,3,1,4,1,4,1,4,1,5,3,5,305,8,5,1,5,1,5,5,5,309,8,5,10,5,12,5,
  	312,9,5,1,6,1,6,1,6,1,7,1,7,1,7,3,7,320,8,7,1,7,1,7,5,7,324,8,7,10,7,
  	12,7,327,9,7,1,7,1,7,1,8,1,8,1,8,1,8,5,8,335,8,8,10,8,12,8,338,9,8,1,
  	9,1,9,1,9,1,9,1,9,1,9,3,9,346,8,9,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
  	5,11,355,8,11,10,11,12,11,358,9,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,
  	1,12,3,12,368,8,12,1,13,5,13,371,8,13,10,13,12,13,374,9,13,1,13,1,13,
  	1,13,1,14,1,14,1,14,1,15,1,15,1,15,1,15,3,15,386,8,15,1,15,1,15,1,16,
  	1,16,1,16,3,16,393,8,16,1,17,1,17,1,17,5,17,398,8,17,10,17,12,17,401,
  	9,17,1,17,3,17,404,8,17,1,18,1,18,1,18,3,18,409,8,18,1,19,1,19,1,19,1,
  	19,3,19,415,8,19,1,20,1,20,1,20,1,21,1,21,1,21,1,21,5,21,424,8,21,10,
  	21,12,21,427,9,21,1,21,1,21,1,22,1,22,1,22,3,22,434,8,22,1,23,1,23,1,
  	23,1,23,1,23,1,24,1,24,1,24,1,25,1,25,1,25,1,25,5,25,448,8,25,10,25,12,
  	25,451,9,25,3,25,453,8,25,1,26,5,26,456,8,26,10,26,12,26,459,9,26,1,26,
  	1,26,3,26,463,8,26,1,26,1,26,1,27,1,27,1,27,1,28,1,28,1,29,1,29,1,29,
  	5,29,475,8,29,10,29,12,29,478,9,29,1,30,1,30,1,30,1,30,1,31,1,31,1,31,
  	1,31,3,31,488,8,31,1,31,1,31,3,31,492,8,31,1,31,1,31,3,31,496,8,31,1,
  	31,1,31,3,31,500,8,31,3,31,502,8,31,1,32,1,32,1,32,1,32,1,33,1,33,1,33,
  	1,33,5,33,512,8,33,10,33,12,33,515,9,33,1,33,1,33,1,33,1,34,1,34,3,34,
  	522,8,34,1,35,1,35,5,35,526,8,35,10,35,12,35,529,9,35,1,35,1,35,1,36,
  	1,36,1,36,3,36,536,8,36,1,37,1,37,3,37,540,8,37,1,38,1,38,1,38,1,38,1,
  	38,1,38,3,38,548,8,38,1,39,4,39,551,8,39,11,39,12,39,552,1,39,4,39,556,
  	8,39,11,39,12,39,557,1,40,1,40,5,40,562,8,40,10,40,12,40,565,9,40,1,40,
  	1,40,1,41,1,41,1,41,1,41,1,41,1,41,5,41,575,8,41,10,41,12,41,578,9,41,
  	1,41,1,41,1,41,1,41,1,41,1,41,3,41,586,8,41,1,41,5,41,589,8,41,10,41,
  	12,41,592,9,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,5,41,601,8,41,10,41,
  	12,41,604,9,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,5,41,613,8,41,10,41,
  	12,41,616,9,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,5,41,627,
  	8,41,10,41,12,41,630,9,41,1,41,1,41,1,41,3,41,635,8,41,1,41,1,41,3,41,
  	639,8,41,1,41,1,41,3,41,643,8,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,3,41,655,8,41,1,41,1,41,1,41,3,41,660,8,41,1,42,1,42,1,42,
  	1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,5,43,
  	678,8,43,10,43,12,43,681,9,43,1,43,1,43,1,43,1,43,1,43,1,43,3,43,689,
  	8,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
  	1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,5,43,
  	717,8,43,10,43,12,43,720,9,43,1,44,1,44,1,44,1,44,1,44,1,44,5,44,728,
  	8,44,10,44,12,44,731,9,44,1,45,1,45,1,46,1,46,1,47,1,47,1,48,1,48,1,49,
  	1,49,3,49,743,8,49,1,49,1,49,1,50,1,50,1,50,5,50,750,8,50,10,50,12,50,
  	753,9,50,1,51,5,51,756,8,51,10,51,12,51,759,9,51,1,51,1,51,1,51,1,52,
  	1,52,1,52,5,52,767,8,52,10,52,12,52,770,9,52,1,53,5,53,773,8,53,10,53,
  	12,53,776,9,53,1,53,3,53,779,8,53,1,53,3,53,782,8,53,1,53,3,53,785,8,
  	53,1,53,3,53,788,8,53,1,54,1,54,1,54,1,55,1,55,1,55,3,55,796,8,55,1,56,
  	1,56,1,56,1,56,1,56,3,56,803,8,56,1,57,1,57,1,57,5,57,808,8,57,10,57,
  	12,57,811,9,57,1,57,3,57,814,8,57,1,58,1,58,3,58,818,8,58,1,58,1,58,1,
  	59,1,59,1,59,1,59,1,59,1,59,3,59,828,8,59,1,59,1,59,1,60,5,60,833,8,60,
  	10,60,12,60,836,9,60,1,61,1,61,1,62,1,62,1,62,1,62,1,62,3,62,845,8,62,
  	1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,
  	1,63,1,63,1,63,1,63,3,63,865,8,63,1,64,1,64,1,65,1,65,1,66,1,66,1,67,
  	1,67,1,67,1,67,1,67,1,68,1,68,1,69,1,69,1,70,1,70,1,70,1,70,1,70,1,70,
  	1,70,1,71,1,71,1,72,1,72,1,73,1,73,1,74,1,74,1,74,1,74,1,74,1,75,1,75,
  	1,76,1,76,1,76,1,76,1,76,1,77,1,77,1,78,1,78,1,79,1,79,1,80,1,80,1,80,
  	1,80,1,80,1,81,1,81,1,82,1,82,1,82,1,82,1,82,3,82,925,8,82,1,82,1,82,
  	1,83,1,83,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,85,1,85,3,85,940,8,85,
  	1,86,1,86,1,86,3,86,945,8,86,1,87,1,87,1,88,1,88,1,88,1,88,1,88,1,88,
  	1,88,1,88,1,88,1,89,1,89,1,89,1,89,1,89,1,89,1,90,1,90,1,90,1,90,1,90,
  	1,91,1,91,1,91,1,91,1,91,4,91,974,8,91,11,91,12,91,975,3,91,978,8,91,
  	1,92,1,92,1,92,1,92,3,92,984,8,92,1,92,1,92,3,92,988,8,92,1,92,1,92,3,
  	92,992,8,92,1,92,1,92,3,92,996,8,92,1,92,3,92,999,8,92,1,93,1,93,1,93,
  	1,94,1,94,1,94,1,95,1,95,3,95,1009,8,95,1,96,1,96,1,96,3,96,1014,8,96,
  	1,96,1,96,1,97,1,97,1,97,1,97,1,97,1,98,1,98,1,98,1,98,1,98,1,98,1,99,
  	1,99,3,99,1031,8,99,1,100,1,100,1,100,1,100,3,100,1037,8,100,1,100,1,
  	100,1,100,3,100,1042,8,100,1,101,1,101,1,101,1,101,5,101,1048,8,101,10,
  	101,12,101,1051,9,101,1,101,1,101,1,102,1,102,3,102,1057,8,102,1,103,
  	1,103,1,103,1,104,1,104,1,105,1,105,1,106,5,106,1067,8,106,10,106,12,
  	106,1070,9,106,1,106,1,106,1,107,1,107,1,108,5,108,1077,8,108,10,108,
  	12,108,1080,9,108,1,108,1,108,1,109,1,109,1,109,1,109,1,109,1,109,1,109,
  	1,109,1,109,3,109,1093,8,109,1,109,1,109,1,109,1,109,1,109,3,109,1100,
  	8,109,1,110,3,110,1103,8,110,1,110,1,110,1,110,1,110,3,110,1109,8,110,
  	1,110,1,110,5,110,1113,8,110,10,110,12,110,1116,9,110,1,110,1,110,1,111,
  	5,111,1121,8,111,10,111,12,111,1124,9,111,1,111,1,111,1,112,1,112,1,112,
  	1,112,1,112,1,112,1,112,3,112,1135,8,112,1,113,1,113,1,113,1,113,1,114,
  	5,114,1142,8,114,10,114,12,114,1145,9,114,1,114,1,114,1,115,1,115,5,115,
  	1151,8,115,10,115,12,115,1154,9,115,1,115,1,115,1,116,1,116,1,116,1,116,
  	1,116,1,116,1,116,1,116,1,116,1,116,3,116,1168,8,116,1,117,1,117,5,117,
  	1172,8,117,10,117,12,117,1175,9,117,1,117,1,117,1,118,1,118,1,118,1,118,
  	1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,3,118,1192,8,118,
  	1,119,1,119,1,119,1,119,1,119,1,120,1,120,1,120,1,120,1,120,1,121,1,121,
  	1,121,1,121,1,121,1,122,1,122,1,122,1,122,1,122,1,123,1,123,1,123,1,123,
  	1,123,1,124,1,124,1,124,1,124,1,124,1,125,1,125,1,125,1,125,1,125,1,126,
  	1,126,1,126,1,126,1,126,1,127,1,127,1,127,1,127,1,127,1,128,1,128,1,128,
  	1,128,1,128,1,129,1,129,1,129,1,129,1,129,1,130,1,130,1,130,1,130,1,130,
  	1,131,1,131,1,131,1,131,1,131,1,132,1,132,1,133,1,133,1,134,1,134,1,135,
  	1,135,1,136,1,136,1,136,1,834,2,86,88,137,0,2,4,6,8,10,12,14,16,18,20,
  	22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
  	68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
  	112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,
  	148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,
  	184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,
  	220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,
  	256,258,260,262,264,266,268,270,272,0,27,2,0,32,32,191,191,1,0,30,31,
  	1,0,367,369,2,0,319,319,321,321,2,0,318,321,330,331,4,0,312,318,320,320,
  	322,329,348,349,1,0,337,347,17,0,29,29,33,34,64,64,89,90,114,117,144,
  	146,150,153,158,158,160,160,173,173,182,182,188,190,206,207,209,209,234,
  	235,258,258,369,369,1,0,261,269,2,0,24,24,169,169,3,0,23,23,161,161,174,
  	174,3,0,25,25,162,162,175,175,2,0,118,118,154,154,1,0,183,187,8,0,2,2,
  	40,40,67,67,92,92,119,122,210,210,231,233,236,236,3,0,147,147,159,159,
  	208,208,5,0,1,1,35,35,163,163,176,176,192,192,5,0,164,168,177,181,193,
  	194,197,200,203,205,1,0,201,202,8,0,3,6,41,44,68,71,93,96,123,126,211,
  	214,237,240,257,257,8,0,7,22,45,60,72,87,97,112,127,142,149,149,215,230,
  	241,256,1,0,364,366,1,0,283,284,1,0,285,288,1,0,289,293,1,0,294,301,1,
  	0,302,304,1314,0,277,1,0,0,0,2,292,1,0,0,0,4,296,1,0,0,0,6,298,1,0,0,
  	0,8,300,1,0,0,0,10,304,1,0,0,0,12,313,1,0,0,0,14,316,1,0,0,0,16,330,1,
  	0,0,0,18,345,1,0,0,0,20,347,1,0,0,0,22,350,1,0,0,0,24,367,1,0,0,0,26,
  	372,1,0,0,0,28,378,1,0,0,0,30,381,1,0,0,0,32,392,1,0,0,0,34,394,1,0,0,
  	0,36,405,1,0,0,0,38,414,1,0,0,0,40,416,1,0,0,0,42,419,1,0,0,0,44,433,
  	1,0,0,0,46,435,1,0,0,0,48,440,1,0,0,0,50,452,1,0,0,0,52,457,1,0,0,0,54,
  	466,1,0,0,0,56,469,1,0,0,0,58,471,1,0,0,0,60,479,1,0,0,0,62,501,1,0,0,
  	0,64,503,1,0,0,0,66,507,1,0,0,0,68,521,1,0,0,0,70,523,1,0,0,0,72,535,
  	1,0,0,0,74,539,1,0,0,0,76,547,1,0,0,0,78,550,1,0,0,0,80,559,1,0,0,0,82,
  	659,1,0,0,0,84,661,1,0,0,0,86,688,1,0,0,0,88,721,1,0,0,0,90,732,1,0,0,
  	0,92,734,1,0,0,0,94,736,1,0,0,0,96,738,1,0,0,0,98,740,1,0,0,0,100,746,
  	1,0,0,0,102,757,1,0,0,0,104,763,1,0,0,0,106,774,1,0,0,0,108,789,1,0,0,
  	0,110,795,1,0,0,0,112,802,1,0,0,0,114,804,1,0,0,0,116,815,1,0,0,0,118,
  	821,1,0,0,0,120,834,1,0,0,0,122,837,1,0,0,0,124,839,1,0,0,0,126,864,1,
  	0,0,0,128,866,1,0,0,0,130,868,1,0,0,0,132,870,1,0,0,0,134,872,1,0,0,0,
  	136,877,1,0,0,0,138,879,1,0,0,0,140,881,1,0,0,0,142,888,1,0,0,0,144,890,
  	1,0,0,0,146,892,1,0,0,0,148,894,1,0,0,0,150,899,1,0,0,0,152,901,1,0,0,
  	0,154,906,1,0,0,0,156,908,1,0,0,0,158,910,1,0,0,0,160,912,1,0,0,0,162,
  	917,1,0,0,0,164,919,1,0,0,0,166,928,1,0,0,0,168,930,1,0,0,0,170,939,1,
  	0,0,0,172,944,1,0,0,0,174,946,1,0,0,0,176,948,1,0,0,0,178,957,1,0,0,0,
  	180,963,1,0,0,0,182,977,1,0,0,0,184,979,1,0,0,0,186,1000,1,0,0,0,188,
  	1003,1,0,0,0,190,1008,1,0,0,0,192,1010,1,0,0,0,194,1017,1,0,0,0,196,1022,
  	1,0,0,0,198,1030,1,0,0,0,200,1032,1,0,0,0,202,1043,1,0,0,0,204,1054,1,
  	0,0,0,206,1058,1,0,0,0,208,1061,1,0,0,0,210,1063,1,0,0,0,212,1068,1,0,
  	0,0,214,1073,1,0,0,0,216,1078,1,0,0,0,218,1099,1,0,0,0,220,1102,1,0,0,
  	0,222,1122,1,0,0,0,224,1134,1,0,0,0,226,1136,1,0,0,0,228,1143,1,0,0,0,
  	230,1148,1,0,0,0,232,1167,1,0,0,0,234,1169,1,0,0,0,236,1191,1,0,0,0,238,
  	1193,1,0,0,0,240,1198,1,0,0,0,242,1203,1,0,0,0,244,1208,1,0,0,0,246,1213,
  	1,0,0,0,248,1218,1,0,0,0,250,1223,1,0,0,0,252,1228,1,0,0,0,254,1233,1,
  	0,0,0,256,1238,1,0,0,0,258,1243,1,0,0,0,260,1248,1,0,0,0,262,1253,1,0,
  	0,0,264,1258,1,0,0,0,266,1260,1,0,0,0,268,1262,1,0,0,0,270,1264,1,0,0,
  	0,272,1266,1,0,0,0,274,276,3,2,1,0,275,274,1,0,0,0,276,279,1,0,0,0,277,
  	275,1,0,0,0,277,278,1,0,0,0,278,280,1,0,0,0,279,277,1,0,0,0,280,281,5,
  	0,0,1,281,1,1,0,0,0,282,293,3,26,13,0,283,293,3,48,24,0,284,293,3,216,
  	108,0,285,293,3,212,106,0,286,293,3,66,33,0,287,293,3,218,109,0,288,293,
  	3,198,99,0,289,293,3,222,111,0,290,293,3,228,114,0,291,293,5,335,0,0,
  	292,282,1,0,0,0,292,283,1,0,0,0,292,284,1,0,0,0,292,285,1,0,0,0,292,286,
  	1,0,0,0,292,287,1,0,0,0,292,288,1,0,0,0,292,289,1,0,0,0,292,290,1,0,0,
  	0,292,291,1,0,0,0,293,3,1,0,0,0,294,297,3,6,3,0,295,297,3,8,4,0,296,294,
  	1,0,0,0,296,295,1,0,0,0,297,5,1,0,0,0,298,299,5,369,0,0,299,7,1,0,0,0,
  	300,301,3,10,5,0,301,302,3,6,3,0,302,9,1,0,0,0,303,305,5,334,0,0,304,
  	303,1,0,0,0,304,305,1,0,0,0,305,310,1,0,0,0,306,307,5,369,0,0,307,309,
  	5,334,0,0,308,306,1,0,0,0,309,312,1,0,0,0,310,308,1,0,0,0,310,311,1,0,
  	0,0,311,11,1,0,0,0,312,310,1,0,0,0,313,314,3,14,7,0,314,315,5,335,0,0,
  	315,13,1,0,0,0,316,317,5,32,0,0,317,319,5,369,0,0,318,320,3,16,8,0,319,
  	318,1,0,0,0,319,320,1,0,0,0,320,321,1,0,0,0,321,325,5,309,0,0,322,324,
  	3,18,9,0,323,322,1,0,0,0,324,327,1,0,0,0,325,323,1,0,0,0,325,326,1,0,
  	0,0,326,328,1,0,0,0,327,325,1,0,0,0,328,329,5,310,0,0,329,15,1,0,0,0,
  	330,331,5,333,0,0,331,336,3,4,2,0,332,333,5,336,0,0,333,335,3,4,2,0,334,
  	332,1,0,0,0,335,338,1,0,0,0,336,334,1,0,0,0,336,337,1,0,0,0,337,17,1,
  	0,0,0,338,336,1,0,0,0,339,346,3,48,24,0,340,346,3,216,108,0,341,346,3,
  	212,106,0,342,346,3,198,99,0,343,346,3,26,13,0,344,346,3,68,34,0,345,
  	339,1,0,0,0,345,340,1,0,0,0,345,341,1,0,0,0,345,342,1,0,0,0,345,343,1,
  	0,0,0,345,344,1,0,0,0,346,19,1,0,0,0,347,348,3,22,11,0,348,349,5,335,
  	0,0,349,21,1,0,0,0,350,351,5,191,0,0,351,352,5,369,0,0,352,356,5,309,
  	0,0,353,355,3,24,12,0,354,353,1,0,0,0,355,358,1,0,0,0,356,354,1,0,0,0,
  	356,357,1,0,0,0,357,359,1,0,0,0,358,356,1,0,0,0,359,360,5,310,0,0,360,
  	23,1,0,0,0,361,368,3,48,24,0,362,368,3,216,108,0,363,368,3,212,106,0,
  	364,368,3,26,13,0,365,368,3,198,99,0,366,368,3,68,34,0,367,361,1,0,0,
  	0,367,362,1,0,0,0,367,363,1,0,0,0,367,364,1,0,0,0,367,365,1,0,0,0,367,
  	366,1,0,0,0,368,25,1,0,0,0,369,371,3,68,34,0,370,369,1,0,0,0,371,374,
  	1,0,0,0,372,370,1,0,0,0,372,373,1,0,0,0,373,375,1,0,0,0,374,372,1,0,0,
  	0,375,376,3,38,19,0,376,377,5,335,0,0,377,27,1,0,0,0,378,379,3,30,15,
  	0,379,380,5,335,0,0,380,29,1,0,0,0,381,382,3,32,16,0,382,383,5,369,0,
  	0,383,385,5,309,0,0,384,386,3,34,17,0,385,384,1,0,0,0,385,386,1,0,0,0,
  	386,387,1,0,0,0,387,388,5,310,0,0,388,31,1,0,0,0,389,393,5,62,0,0,390,
  	391,5,62,0,0,391,393,7,0,0,0,392,389,1,0,0,0,392,390,1,0,0,0,393,33,1,
  	0,0,0,394,399,3,36,18,0,395,396,5,336,0,0,396,398,3,36,18,0,397,395,1,
  	0,0,0,398,401,1,0,0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,403,1,0,0,0,
  	401,399,1,0,0,0,402,404,5,336,0,0,403,402,1,0,0,0,403,404,1,0,0,0,404,
  	35,1,0,0,0,405,408,5,369,0,0,406,407,5,337,0,0,407,409,3,86,43,0,408,
  	406,1,0,0,0,408,409,1,0,0,0,409,37,1,0,0,0,410,415,3,14,7,0,411,415,3,
  	42,21,0,412,415,3,22,11,0,413,415,3,30,15,0,414,410,1,0,0,0,414,411,1,
  	0,0,0,414,412,1,0,0,0,414,413,1,0,0,0,415,39,1,0,0,0,416,417,3,42,21,
  	0,417,418,5,335,0,0,418,41,1,0,0,0,419,420,5,143,0,0,420,421,5,369,0,
  	0,421,425,5,309,0,0,422,424,3,44,22,0,423,422,1,0,0,0,424,427,1,0,0,0,
  	425,423,1,0,0,0,425,426,1,0,0,0,426,428,1,0,0,0,427,425,1,0,0,0,428,429,
  	5,310,0,0,429,43,1,0,0,0,430,434,3,212,106,0,431,434,3,192,96,0,432,434,
  	3,26,13,0,433,430,1,0,0,0,433,431,1,0,0,0,433,432,1,0,0,0,434,45,1,0,
  	0,0,435,436,7,1,0,0,436,437,5,312,0,0,437,438,3,124,62,0,438,439,5,314,
  	0,0,439,47,1,0,0,0,440,441,3,102,51,0,441,442,5,335,0,0,442,49,1,0,0,
  	0,443,453,5,259,0,0,444,449,3,52,26,0,445,446,5,336,0,0,446,448,3,52,
  	26,0,447,445,1,0,0,0,448,451,1,0,0,0,449,447,1,0,0,0,449,450,1,0,0,0,
  	450,453,1,0,0,0,451,449,1,0,0,0,452,443,1,0,0,0,452,444,1,0,0,0,453,51,
  	1,0,0,0,454,456,3,68,34,0,455,454,1,0,0,0,456,459,1,0,0,0,457,455,1,0,
  	0,0,457,458,1,0,0,0,458,460,1,0,0,0,459,457,1,0,0,0,460,462,3,124,62,
  	0,461,463,5,369,0,0,462,461,1,0,0,0,462,463,1,0,0,0,463,464,1,0,0,0,464,
  	465,3,106,53,0,465,53,1,0,0,0,466,467,5,333,0,0,467,468,3,56,28,0,468,
  	55,1,0,0,0,469,470,7,2,0,0,470,57,1,0,0,0,471,476,3,182,91,0,472,473,
  	5,336,0,0,473,475,3,182,91,0,474,472,1,0,0,0,475,478,1,0,0,0,476,474,
  	1,0,0,0,476,477,1,0,0,0,477,59,1,0,0,0,478,476,1,0,0,0,479,480,5,305,
  	0,0,480,481,3,58,29,0,481,482,5,306,0,0,482,61,1,0,0,0,483,484,5,91,0,
  	0,484,487,5,334,0,0,485,486,5,369,0,0,486,488,5,334,0,0,487,485,1,0,0,
  	0,487,488,1,0,0,0,488,489,1,0,0,0,489,491,5,369,0,0,490,492,3,60,30,0,
  	491,490,1,0,0,0,491,492,1,0,0,0,492,502,1,0,0,0,493,494,5,369,0,0,494,
  	496,5,334,0,0,495,493,1,0,0,0,495,496,1,0,0,0,496,497,1,0,0,0,497,499,
  	5,369,0,0,498,500,3,60,30,0,499,498,1,0,0,0,499,500,1,0,0,0,500,502,1,
  	0,0,0,501,483,1,0,0,0,501,495,1,0,0,0,502,63,1,0,0,0,503,504,5,307,0,
  	0,504,505,3,62,31,0,505,506,5,308,0,0,506,65,1,0,0,0,507,508,5,311,0,
  	0,508,513,3,62,31,0,509,510,5,336,0,0,510,512,3,62,31,0,511,509,1,0,0,
  	0,512,515,1,0,0,0,513,511,1,0,0,0,513,514,1,0,0,0,514,516,1,0,0,0,515,
  	513,1,0,0,0,516,517,5,308,0,0,517,518,5,308,0,0,518,67,1,0,0,0,519,522,
  	3,64,32,0,520,522,3,66,33,0,521,519,1,0,0,0,521,520,1,0,0,0,522,69,1,
  	0,0,0,523,527,5,309,0,0,524,526,3,72,36,0,525,524,1,0,0,0,526,529,1,0,
  	0,0,527,525,1,0,0,0,527,528,1,0,0,0,528,530,1,0,0,0,529,527,1,0,0,0,530,
  	531,5,310,0,0,531,71,1,0,0,0,532,536,3,48,24,0,533,536,3,82,41,0,534,
  	536,3,26,13,0,535,532,1,0,0,0,535,533,1,0,0,0,535,534,1,0,0,0,536,73,
  	1,0,0,0,537,540,3,102,51,0,538,540,3,88,44,0,539,537,1,0,0,0,539,538,
  	1,0,0,0,540,75,1,0,0,0,541,542,5,27,0,0,542,543,3,86,43,0,543,544,5,333,
  	0,0,544,548,1,0,0,0,545,546,5,37,0,0,546,548,5,333,0,0,547,541,1,0,0,
  	0,547,545,1,0,0,0,548,77,1,0,0,0,549,551,3,76,38,0,550,549,1,0,0,0,551,
  	552,1,0,0,0,552,550,1,0,0,0,552,553,1,0,0,0,553,555,1,0,0,0,554,556,3,
  	72,36,0,555,554,1,0,0,0,556,557,1,0,0,0,557,555,1,0,0,0,557,558,1,0,0,
  	0,558,79,1,0,0,0,559,563,5,309,0,0,560,562,3,78,39,0,561,560,1,0,0,0,
  	562,565,1,0,0,0,563,561,1,0,0,0,563,564,1,0,0,0,564,566,1,0,0,0,565,563,
  	1,0,0,0,566,567,5,310,0,0,567,81,1,0,0,0,568,660,5,335,0,0,569,660,3,
  	70,35,0,570,571,3,88,44,0,571,572,5,335,0,0,572,660,1,0,0,0,573,575,3,
  	64,32,0,574,573,1,0,0,0,575,578,1,0,0,0,576,574,1,0,0,0,576,577,1,0,0,
  	0,577,579,1,0,0,0,578,576,1,0,0,0,579,580,5,113,0,0,580,581,5,305,0,0,
  	581,582,3,88,44,0,582,583,5,306,0,0,583,585,3,82,41,0,584,586,3,84,42,
  	0,585,584,1,0,0,0,585,586,1,0,0,0,586,660,1,0,0,0,587,589,3,64,32,0,588,
  	587,1,0,0,0,589,592,1,0,0,0,590,588,1,0,0,0,590,591,1,0,0,0,591,593,1,
  	0,0,0,592,590,1,0,0,0,593,594,5,195,0,0,594,595,5,305,0,0,595,596,3,88,
  	44,0,596,597,5,306,0,0,597,598,3,80,40,0,598,660,1,0,0,0,599,601,3,64,
  	32,0,600,599,1,0,0,0,601,604,1,0,0,0,602,600,1,0,0,0,602,603,1,0,0,0,
  	603,605,1,0,0,0,604,602,1,0,0,0,605,606,5,260,0,0,606,607,5,305,0,0,607,
  	608,3,88,44,0,608,609,5,306,0,0,609,610,3,82,41,0,610,660,1,0,0,0,611,
  	613,3,64,32,0,612,611,1,0,0,0,613,616,1,0,0,0,614,612,1,0,0,0,614,615,
  	1,0,0,0,615,617,1,0,0,0,616,614,1,0,0,0,617,618,5,39,0,0,618,619,3,82,
  	41,0,619,620,5,260,0,0,620,621,5,305,0,0,621,622,3,88,44,0,622,623,5,
  	306,0,0,623,624,5,335,0,0,624,660,1,0,0,0,625,627,3,64,32,0,626,625,1,
  	0,0,0,627,630,1,0,0,0,628,626,1,0,0,0,628,629,1,0,0,0,629,631,1,0,0,0,
  	630,628,1,0,0,0,631,632,5,88,0,0,632,634,5,305,0,0,633,635,3,74,37,0,
  	634,633,1,0,0,0,634,635,1,0,0,0,635,636,1,0,0,0,636,638,5,335,0,0,637,
  	639,3,88,44,0,638,637,1,0,0,0,638,639,1,0,0,0,639,640,1,0,0,0,640,642,
  	5,335,0,0,641,643,3,88,44,0,642,641,1,0,0,0,642,643,1,0,0,0,643,644,1,
  	0,0,0,644,645,5,306,0,0,645,660,3,82,41,0,646,647,5,26,0,0,647,660,5,
  	335,0,0,648,649,5,36,0,0,649,660,5,335,0,0,650,651,5,38,0,0,651,660,5,
  	335,0,0,652,654,5,172,0,0,653,655,3,88,44,0,654,653,1,0,0,0,654,655,1,
  	0,0,0,655,656,1,0,0,0,656,660,5,335,0,0,657,660,3,218,109,0,658,660,3,
  	198,99,0,659,568,1,0,0,0,659,569,1,0,0,0,659,570,1,0,0,0,659,576,1,0,
  	0,0,659,590,1,0,0,0,659,602,1,0,0,0,659,614,1,0,0,0,659,628,1,0,0,0,659,
  	646,1,0,0,0,659,648,1,0,0,0,659,650,1,0,0,0,659,652,1,0,0,0,659,657,1,
  	0,0,0,659,658,1,0,0,0,660,83,1,0,0,0,661,662,5,61,0,0,662,663,3,82,41,
  	0,663,85,1,0,0,0,664,665,6,43,-1,0,665,689,3,182,91,0,666,689,3,4,2,0,
  	667,668,5,305,0,0,668,669,3,88,44,0,669,670,5,306,0,0,670,689,1,0,0,0,
  	671,672,3,172,86,0,672,673,3,98,49,0,673,689,1,0,0,0,674,675,5,305,0,
  	0,675,679,3,124,62,0,676,678,3,116,58,0,677,676,1,0,0,0,678,681,1,0,0,
  	0,679,677,1,0,0,0,679,680,1,0,0,0,680,682,1,0,0,0,681,679,1,0,0,0,682,
  	683,5,306,0,0,683,684,3,86,43,6,684,689,1,0,0,0,685,686,3,92,46,0,686,
  	687,3,86,43,4,687,689,1,0,0,0,688,664,1,0,0,0,688,666,1,0,0,0,688,667,
  	1,0,0,0,688,671,1,0,0,0,688,674,1,0,0,0,688,685,1,0,0,0,689,718,1,0,0,
  	0,690,691,10,3,0,0,691,692,3,94,47,0,692,693,3,86,43,4,693,717,1,0,0,
  	0,694,695,10,10,0,0,695,696,5,350,0,0,696,717,3,4,2,0,697,698,10,9,0,
  	0,698,699,5,307,0,0,699,700,3,86,43,0,700,701,5,308,0,0,701,717,1,0,0,
  	0,702,703,10,8,0,0,703,717,3,98,49,0,704,705,10,5,0,0,705,717,3,90,45,
  	0,706,707,10,2,0,0,707,708,5,332,0,0,708,709,3,88,44,0,709,710,5,333,
  	0,0,710,711,3,88,44,0,711,717,1,0,0,0,712,713,10,1,0,0,713,714,3,96,48,
  	0,714,715,3,88,44,0,715,717,1,0,0,0,716,690,1,0,0,0,716,694,1,0,0,0,716,
  	697,1,0,0,0,716,702,1,0,0,0,716,704,1,0,0,0,716,706,1,0,0,0,716,712,1,
  	0,0,0,717,720,1,0,0,0,718,716,1,0,0,0,718,719,1,0,0,0,719,87,1,0,0,0,
  	720,718,1,0,0,0,721,722,6,44,-1,0,722,723,3,86,43,0,723,729,1,0,0,0,724,
  	725,10,1,0,0,725,726,5,336,0,0,726,728,3,86,43,0,727,724,1,0,0,0,728,
  	731,1,0,0,0,729,727,1,0,0,0,729,730,1,0,0,0,730,89,1,0,0,0,731,729,1,
  	0,0,0,732,733,7,3,0,0,733,91,1,0,0,0,734,735,7,4,0,0,735,93,1,0,0,0,736,
  	737,7,5,0,0,737,95,1,0,0,0,738,739,7,6,0,0,739,97,1,0,0,0,740,742,5,305,
  	0,0,741,743,3,100,50,0,742,741,1,0,0,0,742,743,1,0,0,0,743,744,1,0,0,
  	0,744,745,5,306,0,0,745,99,1,0,0,0,746,751,3,86,43,0,747,748,5,336,0,
  	0,748,750,3,86,43,0,749,747,1,0,0,0,750,753,1,0,0,0,751,749,1,0,0,0,751,
  	752,1,0,0,0,752,101,1,0,0,0,753,751,1,0,0,0,754,756,3,68,34,0,755,754,
  	1,0,0,0,756,759,1,0,0,0,757,755,1,0,0,0,757,758,1,0,0,0,758,760,1,0,0,
  	0,759,757,1,0,0,0,760,761,3,124,62,0,761,762,3,104,52,0,762,103,1,0,0,
  	0,763,768,3,108,54,0,764,765,5,336,0,0,765,767,3,108,54,0,766,764,1,0,
  	0,0,767,770,1,0,0,0,768,766,1,0,0,0,768,769,1,0,0,0,769,105,1,0,0,0,770,
  	768,1,0,0,0,771,773,3,116,58,0,772,771,1,0,0,0,773,776,1,0,0,0,774,772,
  	1,0,0,0,774,775,1,0,0,0,775,778,1,0,0,0,776,774,1,0,0,0,777,779,3,54,
  	27,0,778,777,1,0,0,0,778,779,1,0,0,0,779,781,1,0,0,0,780,782,3,118,59,
  	0,781,780,1,0,0,0,781,782,1,0,0,0,782,784,1,0,0,0,783,785,3,178,89,0,
  	784,783,1,0,0,0,784,785,1,0,0,0,785,787,1,0,0,0,786,788,3,110,55,0,787,
  	786,1,0,0,0,787,788,1,0,0,0,788,107,1,0,0,0,789,790,5,369,0,0,790,791,
  	3,106,53,0,791,109,1,0,0,0,792,793,5,337,0,0,793,796,3,112,56,0,794,796,
  	3,234,117,0,795,792,1,0,0,0,795,794,1,0,0,0,796,111,1,0,0,0,797,798,5,
  	309,0,0,798,799,3,114,57,0,799,800,5,310,0,0,800,803,1,0,0,0,801,803,
  	3,86,43,0,802,797,1,0,0,0,802,801,1,0,0,0,803,113,1,0,0,0,804,809,3,112,
  	56,0,805,806,5,336,0,0,806,808,3,112,56,0,807,805,1,0,0,0,808,811,1,0,
  	0,0,809,807,1,0,0,0,809,810,1,0,0,0,810,813,1,0,0,0,811,809,1,0,0,0,812,
  	814,5,336,0,0,813,812,1,0,0,0,813,814,1,0,0,0,814,115,1,0,0,0,815,817,
  	5,307,0,0,816,818,3,86,43,0,817,816,1,0,0,0,817,818,1,0,0,0,818,819,1,
  	0,0,0,819,820,5,308,0,0,820,117,1,0,0,0,821,822,5,333,0,0,822,823,5,157,
  	0,0,823,824,5,305,0,0,824,827,5,369,0,0,825,826,5,350,0,0,826,828,5,369,
  	0,0,827,825,1,0,0,0,827,828,1,0,0,0,828,829,1,0,0,0,829,830,5,306,0,0,
  	830,119,1,0,0,0,831,833,3,122,61,0,832,831,1,0,0,0,833,836,1,0,0,0,834,
  	835,1,0,0,0,834,832,1,0,0,0,835,121,1,0,0,0,836,834,1,0,0,0,837,838,7,
  	7,0,0,838,123,1,0,0,0,839,844,3,120,60,0,840,845,3,126,63,0,841,845,3,
  	190,95,0,842,845,3,200,100,0,843,845,5,259,0,0,844,840,1,0,0,0,844,841,
  	1,0,0,0,844,842,1,0,0,0,844,843,1,0,0,0,845,125,1,0,0,0,846,865,3,134,
  	67,0,847,865,3,138,69,0,848,865,3,140,70,0,849,865,3,174,87,0,850,865,
  	3,176,88,0,851,865,3,144,72,0,852,865,3,146,73,0,853,865,3,148,74,0,854,
  	865,3,152,76,0,855,865,3,158,79,0,856,865,3,160,80,0,857,865,3,164,82,
  	0,858,865,3,166,83,0,859,865,3,168,84,0,860,865,3,46,23,0,861,865,3,130,
  	65,0,862,865,3,128,64,0,863,865,3,132,66,0,864,846,1,0,0,0,864,847,1,
  	0,0,0,864,848,1,0,0,0,864,849,1,0,0,0,864,850,1,0,0,0,864,851,1,0,0,0,
  	864,852,1,0,0,0,864,853,1,0,0,0,864,854,1,0,0,0,864,855,1,0,0,0,864,856,
  	1,0,0,0,864,857,1,0,0,0,864,858,1,0,0,0,864,859,1,0,0,0,864,860,1,0,0,
  	0,864,861,1,0,0,0,864,862,1,0,0,0,864,863,1,0,0,0,865,127,1,0,0,0,866,
  	867,7,8,0,0,867,129,1,0,0,0,868,869,5,170,0,0,869,131,1,0,0,0,870,871,
  	7,9,0,0,871,133,1,0,0,0,872,873,3,136,68,0,873,874,5,312,0,0,874,875,
  	3,172,86,0,875,876,5,314,0,0,876,135,1,0,0,0,877,878,7,10,0,0,878,137,
  	1,0,0,0,879,880,7,11,0,0,880,139,1,0,0,0,881,882,3,142,71,0,882,883,5,
  	312,0,0,883,884,3,190,95,0,884,885,5,336,0,0,885,886,5,370,0,0,886,887,
  	5,314,0,0,887,141,1,0,0,0,888,889,7,12,0,0,889,143,1,0,0,0,890,891,7,
  	13,0,0,891,145,1,0,0,0,892,893,7,14,0,0,893,147,1,0,0,0,894,895,3,150,
  	75,0,895,896,5,312,0,0,896,897,3,124,62,0,897,898,5,314,0,0,898,149,1,
  	0,0,0,899,900,7,15,0,0,900,151,1,0,0,0,901,902,3,154,77,0,902,903,5,312,
  	0,0,903,904,3,124,62,0,904,905,5,314,0,0,905,153,1,0,0,0,906,907,7,16,
  	0,0,907,155,1,0,0,0,908,909,7,17,0,0,909,157,1,0,0,0,910,911,3,156,78,
  	0,911,159,1,0,0,0,912,913,3,156,78,0,913,914,5,312,0,0,914,915,3,170,
  	85,0,915,916,5,314,0,0,916,161,1,0,0,0,917,918,7,18,0,0,918,163,1,0,0,
  	0,919,920,3,162,81,0,920,921,5,312,0,0,921,924,3,170,85,0,922,923,5,336,
  	0,0,923,925,5,370,0,0,924,922,1,0,0,0,924,925,1,0,0,0,925,926,1,0,0,0,
  	926,927,5,314,0,0,927,165,1,0,0,0,928,929,7,19,0,0,929,167,1,0,0,0,930,
  	931,5,257,0,0,931,932,5,312,0,0,932,933,3,146,73,0,933,934,5,336,0,0,
  	934,935,5,370,0,0,935,936,5,314,0,0,936,169,1,0,0,0,937,940,3,146,73,
  	0,938,940,3,166,83,0,939,937,1,0,0,0,939,938,1,0,0,0,940,171,1,0,0,0,
  	941,945,3,146,73,0,942,945,3,166,83,0,943,945,3,174,87,0,944,941,1,0,
  	0,0,944,942,1,0,0,0,944,943,1,0,0,0,945,173,1,0,0,0,946,947,7,20,0,0,
  	947,175,1,0,0,0,948,949,5,149,0,0,949,950,5,312,0,0,950,951,3,146,73,
  	0,951,952,5,336,0,0,952,953,5,370,0,0,953,954,5,336,0,0,954,955,5,370,
  	0,0,955,956,5,314,0,0,956,177,1,0,0,0,957,958,5,333,0,0,958,959,5,171,
  	0,0,959,960,5,305,0,0,960,961,5,369,0,0,961,962,5,306,0,0,962,179,1,0,
  	0,0,963,964,5,369,0,0,964,965,5,337,0,0,965,966,3,86,43,0,966,967,5,335,
  	0,0,967,181,1,0,0,0,968,978,5,351,0,0,969,978,5,352,0,0,970,978,5,371,
  	0,0,971,978,5,370,0,0,972,974,5,372,0,0,973,972,1,0,0,0,974,975,1,0,0,
  	0,975,973,1,0,0,0,975,976,1,0,0,0,976,978,1,0,0,0,977,968,1,0,0,0,977,
  	969,1,0,0,0,977,970,1,0,0,0,977,971,1,0,0,0,977,973,1,0,0,0,978,183,1,
  	0,0,0,979,983,3,124,62,0,980,981,3,190,95,0,981,982,5,334,0,0,982,984,
  	1,0,0,0,983,980,1,0,0,0,983,984,1,0,0,0,984,985,1,0,0,0,985,987,5,369,
  	0,0,986,988,3,202,101,0,987,986,1,0,0,0,987,988,1,0,0,0,988,989,1,0,0,
  	0,989,991,5,305,0,0,990,992,3,50,25,0,991,990,1,0,0,0,991,992,1,0,0,0,
  	992,993,1,0,0,0,993,995,5,306,0,0,994,996,5,155,0,0,995,994,1,0,0,0,995,
  	996,1,0,0,0,996,998,1,0,0,0,997,999,3,54,27,0,998,997,1,0,0,0,998,999,
  	1,0,0,0,999,185,1,0,0,0,1000,1001,3,184,92,0,1001,1002,3,70,35,0,1002,
  	187,1,0,0,0,1003,1004,3,184,92,0,1004,1005,5,335,0,0,1005,189,1,0,0,0,
  	1006,1009,3,4,2,0,1007,1009,3,38,19,0,1008,1006,1,0,0,0,1008,1007,1,0,
  	0,0,1009,191,1,0,0,0,1010,1011,5,353,0,0,1011,1013,5,369,0,0,1012,1014,
  	3,206,103,0,1013,1012,1,0,0,0,1013,1014,1,0,0,0,1014,1015,1,0,0,0,1015,
  	1016,5,335,0,0,1016,193,1,0,0,0,1017,1018,5,355,0,0,1018,1019,3,124,62,
  	0,1019,1020,5,369,0,0,1020,1021,5,335,0,0,1021,195,1,0,0,0,1022,1023,
  	5,354,0,0,1023,1024,5,369,0,0,1024,1025,5,337,0,0,1025,1026,3,124,62,
  	0,1026,1027,5,335,0,0,1027,197,1,0,0,0,1028,1031,3,196,98,0,1029,1031,
  	3,194,97,0,1030,1028,1,0,0,0,1030,1029,1,0,0,0,1031,199,1,0,0,0,1032,
  	1033,5,357,0,0,1033,1036,5,305,0,0,1034,1037,3,88,44,0,1035,1037,3,124,
  	62,0,1036,1034,1,0,0,0,1036,1035,1,0,0,0,1037,1038,1,0,0,0,1038,1041,
  	5,306,0,0,1039,1040,5,334,0,0,1040,1042,3,4,2,0,1041,1039,1,0,0,0,1041,
  	1042,1,0,0,0,1042,201,1,0,0,0,1043,1044,5,312,0,0,1044,1049,3,204,102,
  	0,1045,1046,5,336,0,0,1046,1048,3,204,102,0,1047,1045,1,0,0,0,1048,1051,
  	1,0,0,0,1049,1047,1,0,0,0,1049,1050,1,0,0,0,1050,1052,1,0,0,0,1051,1049,
  	1,0,0,0,1052,1053,5,314,0,0,1053,203,1,0,0,0,1054,1056,5,369,0,0,1055,
  	1057,3,206,103,0,1056,1055,1,0,0,0,1056,1057,1,0,0,0,1057,205,1,0,0,0,
  	1058,1059,5,333,0,0,1059,1060,3,190,95,0,1060,207,1,0,0,0,1061,1062,5,
  	356,0,0,1062,209,1,0,0,0,1063,1064,3,188,94,0,1064,211,1,0,0,0,1065,1067,
  	3,68,34,0,1066,1065,1,0,0,0,1067,1070,1,0,0,0,1068,1066,1,0,0,0,1068,
  	1069,1,0,0,0,1069,1071,1,0,0,0,1070,1068,1,0,0,0,1071,1072,3,210,105,
  	0,1072,213,1,0,0,0,1073,1074,3,186,93,0,1074,215,1,0,0,0,1075,1077,3,
  	68,34,0,1076,1075,1,0,0,0,1077,1080,1,0,0,0,1078,1076,1,0,0,0,1078,1079,
  	1,0,0,0,1079,1081,1,0,0,0,1080,1078,1,0,0,0,1081,1082,3,214,107,0,1082,
  	217,1,0,0,0,1083,1084,5,362,0,0,1084,1085,5,305,0,0,1085,1086,5,372,0,
  	0,1086,1087,5,306,0,0,1087,1100,5,335,0,0,1088,1089,5,363,0,0,1089,1092,
  	5,305,0,0,1090,1093,3,4,2,0,1091,1093,3,200,100,0,1092,1090,1,0,0,0,1092,
  	1091,1,0,0,0,1093,1094,1,0,0,0,1094,1095,5,336,0,0,1095,1096,7,21,0,0,
  	1096,1097,5,306,0,0,1097,1098,5,335,0,0,1098,1100,1,0,0,0,1099,1083,1,
  	0,0,0,1099,1088,1,0,0,0,1100,219,1,0,0,0,1101,1103,5,156,0,0,1102,1101,
  	1,0,0,0,1102,1103,1,0,0,0,1103,1104,1,0,0,0,1104,1105,5,361,0,0,1105,
  	1108,5,369,0,0,1106,1107,5,333,0,0,1107,1109,5,369,0,0,1108,1106,1,0,
  	0,0,1108,1109,1,0,0,0,1109,1110,1,0,0,0,1110,1114,5,309,0,0,1111,1113,
  	3,224,112,0,1112,1111,1,0,0,0,1113,1116,1,0,0,0,1114,1112,1,0,0,0,1114,
  	1115,1,0,0,0,1115,1117,1,0,0,0,1116,1114,1,0,0,0,1117,1118,5,310,0,0,
  	1118,221,1,0,0,0,1119,1121,3,68,34,0,1120,1119,1,0,0,0,1121,1124,1,0,
  	0,0,1122,1120,1,0,0,0,1122,1123,1,0,0,0,1123,1125,1,0,0,0,1124,1122,1,
  	0,0,0,1125,1126,3,220,110,0,1126,223,1,0,0,0,1127,1135,3,20,10,0,1128,
  	1135,3,212,106,0,1129,1135,3,216,108,0,1130,1135,3,48,24,0,1131,1135,
  	3,28,14,0,1132,1135,3,198,99,0,1133,1135,3,68,34,0,1134,1127,1,0,0,0,
  	1134,1128,1,0,0,0,1134,1129,1,0,0,0,1134,1130,1,0,0,0,1134,1131,1,0,0,
  	0,1134,1132,1,0,0,0,1134,1133,1,0,0,0,1135,225,1,0,0,0,1136,1137,5,360,
  	0,0,1137,1138,5,369,0,0,1138,1139,3,230,115,0,1139,227,1,0,0,0,1140,1142,
  	3,68,34,0,1141,1140,1,0,0,0,1142,1145,1,0,0,0,1143,1141,1,0,0,0,1143,
  	1144,1,0,0,0,1144,1146,1,0,0,0,1145,1143,1,0,0,0,1146,1147,3,226,113,
  	0,1147,229,1,0,0,0,1148,1152,5,309,0,0,1149,1151,3,232,116,0,1150,1149,
  	1,0,0,0,1151,1154,1,0,0,0,1152,1150,1,0,0,0,1152,1153,1,0,0,0,1153,1155,
  	1,0,0,0,1154,1152,1,0,0,0,1155,1156,5,310,0,0,1156,231,1,0,0,0,1157,1158,
  	5,358,0,0,1158,1159,5,337,0,0,1159,1160,3,182,91,0,1160,1161,5,335,0,
  	0,1161,1168,1,0,0,0,1162,1163,5,359,0,0,1163,1164,5,337,0,0,1164,1165,
  	3,182,91,0,1165,1166,5,335,0,0,1166,1168,1,0,0,0,1167,1157,1,0,0,0,1167,
  	1162,1,0,0,0,1168,233,1,0,0,0,1169,1173,5,309,0,0,1170,1172,3,236,118,
  	0,1171,1170,1,0,0,0,1172,1175,1,0,0,0,1173,1171,1,0,0,0,1173,1174,1,0,
  	0,0,1174,1176,1,0,0,0,1175,1173,1,0,0,0,1176,1177,5,310,0,0,1177,235,
  	1,0,0,0,1178,1192,3,238,119,0,1179,1192,3,240,120,0,1180,1192,3,242,121,
  	0,1181,1192,3,244,122,0,1182,1192,3,246,123,0,1183,1192,3,248,124,0,1184,
  	1192,3,250,125,0,1185,1192,3,252,126,0,1186,1192,3,254,127,0,1187,1192,
  	3,256,128,0,1188,1192,3,258,129,0,1189,1192,3,260,130,0,1190,1192,3,262,
  	131,0,1191,1178,1,0,0,0,1191,1179,1,0,0,0,1191,1180,1,0,0,0,1191,1181,
  	1,0,0,0,1191,1182,1,0,0,0,1191,1183,1,0,0,0,1191,1184,1,0,0,0,1191,1185,
  	1,0,0,0,1191,1186,1,0,0,0,1191,1187,1,0,0,0,1191,1188,1,0,0,0,1191,1189,
  	1,0,0,0,1191,1190,1,0,0,0,1192,237,1,0,0,0,1193,1194,5,277,0,0,1194,1195,
  	5,337,0,0,1195,1196,5,370,0,0,1196,1197,5,335,0,0,1197,239,1,0,0,0,1198,
  	1199,5,274,0,0,1199,1200,5,337,0,0,1200,1201,3,264,132,0,1201,1202,5,
  	335,0,0,1202,241,1,0,0,0,1203,1204,5,275,0,0,1204,1205,5,337,0,0,1205,
  	1206,3,264,132,0,1206,1207,5,335,0,0,1207,243,1,0,0,0,1208,1209,5,276,
  	0,0,1209,1210,5,337,0,0,1210,1211,3,264,132,0,1211,1212,5,335,0,0,1212,
  	245,1,0,0,0,1213,1214,5,282,0,0,1214,1215,5,337,0,0,1215,1216,3,266,133,
  	0,1216,1217,5,335,0,0,1217,247,1,0,0,0,1218,1219,5,281,0,0,1219,1220,
  	5,337,0,0,1220,1221,3,270,135,0,1221,1222,5,335,0,0,1222,249,1,0,0,0,
  	1223,1224,5,270,0,0,1224,1225,5,337,0,0,1225,1226,3,268,134,0,1226,1227,
  	5,335,0,0,1227,251,1,0,0,0,1228,1229,5,271,0,0,1229,1230,5,337,0,0,1230,
  	1231,3,268,134,0,1231,1232,5,335,0,0,1232,253,1,0,0,0,1233,1234,5,272,
  	0,0,1234,1235,5,337,0,0,1235,1236,3,268,134,0,1236,1237,5,335,0,0,1237,
  	255,1,0,0,0,1238,1239,5,279,0,0,1239,1240,5,337,0,0,1240,1241,5,371,0,
  	0,1241,1242,5,335,0,0,1242,257,1,0,0,0,1243,1244,5,278,0,0,1244,1245,
  	5,337,0,0,1245,1246,5,371,0,0,1246,1247,5,335,0,0,1247,259,1,0,0,0,1248,
  	1249,5,280,0,0,1249,1250,5,337,0,0,1250,1251,5,371,0,0,1251,1252,5,335,
  	0,0,1252,261,1,0,0,0,1253,1254,5,273,0,0,1254,1255,5,337,0,0,1255,1256,
  	3,272,136,0,1256,1257,5,335,0,0,1257,263,1,0,0,0,1258,1259,7,22,0,0,1259,
  	265,1,0,0,0,1260,1261,7,23,0,0,1261,267,1,0,0,0,1262,1263,7,24,0,0,1263,
  	269,1,0,0,0,1264,1265,7,25,0,0,1265,271,1,0,0,0,1266,1267,7,26,0,0,1267,
  	273,1,0,0,0,104,277,292,296,304,310,319,325,336,345,356,367,372,385,392,
  	399,403,408,414,425,433,449,452,457,462,476,487,491,495,499,501,513,521,
  	527,535,539,547,552,557,563,576,585,590,602,614,628,634,638,642,654,659,
  	679,688,716,718,729,742,751,757,768,774,778,781,784,787,795,802,809,813,
  	817,827,834,844,864,924,939,944,975,977,983,987,991,995,998,1008,1013,
  	1030,1036,1041,1049,1056,1068,1078,1092,1099,1102,1108,1114,1122,1134,
  	1143,1152,1167,1173,1191
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  azslparserParserStaticData = std::move(staticData);
}

}

azslParser::azslParser(TokenStream *input) : azslParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

azslParser::azslParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  azslParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *azslparserParserStaticData->atn, azslparserParserStaticData->decisionToDFA, azslparserParserStaticData->sharedContextCache, options);
}

azslParser::~azslParser() {
  delete _interpreter;
}

const atn::ATN& azslParser::getATN() const {
  return *azslparserParserStaticData->atn;
}

std::string azslParser::getGrammarFileName() const {
  return "azslParser.g4";
}

const std::vector<std::string>& azslParser::getRuleNames() const {
  return azslparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& azslParser::getVocabulary() const {
  return azslparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView azslParser::getSerializedATN() const {
  return azslparserParserStaticData->serializedATN;
}


//----------------- CompilationUnitContext ------------------------------------------------------------------

azslParser::CompilationUnitContext::CompilationUnitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::CompilationUnitContext::EOF() {
  return getToken(azslParser::EOF, 0);
}

std::vector<azslParser::TopLevelDeclarationContext *> azslParser::CompilationUnitContext::topLevelDeclaration() {
  return getRuleContexts<azslParser::TopLevelDeclarationContext>();
}

azslParser::TopLevelDeclarationContext* azslParser::CompilationUnitContext::topLevelDeclaration(size_t i) {
  return getRuleContext<azslParser::TopLevelDeclarationContext>(i);
}


size_t azslParser::CompilationUnitContext::getRuleIndex() const {
  return azslParser::RuleCompilationUnit;
}

void azslParser::CompilationUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompilationUnit(this);
}

void azslParser::CompilationUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompilationUnit(this);
}

azslParser::CompilationUnitContext* azslParser::compilationUnit() {
  CompilationUnitContext *_localctx = _tracker.createInstance<CompilationUnitContext>(_ctx, getState());
  enterRule(_localctx, 0, azslParser::RuleCompilationUnit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(277);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26388951203841) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -25) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 38280596832665583) != 0) || ((((_la - 334) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 334)) & 35377905667) != 0)) {
      setState(274);
      antlrcpp::downCast<CompilationUnitContext *>(_localctx)->topLevelDeclarationContext = topLevelDeclaration();
      antlrcpp::downCast<CompilationUnitContext *>(_localctx)->Declarations.push_back(antlrcpp::downCast<CompilationUnitContext *>(_localctx)->topLevelDeclarationContext);
      setState(279);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(280);
    match(azslParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TopLevelDeclarationContext ------------------------------------------------------------------

azslParser::TopLevelDeclarationContext::TopLevelDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::TopLevelDeclarationContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}

azslParser::VariableDeclarationStatementContext* azslParser::TopLevelDeclarationContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::TopLevelDeclarationContext::attributedFunctionDefinition() {
  return getRuleContext<azslParser::AttributedFunctionDefinitionContext>(0);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::TopLevelDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::AttributeSpecifierSequenceContext* azslParser::TopLevelDeclarationContext::attributeSpecifierSequence() {
  return getRuleContext<azslParser::AttributeSpecifierSequenceContext>(0);
}

azslParser::CompilerExtensionStatementContext* azslParser::TopLevelDeclarationContext::compilerExtensionStatement() {
  return getRuleContext<azslParser::CompilerExtensionStatementContext>(0);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::TopLevelDeclarationContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::AttributedSrgDefinitionContext* azslParser::TopLevelDeclarationContext::attributedSrgDefinition() {
  return getRuleContext<azslParser::AttributedSrgDefinitionContext>(0);
}

azslParser::AttributedSrgSemanticContext* azslParser::TopLevelDeclarationContext::attributedSrgSemantic() {
  return getRuleContext<azslParser::AttributedSrgSemanticContext>(0);
}

tree::TerminalNode* azslParser::TopLevelDeclarationContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::TopLevelDeclarationContext::getRuleIndex() const {
  return azslParser::RuleTopLevelDeclaration;
}

void azslParser::TopLevelDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopLevelDeclaration(this);
}

void azslParser::TopLevelDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopLevelDeclaration(this);
}

azslParser::TopLevelDeclarationContext* azslParser::topLevelDeclaration() {
  TopLevelDeclarationContext *_localctx = _tracker.createInstance<TopLevelDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 2, azslParser::RuleTopLevelDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(292);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(282);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(283);
      variableDeclarationStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(284);
      attributedFunctionDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(285);
      attributedFunctionDeclaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(286);
      attributeSpecifierSequence();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(287);
      compilerExtensionStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(288);
      typeAliasingDefinitionStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(289);
      attributedSrgDefinition();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(290);
      attributedSrgSemantic();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(291);
      match(azslParser::Semi);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdExpressionContext ------------------------------------------------------------------

azslParser::IdExpressionContext::IdExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::UnqualifiedIdContext* azslParser::IdExpressionContext::unqualifiedId() {
  return getRuleContext<azslParser::UnqualifiedIdContext>(0);
}

azslParser::QualifiedIdContext* azslParser::IdExpressionContext::qualifiedId() {
  return getRuleContext<azslParser::QualifiedIdContext>(0);
}


size_t azslParser::IdExpressionContext::getRuleIndex() const {
  return azslParser::RuleIdExpression;
}

void azslParser::IdExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdExpression(this);
}

void azslParser::IdExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdExpression(this);
}

azslParser::IdExpressionContext* azslParser::idExpression() {
  IdExpressionContext *_localctx = _tracker.createInstance<IdExpressionContext>(_ctx, getState());
  enterRule(_localctx, 4, azslParser::RuleIdExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(296);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(294);
      unqualifiedId();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(295);
      qualifiedId();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnqualifiedIdContext ------------------------------------------------------------------

azslParser::UnqualifiedIdContext::UnqualifiedIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::UnqualifiedIdContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::UnqualifiedIdContext::getRuleIndex() const {
  return azslParser::RuleUnqualifiedId;
}

void azslParser::UnqualifiedIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnqualifiedId(this);
}

void azslParser::UnqualifiedIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnqualifiedId(this);
}

azslParser::UnqualifiedIdContext* azslParser::unqualifiedId() {
  UnqualifiedIdContext *_localctx = _tracker.createInstance<UnqualifiedIdContext>(_ctx, getState());
  enterRule(_localctx, 6, azslParser::RuleUnqualifiedId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(298);
    match(azslParser::Identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdContext ------------------------------------------------------------------

azslParser::QualifiedIdContext::QualifiedIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::NestedNameSpecifierContext* azslParser::QualifiedIdContext::nestedNameSpecifier() {
  return getRuleContext<azslParser::NestedNameSpecifierContext>(0);
}

azslParser::UnqualifiedIdContext* azslParser::QualifiedIdContext::unqualifiedId() {
  return getRuleContext<azslParser::UnqualifiedIdContext>(0);
}


size_t azslParser::QualifiedIdContext::getRuleIndex() const {
  return azslParser::RuleQualifiedId;
}

void azslParser::QualifiedIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedId(this);
}

void azslParser::QualifiedIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedId(this);
}

azslParser::QualifiedIdContext* azslParser::qualifiedId() {
  QualifiedIdContext *_localctx = _tracker.createInstance<QualifiedIdContext>(_ctx, getState());
  enterRule(_localctx, 8, azslParser::RuleQualifiedId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(300);
    nestedNameSpecifier();
    setState(301);
    unqualifiedId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NestedNameSpecifierContext ------------------------------------------------------------------

azslParser::NestedNameSpecifierContext::NestedNameSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> azslParser::NestedNameSpecifierContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::NestedNameSpecifierContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

std::vector<tree::TerminalNode *> azslParser::NestedNameSpecifierContext::ColonColon() {
  return getTokens(azslParser::ColonColon);
}

tree::TerminalNode* azslParser::NestedNameSpecifierContext::ColonColon(size_t i) {
  return getToken(azslParser::ColonColon, i);
}


size_t azslParser::NestedNameSpecifierContext::getRuleIndex() const {
  return azslParser::RuleNestedNameSpecifier;
}

void azslParser::NestedNameSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNestedNameSpecifier(this);
}

void azslParser::NestedNameSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNestedNameSpecifier(this);
}

azslParser::NestedNameSpecifierContext* azslParser::nestedNameSpecifier() {
  NestedNameSpecifierContext *_localctx = _tracker.createInstance<NestedNameSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 10, azslParser::RuleNestedNameSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(304);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::ColonColon) {
      setState(303);
      antlrcpp::downCast<NestedNameSpecifierContext *>(_localctx)->GlobalSROToken = match(azslParser::ColonColon);
    }
    setState(310);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(306);
        match(azslParser::Identifier);
        setState(307);
        match(azslParser::ColonColon); 
      }
      setState(312);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDefinitionStatementContext ------------------------------------------------------------------

azslParser::ClassDefinitionStatementContext::ClassDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::ClassDefinitionContext* azslParser::ClassDefinitionStatementContext::classDefinition() {
  return getRuleContext<azslParser::ClassDefinitionContext>(0);
}

tree::TerminalNode* azslParser::ClassDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::ClassDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleClassDefinitionStatement;
}

void azslParser::ClassDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassDefinitionStatement(this);
}

void azslParser::ClassDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassDefinitionStatement(this);
}

azslParser::ClassDefinitionStatementContext* azslParser::classDefinitionStatement() {
  ClassDefinitionStatementContext *_localctx = _tracker.createInstance<ClassDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 12, azslParser::RuleClassDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(313);
    classDefinition();
    setState(314);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDefinitionContext ------------------------------------------------------------------

azslParser::ClassDefinitionContext::ClassDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ClassDefinitionContext::Class() {
  return getToken(azslParser::Class, 0);
}

tree::TerminalNode* azslParser::ClassDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::ClassDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

tree::TerminalNode* azslParser::ClassDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

std::vector<azslParser::ClassMemberDeclarationContext *> azslParser::ClassDefinitionContext::classMemberDeclaration() {
  return getRuleContexts<azslParser::ClassMemberDeclarationContext>();
}

azslParser::ClassMemberDeclarationContext* azslParser::ClassDefinitionContext::classMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::ClassMemberDeclarationContext>(i);
}

azslParser::BaseListContext* azslParser::ClassDefinitionContext::baseList() {
  return getRuleContext<azslParser::BaseListContext>(0);
}


size_t azslParser::ClassDefinitionContext::getRuleIndex() const {
  return azslParser::RuleClassDefinition;
}

void azslParser::ClassDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassDefinition(this);
}

void azslParser::ClassDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassDefinition(this);
}

azslParser::ClassDefinitionContext* azslParser::classDefinition() {
  ClassDefinitionContext *_localctx = _tracker.createInstance<ClassDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 14, azslParser::RuleClassDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(316);
    match(azslParser::Class);
    setState(317);
    antlrcpp::downCast<ClassDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(319);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(318);
      antlrcpp::downCast<ClassDefinitionContext *>(_localctx)->BaseListOpt = baseList();
    }
    setState(321);
    match(azslParser::LeftBrace);
    setState(325);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -25) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 38280596832665583) != 0) || ((((_la - 334) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 334)) & 34371272705) != 0)) {
      setState(322);
      classMemberDeclaration();
      setState(327);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(328);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseListContext ------------------------------------------------------------------

azslParser::BaseListContext::BaseListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BaseListContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

std::vector<azslParser::IdExpressionContext *> azslParser::BaseListContext::idExpression() {
  return getRuleContexts<azslParser::IdExpressionContext>();
}

azslParser::IdExpressionContext* azslParser::BaseListContext::idExpression(size_t i) {
  return getRuleContext<azslParser::IdExpressionContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::BaseListContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::BaseListContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::BaseListContext::getRuleIndex() const {
  return azslParser::RuleBaseList;
}

void azslParser::BaseListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseList(this);
}

void azslParser::BaseListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseList(this);
}

azslParser::BaseListContext* azslParser::baseList() {
  BaseListContext *_localctx = _tracker.createInstance<BaseListContext>(_ctx, getState());
  enterRule(_localctx, 16, azslParser::RuleBaseList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(330);
    match(azslParser::Colon);
    setState(331);
    idExpression();
    setState(336);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(332);
      match(azslParser::Comma);
      setState(333);
      idExpression();
      setState(338);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassMemberDeclarationContext ------------------------------------------------------------------

azslParser::ClassMemberDeclarationContext::ClassMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationStatementContext* azslParser::ClassMemberDeclarationContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::ClassMemberDeclarationContext::attributedFunctionDefinition() {
  return getRuleContext<azslParser::AttributedFunctionDefinitionContext>(0);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::ClassMemberDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::ClassMemberDeclarationContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::ClassMemberDeclarationContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}

azslParser::AttributeSpecifierAnyContext* azslParser::ClassMemberDeclarationContext::attributeSpecifierAny() {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(0);
}


size_t azslParser::ClassMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleClassMemberDeclaration;
}

void azslParser::ClassMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassMemberDeclaration(this);
}

void azslParser::ClassMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassMemberDeclaration(this);
}

azslParser::ClassMemberDeclarationContext* azslParser::classMemberDeclaration() {
  ClassMemberDeclarationContext *_localctx = _tracker.createInstance<ClassMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 18, azslParser::RuleClassMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(345);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(339);
      variableDeclarationStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(340);
      attributedFunctionDefinition();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(341);
      attributedFunctionDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(342);
      typeAliasingDefinitionStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(343);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(344);
      attributeSpecifierAny();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructDefinitionStatementContext ------------------------------------------------------------------

azslParser::StructDefinitionStatementContext::StructDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StructDefinitionContext* azslParser::StructDefinitionStatementContext::structDefinition() {
  return getRuleContext<azslParser::StructDefinitionContext>(0);
}

tree::TerminalNode* azslParser::StructDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::StructDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleStructDefinitionStatement;
}

void azslParser::StructDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructDefinitionStatement(this);
}

void azslParser::StructDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructDefinitionStatement(this);
}

azslParser::StructDefinitionStatementContext* azslParser::structDefinitionStatement() {
  StructDefinitionStatementContext *_localctx = _tracker.createInstance<StructDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 20, azslParser::RuleStructDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(347);
    structDefinition();
    setState(348);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructDefinitionContext ------------------------------------------------------------------

azslParser::StructDefinitionContext::StructDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StructDefinitionContext::Struct() {
  return getToken(azslParser::Struct, 0);
}

tree::TerminalNode* azslParser::StructDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::StructDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

tree::TerminalNode* azslParser::StructDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

std::vector<azslParser::StructMemberDeclarationContext *> azslParser::StructDefinitionContext::structMemberDeclaration() {
  return getRuleContexts<azslParser::StructMemberDeclarationContext>();
}

azslParser::StructMemberDeclarationContext* azslParser::StructDefinitionContext::structMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::StructMemberDeclarationContext>(i);
}


size_t azslParser::StructDefinitionContext::getRuleIndex() const {
  return azslParser::RuleStructDefinition;
}

void azslParser::StructDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructDefinition(this);
}

void azslParser::StructDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructDefinition(this);
}

azslParser::StructDefinitionContext* azslParser::structDefinition() {
  StructDefinitionContext *_localctx = _tracker.createInstance<StructDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 22, azslParser::RuleStructDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(350);
    match(azslParser::Struct);
    setState(351);
    antlrcpp::downCast<StructDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(352);
    match(azslParser::LeftBrace);
    setState(356);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -25) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 38280596832665583) != 0) || ((((_la - 334) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 334)) & 34371272705) != 0)) {
      setState(353);
      structMemberDeclaration();
      setState(358);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(359);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructMemberDeclarationContext ------------------------------------------------------------------

azslParser::StructMemberDeclarationContext::StructMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationStatementContext* azslParser::StructMemberDeclarationContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::StructMemberDeclarationContext::attributedFunctionDefinition() {
  return getRuleContext<azslParser::AttributedFunctionDefinitionContext>(0);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::StructMemberDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::StructMemberDeclarationContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::StructMemberDeclarationContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::AttributeSpecifierAnyContext* azslParser::StructMemberDeclarationContext::attributeSpecifierAny() {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(0);
}


size_t azslParser::StructMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleStructMemberDeclaration;
}

void azslParser::StructMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructMemberDeclaration(this);
}

void azslParser::StructMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructMemberDeclaration(this);
}

azslParser::StructMemberDeclarationContext* azslParser::structMemberDeclaration() {
  StructMemberDeclarationContext *_localctx = _tracker.createInstance<StructMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 24, azslParser::RuleStructMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(367);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(361);
      variableDeclarationStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(362);
      attributedFunctionDefinition();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(363);
      attributedFunctionDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(364);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(365);
      typeAliasingDefinitionStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(366);
      attributeSpecifierAny();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnyStructuredTypeDefinitionStatementContext ------------------------------------------------------------------

azslParser::AnyStructuredTypeDefinitionStatementContext::AnyStructuredTypeDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::AnyStructuredTypeDefinitionContext* azslParser::AnyStructuredTypeDefinitionStatementContext::anyStructuredTypeDefinition() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionContext>(0);
}

tree::TerminalNode* azslParser::AnyStructuredTypeDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AnyStructuredTypeDefinitionStatementContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AnyStructuredTypeDefinitionStatementContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AnyStructuredTypeDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleAnyStructuredTypeDefinitionStatement;
}

void azslParser::AnyStructuredTypeDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnyStructuredTypeDefinitionStatement(this);
}

void azslParser::AnyStructuredTypeDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnyStructuredTypeDefinitionStatement(this);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::anyStructuredTypeDefinitionStatement() {
  AnyStructuredTypeDefinitionStatementContext *_localctx = _tracker.createInstance<AnyStructuredTypeDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 26, azslParser::RuleAnyStructuredTypeDefinitionStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(372);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(369);
      attributeSpecifierAny();
      setState(374);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(375);
    anyStructuredTypeDefinition();
    setState(376);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDefinitionStatementContext ------------------------------------------------------------------

azslParser::EnumDefinitionStatementContext::EnumDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::EnumDefinitionContext* azslParser::EnumDefinitionStatementContext::enumDefinition() {
  return getRuleContext<azslParser::EnumDefinitionContext>(0);
}

tree::TerminalNode* azslParser::EnumDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::EnumDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleEnumDefinitionStatement;
}

void azslParser::EnumDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumDefinitionStatement(this);
}

void azslParser::EnumDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumDefinitionStatement(this);
}

azslParser::EnumDefinitionStatementContext* azslParser::enumDefinitionStatement() {
  EnumDefinitionStatementContext *_localctx = _tracker.createInstance<EnumDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 28, azslParser::RuleEnumDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(378);
    enumDefinition();
    setState(379);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDefinitionContext ------------------------------------------------------------------

azslParser::EnumDefinitionContext::EnumDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::EnumKeyContext* azslParser::EnumDefinitionContext::enumKey() {
  return getRuleContext<azslParser::EnumKeyContext>(0);
}

tree::TerminalNode* azslParser::EnumDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::EnumDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

tree::TerminalNode* azslParser::EnumDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

azslParser::EnumeratorListDefinitionContext* azslParser::EnumDefinitionContext::enumeratorListDefinition() {
  return getRuleContext<azslParser::EnumeratorListDefinitionContext>(0);
}


size_t azslParser::EnumDefinitionContext::getRuleIndex() const {
  return azslParser::RuleEnumDefinition;
}

void azslParser::EnumDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumDefinition(this);
}

void azslParser::EnumDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumDefinition(this);
}

azslParser::EnumDefinitionContext* azslParser::enumDefinition() {
  EnumDefinitionContext *_localctx = _tracker.createInstance<EnumDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 30, azslParser::RuleEnumDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(381);
    enumKey();
    setState(382);
    antlrcpp::downCast<EnumDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(383);
    match(azslParser::LeftBrace);
    setState(385);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Identifier) {
      setState(384);
      antlrcpp::downCast<EnumDefinitionContext *>(_localctx)->List = enumeratorListDefinition();
    }
    setState(387);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumKeyContext ------------------------------------------------------------------

azslParser::EnumKeyContext::EnumKeyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::EnumKeyContext::getRuleIndex() const {
  return azslParser::RuleEnumKey;
}

void azslParser::EnumKeyContext::copyFrom(EnumKeyContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- UnscopedEnumContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::UnscopedEnumContext::Enum() {
  return getToken(azslParser::Enum, 0);
}

azslParser::UnscopedEnumContext::UnscopedEnumContext(EnumKeyContext *ctx) { copyFrom(ctx); }

void azslParser::UnscopedEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnscopedEnum(this);
}
void azslParser::UnscopedEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnscopedEnum(this);
}
//----------------- ScopedEnumContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ScopedEnumContext::Enum() {
  return getToken(azslParser::Enum, 0);
}

tree::TerminalNode* azslParser::ScopedEnumContext::Class() {
  return getToken(azslParser::Class, 0);
}

tree::TerminalNode* azslParser::ScopedEnumContext::Struct() {
  return getToken(azslParser::Struct, 0);
}

azslParser::ScopedEnumContext::ScopedEnumContext(EnumKeyContext *ctx) { copyFrom(ctx); }

void azslParser::ScopedEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScopedEnum(this);
}
void azslParser::ScopedEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScopedEnum(this);
}
azslParser::EnumKeyContext* azslParser::enumKey() {
  EnumKeyContext *_localctx = _tracker.createInstance<EnumKeyContext>(_ctx, getState());
  enterRule(_localctx, 32, azslParser::RuleEnumKey);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(392);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<azslParser::UnscopedEnumContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(389);
      match(azslParser::Enum);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<azslParser::ScopedEnumContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(390);
      match(azslParser::Enum);
      setState(391);
      _la = _input->LA(1);
      if (!(_la == azslParser::Class || _la == azslParser::Struct)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumeratorListDefinitionContext ------------------------------------------------------------------

azslParser::EnumeratorListDefinitionContext::EnumeratorListDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::EnumeratorDeclaratorContext *> azslParser::EnumeratorListDefinitionContext::enumeratorDeclarator() {
  return getRuleContexts<azslParser::EnumeratorDeclaratorContext>();
}

azslParser::EnumeratorDeclaratorContext* azslParser::EnumeratorListDefinitionContext::enumeratorDeclarator(size_t i) {
  return getRuleContext<azslParser::EnumeratorDeclaratorContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::EnumeratorListDefinitionContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::EnumeratorListDefinitionContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::EnumeratorListDefinitionContext::getRuleIndex() const {
  return azslParser::RuleEnumeratorListDefinition;
}

void azslParser::EnumeratorListDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumeratorListDefinition(this);
}

void azslParser::EnumeratorListDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumeratorListDefinition(this);
}

azslParser::EnumeratorListDefinitionContext* azslParser::enumeratorListDefinition() {
  EnumeratorListDefinitionContext *_localctx = _tracker.createInstance<EnumeratorListDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 34, azslParser::RuleEnumeratorListDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(394);
    antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->enumeratorDeclaratorContext = enumeratorDeclarator();
    antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->Enumerators.push_back(antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->enumeratorDeclaratorContext);
    setState(399);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(395);
        match(azslParser::Comma);
        setState(396);
        antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->enumeratorDeclaratorContext = enumeratorDeclarator();
        antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->Enumerators.push_back(antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->enumeratorDeclaratorContext); 
      }
      setState(401);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
    }
    setState(403);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Comma) {
      setState(402);
      match(azslParser::Comma);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumeratorDeclaratorContext ------------------------------------------------------------------

azslParser::EnumeratorDeclaratorContext::EnumeratorDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::EnumeratorDeclaratorContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

tree::TerminalNode* azslParser::EnumeratorDeclaratorContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::ExpressionContext* azslParser::EnumeratorDeclaratorContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}


size_t azslParser::EnumeratorDeclaratorContext::getRuleIndex() const {
  return azslParser::RuleEnumeratorDeclarator;
}

void azslParser::EnumeratorDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumeratorDeclarator(this);
}

void azslParser::EnumeratorDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumeratorDeclarator(this);
}

azslParser::EnumeratorDeclaratorContext* azslParser::enumeratorDeclarator() {
  EnumeratorDeclaratorContext *_localctx = _tracker.createInstance<EnumeratorDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 36, azslParser::RuleEnumeratorDeclarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(405);
    antlrcpp::downCast<EnumeratorDeclaratorContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(408);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Assign) {
      setState(406);
      match(azslParser::Assign);
      setState(407);
      antlrcpp::downCast<EnumeratorDeclaratorContext *>(_localctx)->Value = expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnyStructuredTypeDefinitionContext ------------------------------------------------------------------

azslParser::AnyStructuredTypeDefinitionContext::AnyStructuredTypeDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::ClassDefinitionContext* azslParser::AnyStructuredTypeDefinitionContext::classDefinition() {
  return getRuleContext<azslParser::ClassDefinitionContext>(0);
}

azslParser::InterfaceDefinitionContext* azslParser::AnyStructuredTypeDefinitionContext::interfaceDefinition() {
  return getRuleContext<azslParser::InterfaceDefinitionContext>(0);
}

azslParser::StructDefinitionContext* azslParser::AnyStructuredTypeDefinitionContext::structDefinition() {
  return getRuleContext<azslParser::StructDefinitionContext>(0);
}

azslParser::EnumDefinitionContext* azslParser::AnyStructuredTypeDefinitionContext::enumDefinition() {
  return getRuleContext<azslParser::EnumDefinitionContext>(0);
}


size_t azslParser::AnyStructuredTypeDefinitionContext::getRuleIndex() const {
  return azslParser::RuleAnyStructuredTypeDefinition;
}

void azslParser::AnyStructuredTypeDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnyStructuredTypeDefinition(this);
}

void azslParser::AnyStructuredTypeDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnyStructuredTypeDefinition(this);
}

azslParser::AnyStructuredTypeDefinitionContext* azslParser::anyStructuredTypeDefinition() {
  AnyStructuredTypeDefinitionContext *_localctx = _tracker.createInstance<AnyStructuredTypeDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 38, azslParser::RuleAnyStructuredTypeDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(414);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Class: {
        enterOuterAlt(_localctx, 1);
        setState(410);
        classDefinition();
        break;
      }

      case azslParser::Interface: {
        enterOuterAlt(_localctx, 2);
        setState(411);
        interfaceDefinition();
        break;
      }

      case azslParser::Struct: {
        enterOuterAlt(_localctx, 3);
        setState(412);
        structDefinition();
        break;
      }

      case azslParser::Enum: {
        enterOuterAlt(_localctx, 4);
        setState(413);
        enumDefinition();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceDefinitionStatementContext ------------------------------------------------------------------

azslParser::InterfaceDefinitionStatementContext::InterfaceDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::InterfaceDefinitionContext* azslParser::InterfaceDefinitionStatementContext::interfaceDefinition() {
  return getRuleContext<azslParser::InterfaceDefinitionContext>(0);
}

tree::TerminalNode* azslParser::InterfaceDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::InterfaceDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleInterfaceDefinitionStatement;
}

void azslParser::InterfaceDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceDefinitionStatement(this);
}

void azslParser::InterfaceDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceDefinitionStatement(this);
}

azslParser::InterfaceDefinitionStatementContext* azslParser::interfaceDefinitionStatement() {
  InterfaceDefinitionStatementContext *_localctx = _tracker.createInstance<InterfaceDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 40, azslParser::RuleInterfaceDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(416);
    interfaceDefinition();
    setState(417);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceDefinitionContext ------------------------------------------------------------------

azslParser::InterfaceDefinitionContext::InterfaceDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::InterfaceDefinitionContext::Interface() {
  return getToken(azslParser::Interface, 0);
}

tree::TerminalNode* azslParser::InterfaceDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::InterfaceDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

tree::TerminalNode* azslParser::InterfaceDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

std::vector<azslParser::InterfaceMemberDeclarationContext *> azslParser::InterfaceDefinitionContext::interfaceMemberDeclaration() {
  return getRuleContexts<azslParser::InterfaceMemberDeclarationContext>();
}

azslParser::InterfaceMemberDeclarationContext* azslParser::InterfaceDefinitionContext::interfaceMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::InterfaceMemberDeclarationContext>(i);
}


size_t azslParser::InterfaceDefinitionContext::getRuleIndex() const {
  return azslParser::RuleInterfaceDefinition;
}

void azslParser::InterfaceDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceDefinition(this);
}

void azslParser::InterfaceDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceDefinition(this);
}

azslParser::InterfaceDefinitionContext* azslParser::interfaceDefinition() {
  InterfaceDefinitionContext *_localctx = _tracker.createInstance<InterfaceDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 42, azslParser::RuleInterfaceDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(419);
    match(azslParser::Interface);
    setState(420);
    antlrcpp::downCast<InterfaceDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(421);
    match(azslParser::LeftBrace);
    setState(425);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -25) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 38280596832665583) != 0) || ((((_la - 334) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 334)) & 34368651265) != 0)) {
      setState(422);
      interfaceMemberDeclaration();
      setState(427);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(428);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceMemberDeclarationContext ------------------------------------------------------------------

azslParser::InterfaceMemberDeclarationContext::InterfaceMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::AttributedFunctionDeclarationContext* azslParser::InterfaceMemberDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::AssociatedTypeDeclarationContext* azslParser::InterfaceMemberDeclarationContext::associatedTypeDeclaration() {
  return getRuleContext<azslParser::AssociatedTypeDeclarationContext>(0);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::InterfaceMemberDeclarationContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}


size_t azslParser::InterfaceMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleInterfaceMemberDeclaration;
}

void azslParser::InterfaceMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceMemberDeclaration(this);
}

void azslParser::InterfaceMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceMemberDeclaration(this);
}

azslParser::InterfaceMemberDeclarationContext* azslParser::interfaceMemberDeclaration() {
  InterfaceMemberDeclarationContext *_localctx = _tracker.createInstance<InterfaceMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 44, azslParser::RuleInterfaceMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(433);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(430);
      attributedFunctionDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(431);
      associatedTypeDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(432);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantBufferTemplatedContext ------------------------------------------------------------------

azslParser::ConstantBufferTemplatedContext::ConstantBufferTemplatedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ConstantBufferTemplatedContext::Less() {
  return getToken(azslParser::Less, 0);
}

tree::TerminalNode* azslParser::ConstantBufferTemplatedContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

azslParser::TypeContext* azslParser::ConstantBufferTemplatedContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::ConstantBufferTemplatedContext::ConstantBuffer() {
  return getToken(azslParser::ConstantBuffer, 0);
}

tree::TerminalNode* azslParser::ConstantBufferTemplatedContext::ConstantBufferCamel() {
  return getToken(azslParser::ConstantBufferCamel, 0);
}


size_t azslParser::ConstantBufferTemplatedContext::getRuleIndex() const {
  return azslParser::RuleConstantBufferTemplated;
}

void azslParser::ConstantBufferTemplatedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantBufferTemplated(this);
}

void azslParser::ConstantBufferTemplatedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantBufferTemplated(this);
}

azslParser::ConstantBufferTemplatedContext* azslParser::constantBufferTemplated() {
  ConstantBufferTemplatedContext *_localctx = _tracker.createInstance<ConstantBufferTemplatedContext>(_ctx, getState());
  enterRule(_localctx, 46, azslParser::RuleConstantBufferTemplated);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(435);
    antlrcpp::downCast<ConstantBufferTemplatedContext *>(_localctx)->CBCoreType = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == azslParser::ConstantBuffer

    || _la == azslParser::ConstantBufferCamel)) {
      antlrcpp::downCast<ConstantBufferTemplatedContext *>(_localctx)->CBCoreType = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(436);
    match(azslParser::Less);
    setState(437);
    antlrcpp::downCast<ConstantBufferTemplatedContext *>(_localctx)->GenericTypeName = type();
    setState(438);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationStatementContext ------------------------------------------------------------------

azslParser::VariableDeclarationStatementContext::VariableDeclarationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationContext* azslParser::VariableDeclarationStatementContext::variableDeclaration() {
  return getRuleContext<azslParser::VariableDeclarationContext>(0);
}

tree::TerminalNode* azslParser::VariableDeclarationStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::VariableDeclarationStatementContext::getRuleIndex() const {
  return azslParser::RuleVariableDeclarationStatement;
}

void azslParser::VariableDeclarationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarationStatement(this);
}

void azslParser::VariableDeclarationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarationStatement(this);
}

azslParser::VariableDeclarationStatementContext* azslParser::variableDeclarationStatement() {
  VariableDeclarationStatementContext *_localctx = _tracker.createInstance<VariableDeclarationStatementContext>(_ctx, getState());
  enterRule(_localctx, 48, azslParser::RuleVariableDeclarationStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(440);
    variableDeclaration();
    setState(441);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionParamsContext ------------------------------------------------------------------

azslParser::FunctionParamsContext::FunctionParamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::FunctionParamsContext::Void() {
  return getToken(azslParser::Void, 0);
}

std::vector<azslParser::FunctionParamContext *> azslParser::FunctionParamsContext::functionParam() {
  return getRuleContexts<azslParser::FunctionParamContext>();
}

azslParser::FunctionParamContext* azslParser::FunctionParamsContext::functionParam(size_t i) {
  return getRuleContext<azslParser::FunctionParamContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::FunctionParamsContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::FunctionParamsContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::FunctionParamsContext::getRuleIndex() const {
  return azslParser::RuleFunctionParams;
}

void azslParser::FunctionParamsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionParams(this);
}

void azslParser::FunctionParamsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionParams(this);
}

azslParser::FunctionParamsContext* azslParser::functionParams() {
  FunctionParamsContext *_localctx = _tracker.createInstance<FunctionParamsContext>(_ctx, getState());
  enterRule(_localctx, 50, azslParser::RuleFunctionParams);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(452);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(443);
      match(azslParser::Void);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(444);
      functionParam();
      setState(449);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::Comma) {
        setState(445);
        match(azslParser::Comma);
        setState(446);
        functionParam();
        setState(451);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionParamContext ------------------------------------------------------------------

azslParser::FunctionParamContext::FunctionParamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TypeContext* azslParser::FunctionParamContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

azslParser::UnnamedVariableDeclaratorContext* azslParser::FunctionParamContext::unnamedVariableDeclarator() {
  return getRuleContext<azslParser::UnnamedVariableDeclaratorContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::FunctionParamContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::FunctionParamContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}

tree::TerminalNode* azslParser::FunctionParamContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::FunctionParamContext::getRuleIndex() const {
  return azslParser::RuleFunctionParam;
}

void azslParser::FunctionParamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionParam(this);
}

void azslParser::FunctionParamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionParam(this);
}

azslParser::FunctionParamContext* azslParser::functionParam() {
  FunctionParamContext *_localctx = _tracker.createInstance<FunctionParamContext>(_ctx, getState());
  enterRule(_localctx, 52, azslParser::RuleFunctionParam);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(457);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(454);
      attributeSpecifierAny();
      setState(459);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(460);
    type();
    setState(462);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Identifier) {
      setState(461);
      antlrcpp::downCast<FunctionParamContext *>(_localctx)->Name = match(azslParser::Identifier);
    }
    setState(464);
    unnamedVariableDeclarator();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HlslSemanticContext ------------------------------------------------------------------

azslParser::HlslSemanticContext::HlslSemanticContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::HlslSemanticContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::HlslSemanticNameContext* azslParser::HlslSemanticContext::hlslSemanticName() {
  return getRuleContext<azslParser::HlslSemanticNameContext>(0);
}


size_t azslParser::HlslSemanticContext::getRuleIndex() const {
  return azslParser::RuleHlslSemantic;
}

void azslParser::HlslSemanticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHlslSemantic(this);
}

void azslParser::HlslSemanticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHlslSemantic(this);
}

azslParser::HlslSemanticContext* azslParser::hlslSemantic() {
  HlslSemanticContext *_localctx = _tracker.createInstance<HlslSemanticContext>(_ctx, getState());
  enterRule(_localctx, 54, azslParser::RuleHlslSemantic);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(466);
    match(azslParser::Colon);
    setState(467);
    antlrcpp::downCast<HlslSemanticContext *>(_localctx)->Name = hlslSemanticName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HlslSemanticNameContext ------------------------------------------------------------------

azslParser::HlslSemanticNameContext::HlslSemanticNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::HlslSemanticNameContext::HLSLSemanticStream() {
  return getToken(azslParser::HLSLSemanticStream, 0);
}

tree::TerminalNode* azslParser::HlslSemanticNameContext::HLSLSemanticSystem() {
  return getToken(azslParser::HLSLSemanticSystem, 0);
}

tree::TerminalNode* azslParser::HlslSemanticNameContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::HlslSemanticNameContext::getRuleIndex() const {
  return azslParser::RuleHlslSemanticName;
}

void azslParser::HlslSemanticNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHlslSemanticName(this);
}

void azslParser::HlslSemanticNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHlslSemanticName(this);
}

azslParser::HlslSemanticNameContext* azslParser::hlslSemanticName() {
  HlslSemanticNameContext *_localctx = _tracker.createInstance<HlslSemanticNameContext>(_ctx, getState());
  enterRule(_localctx, 56, azslParser::RuleHlslSemanticName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(469);
    _la = _input->LA(1);
    if (!(((((_la - 367) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 367)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeArgumentsContext ------------------------------------------------------------------

azslParser::AttributeArgumentsContext::AttributeArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::LiteralContext *> azslParser::AttributeArgumentsContext::literal() {
  return getRuleContexts<azslParser::LiteralContext>();
}

azslParser::LiteralContext* azslParser::AttributeArgumentsContext::literal(size_t i) {
  return getRuleContext<azslParser::LiteralContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::AttributeArgumentsContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::AttributeArgumentsContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::AttributeArgumentsContext::getRuleIndex() const {
  return azslParser::RuleAttributeArguments;
}

void azslParser::AttributeArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeArguments(this);
}

void azslParser::AttributeArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeArguments(this);
}

azslParser::AttributeArgumentsContext* azslParser::attributeArguments() {
  AttributeArgumentsContext *_localctx = _tracker.createInstance<AttributeArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 58, azslParser::RuleAttributeArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    literal();
    setState(476);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(472);
      match(azslParser::Comma);
      setState(473);
      literal();
      setState(478);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeArgumentListContext ------------------------------------------------------------------

azslParser::AttributeArgumentListContext::AttributeArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AttributeArgumentListContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

azslParser::AttributeArgumentsContext* azslParser::AttributeArgumentListContext::attributeArguments() {
  return getRuleContext<azslParser::AttributeArgumentsContext>(0);
}

tree::TerminalNode* azslParser::AttributeArgumentListContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}


size_t azslParser::AttributeArgumentListContext::getRuleIndex() const {
  return azslParser::RuleAttributeArgumentList;
}

void azslParser::AttributeArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeArgumentList(this);
}

void azslParser::AttributeArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeArgumentList(this);
}

azslParser::AttributeArgumentListContext* azslParser::attributeArgumentList() {
  AttributeArgumentListContext *_localctx = _tracker.createInstance<AttributeArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 60, azslParser::RuleAttributeArgumentList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(479);
    match(azslParser::LeftParen);
    setState(480);
    attributeArguments();
    setState(481);
    match(azslParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeContext ------------------------------------------------------------------

azslParser::AttributeContext::AttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::AttributeContext::getRuleIndex() const {
  return azslParser::RuleAttribute;
}

void azslParser::AttributeContext::copyFrom(AttributeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- GlobalAttributeContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::GlobalAttributeContext::Global() {
  return getToken(azslParser::Global, 0);
}

std::vector<tree::TerminalNode *> azslParser::GlobalAttributeContext::ColonColon() {
  return getTokens(azslParser::ColonColon);
}

tree::TerminalNode* azslParser::GlobalAttributeContext::ColonColon(size_t i) {
  return getToken(azslParser::ColonColon, i);
}

std::vector<tree::TerminalNode *> azslParser::GlobalAttributeContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::GlobalAttributeContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

azslParser::AttributeArgumentListContext* azslParser::GlobalAttributeContext::attributeArgumentList() {
  return getRuleContext<azslParser::AttributeArgumentListContext>(0);
}

azslParser::GlobalAttributeContext::GlobalAttributeContext(AttributeContext *ctx) { copyFrom(ctx); }

void azslParser::GlobalAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobalAttribute(this);
}
void azslParser::GlobalAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobalAttribute(this);
}
//----------------- AttachedAttributeContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> azslParser::AttachedAttributeContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::AttachedAttributeContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

tree::TerminalNode* azslParser::AttachedAttributeContext::ColonColon() {
  return getToken(azslParser::ColonColon, 0);
}

azslParser::AttributeArgumentListContext* azslParser::AttachedAttributeContext::attributeArgumentList() {
  return getRuleContext<azslParser::AttributeArgumentListContext>(0);
}

azslParser::AttachedAttributeContext::AttachedAttributeContext(AttributeContext *ctx) { copyFrom(ctx); }

void azslParser::AttachedAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttachedAttribute(this);
}
void azslParser::AttachedAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttachedAttribute(this);
}
azslParser::AttributeContext* azslParser::attribute() {
  AttributeContext *_localctx = _tracker.createInstance<AttributeContext>(_ctx, getState());
  enterRule(_localctx, 62, azslParser::RuleAttribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(501);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Global: {
        _localctx = _tracker.createInstance<azslParser::GlobalAttributeContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(483);
        match(azslParser::Global);
        setState(484);
        match(azslParser::ColonColon);
        setState(487);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
        case 1: {
          setState(485);
          antlrcpp::downCast<GlobalAttributeContext *>(_localctx)->Namespace = match(azslParser::Identifier);
          setState(486);
          match(azslParser::ColonColon);
          break;
        }

        default:
          break;
        }
        setState(489);
        antlrcpp::downCast<GlobalAttributeContext *>(_localctx)->Name = match(azslParser::Identifier);
        setState(491);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == azslParser::LeftParen) {
          setState(490);
          attributeArgumentList();
        }
        break;
      }

      case azslParser::Identifier: {
        _localctx = _tracker.createInstance<azslParser::AttachedAttributeContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(495);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
        case 1: {
          setState(493);
          antlrcpp::downCast<AttachedAttributeContext *>(_localctx)->Namespace = match(azslParser::Identifier);
          setState(494);
          match(azslParser::ColonColon);
          break;
        }

        default:
          break;
        }
        setState(497);
        antlrcpp::downCast<AttachedAttributeContext *>(_localctx)->Name = match(azslParser::Identifier);
        setState(499);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == azslParser::LeftParen) {
          setState(498);
          attributeArgumentList();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeSpecifierContext ------------------------------------------------------------------

azslParser::AttributeSpecifierContext::AttributeSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AttributeSpecifierContext::LeftBracket() {
  return getToken(azslParser::LeftBracket, 0);
}

azslParser::AttributeContext* azslParser::AttributeSpecifierContext::attribute() {
  return getRuleContext<azslParser::AttributeContext>(0);
}

tree::TerminalNode* azslParser::AttributeSpecifierContext::RightBracket() {
  return getToken(azslParser::RightBracket, 0);
}


size_t azslParser::AttributeSpecifierContext::getRuleIndex() const {
  return azslParser::RuleAttributeSpecifier;
}

void azslParser::AttributeSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeSpecifier(this);
}

void azslParser::AttributeSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeSpecifier(this);
}

azslParser::AttributeSpecifierContext* azslParser::attributeSpecifier() {
  AttributeSpecifierContext *_localctx = _tracker.createInstance<AttributeSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 64, azslParser::RuleAttributeSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(503);
    match(azslParser::LeftBracket);
    setState(504);
    attribute();
    setState(505);
    match(azslParser::RightBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeSpecifierSequenceContext ------------------------------------------------------------------

azslParser::AttributeSpecifierSequenceContext::AttributeSpecifierSequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AttributeSpecifierSequenceContext::LeftDoubleBracket() {
  return getToken(azslParser::LeftDoubleBracket, 0);
}

std::vector<tree::TerminalNode *> azslParser::AttributeSpecifierSequenceContext::RightBracket() {
  return getTokens(azslParser::RightBracket);
}

tree::TerminalNode* azslParser::AttributeSpecifierSequenceContext::RightBracket(size_t i) {
  return getToken(azslParser::RightBracket, i);
}

std::vector<azslParser::AttributeContext *> azslParser::AttributeSpecifierSequenceContext::attribute() {
  return getRuleContexts<azslParser::AttributeContext>();
}

azslParser::AttributeContext* azslParser::AttributeSpecifierSequenceContext::attribute(size_t i) {
  return getRuleContext<azslParser::AttributeContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::AttributeSpecifierSequenceContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::AttributeSpecifierSequenceContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::AttributeSpecifierSequenceContext::getRuleIndex() const {
  return azslParser::RuleAttributeSpecifierSequence;
}

void azslParser::AttributeSpecifierSequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeSpecifierSequence(this);
}

void azslParser::AttributeSpecifierSequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeSpecifierSequence(this);
}

azslParser::AttributeSpecifierSequenceContext* azslParser::attributeSpecifierSequence() {
  AttributeSpecifierSequenceContext *_localctx = _tracker.createInstance<AttributeSpecifierSequenceContext>(_ctx, getState());
  enterRule(_localctx, 66, azslParser::RuleAttributeSpecifierSequence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(507);
    match(azslParser::LeftDoubleBracket);
    setState(508);
    antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->attributeContext = attribute();
    antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->Attributes.push_back(antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->attributeContext);
    setState(513);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(509);
      match(azslParser::Comma);
      setState(510);
      antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->attributeContext = attribute();
      antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->Attributes.push_back(antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->attributeContext);
      setState(515);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(516);
    match(azslParser::RightBracket);
    setState(517);
    match(azslParser::RightBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeSpecifierAnyContext ------------------------------------------------------------------

azslParser::AttributeSpecifierAnyContext::AttributeSpecifierAnyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::AttributeSpecifierContext* azslParser::AttributeSpecifierAnyContext::attributeSpecifier() {
  return getRuleContext<azslParser::AttributeSpecifierContext>(0);
}

azslParser::AttributeSpecifierSequenceContext* azslParser::AttributeSpecifierAnyContext::attributeSpecifierSequence() {
  return getRuleContext<azslParser::AttributeSpecifierSequenceContext>(0);
}


size_t azslParser::AttributeSpecifierAnyContext::getRuleIndex() const {
  return azslParser::RuleAttributeSpecifierAny;
}

void azslParser::AttributeSpecifierAnyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeSpecifierAny(this);
}

void azslParser::AttributeSpecifierAnyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeSpecifierAny(this);
}

azslParser::AttributeSpecifierAnyContext* azslParser::attributeSpecifierAny() {
  AttributeSpecifierAnyContext *_localctx = _tracker.createInstance<AttributeSpecifierAnyContext>(_ctx, getState());
  enterRule(_localctx, 68, azslParser::RuleAttributeSpecifierAny);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(521);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::LeftBracket: {
        enterOuterAlt(_localctx, 1);
        setState(519);
        attributeSpecifier();
        break;
      }

      case azslParser::LeftDoubleBracket: {
        enterOuterAlt(_localctx, 2);
        setState(520);
        attributeSpecifierSequence();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

azslParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BlockContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::BlockContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<azslParser::StatementContext *> azslParser::BlockContext::statement() {
  return getRuleContexts<azslParser::StatementContext>();
}

azslParser::StatementContext* azslParser::BlockContext::statement(size_t i) {
  return getRuleContext<azslParser::StatementContext>(i);
}


size_t azslParser::BlockContext::getRuleIndex() const {
  return azslParser::RuleBlock;
}

void azslParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void azslParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}

azslParser::BlockContext* azslParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 70, azslParser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(523);
    match(azslParser::LeftBrace);
    setState(527);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917528889799475198) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -134217735) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -8797033594881) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -17) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & -4563835272386560001) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & 8457638861917187) != 0)) {
      setState(524);
      antlrcpp::downCast<BlockContext *>(_localctx)->statementContext = statement();
      antlrcpp::downCast<BlockContext *>(_localctx)->Stmts.push_back(antlrcpp::downCast<BlockContext *>(_localctx)->statementContext);
      setState(529);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(530);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

azslParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationStatementContext* azslParser::StatementContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::EmbeddedStatementContext* azslParser::StatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::StatementContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}


size_t azslParser::StatementContext::getRuleIndex() const {
  return azslParser::RuleStatement;
}

void azslParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void azslParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

azslParser::StatementContext* azslParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 72, azslParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(535);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(532);
      variableDeclarationStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(533);
      embeddedStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(534);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForInitializerContext ------------------------------------------------------------------

azslParser::ForInitializerContext::ForInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationContext* azslParser::ForInitializerContext::variableDeclaration() {
  return getRuleContext<azslParser::VariableDeclarationContext>(0);
}

azslParser::ExpressionExtContext* azslParser::ForInitializerContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}


size_t azslParser::ForInitializerContext::getRuleIndex() const {
  return azslParser::RuleForInitializer;
}

void azslParser::ForInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForInitializer(this);
}

void azslParser::ForInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForInitializer(this);
}

azslParser::ForInitializerContext* azslParser::forInitializer() {
  ForInitializerContext *_localctx = _tracker.createInstance<ForInitializerContext>(_ctx, getState());
  enterRule(_localctx, 74, azslParser::RuleForInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(539);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(537);
      variableDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(538);
      expressionExt(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchLabelContext ------------------------------------------------------------------

azslParser::SwitchLabelContext::SwitchLabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::SwitchLabelContext::getRuleIndex() const {
  return azslParser::RuleSwitchLabel;
}

void azslParser::SwitchLabelContext::copyFrom(SwitchLabelContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DefaultSwitchLabelContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::DefaultSwitchLabelContext::Default() {
  return getToken(azslParser::Default, 0);
}

tree::TerminalNode* azslParser::DefaultSwitchLabelContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::DefaultSwitchLabelContext::DefaultSwitchLabelContext(SwitchLabelContext *ctx) { copyFrom(ctx); }

void azslParser::DefaultSwitchLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultSwitchLabel(this);
}
void azslParser::DefaultSwitchLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultSwitchLabel(this);
}
//----------------- CaseSwitchLabelContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::CaseSwitchLabelContext::Case() {
  return getToken(azslParser::Case, 0);
}

tree::TerminalNode* azslParser::CaseSwitchLabelContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::ExpressionContext* azslParser::CaseSwitchLabelContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::CaseSwitchLabelContext::CaseSwitchLabelContext(SwitchLabelContext *ctx) { copyFrom(ctx); }

void azslParser::CaseSwitchLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseSwitchLabel(this);
}
void azslParser::CaseSwitchLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseSwitchLabel(this);
}
azslParser::SwitchLabelContext* azslParser::switchLabel() {
  SwitchLabelContext *_localctx = _tracker.createInstance<SwitchLabelContext>(_ctx, getState());
  enterRule(_localctx, 76, azslParser::RuleSwitchLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(547);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Case: {
        _localctx = _tracker.createInstance<azslParser::CaseSwitchLabelContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(541);
        match(azslParser::Case);
        setState(542);
        antlrcpp::downCast<CaseSwitchLabelContext *>(_localctx)->Expr = expression(0);
        setState(543);
        match(azslParser::Colon);
        break;
      }

      case azslParser::Default: {
        _localctx = _tracker.createInstance<azslParser::DefaultSwitchLabelContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(545);
        match(azslParser::Default);
        setState(546);
        match(azslParser::Colon);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchSectionContext ------------------------------------------------------------------

azslParser::SwitchSectionContext::SwitchSectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::SwitchLabelContext *> azslParser::SwitchSectionContext::switchLabel() {
  return getRuleContexts<azslParser::SwitchLabelContext>();
}

azslParser::SwitchLabelContext* azslParser::SwitchSectionContext::switchLabel(size_t i) {
  return getRuleContext<azslParser::SwitchLabelContext>(i);
}

std::vector<azslParser::StatementContext *> azslParser::SwitchSectionContext::statement() {
  return getRuleContexts<azslParser::StatementContext>();
}

azslParser::StatementContext* azslParser::SwitchSectionContext::statement(size_t i) {
  return getRuleContext<azslParser::StatementContext>(i);
}


size_t azslParser::SwitchSectionContext::getRuleIndex() const {
  return azslParser::RuleSwitchSection;
}

void azslParser::SwitchSectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchSection(this);
}

void azslParser::SwitchSectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchSection(this);
}

azslParser::SwitchSectionContext* azslParser::switchSection() {
  SwitchSectionContext *_localctx = _tracker.createInstance<SwitchSectionContext>(_ctx, getState());
  enterRule(_localctx, 78, azslParser::RuleSwitchSection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(550); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(549);
      switchLabel();
      setState(552); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == azslParser::Case

    || _la == azslParser::Default);
    setState(555); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(554);
      statement();
      setState(557); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917528889799475198) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -134217735) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -8797033594881) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -17) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & -4563835272386560001) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & 8457638861917187) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchBlockContext ------------------------------------------------------------------

azslParser::SwitchBlockContext::SwitchBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SwitchBlockContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::SwitchBlockContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<azslParser::SwitchSectionContext *> azslParser::SwitchBlockContext::switchSection() {
  return getRuleContexts<azslParser::SwitchSectionContext>();
}

azslParser::SwitchSectionContext* azslParser::SwitchBlockContext::switchSection(size_t i) {
  return getRuleContext<azslParser::SwitchSectionContext>(i);
}


size_t azslParser::SwitchBlockContext::getRuleIndex() const {
  return azslParser::RuleSwitchBlock;
}

void azslParser::SwitchBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchBlock(this);
}

void azslParser::SwitchBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchBlock(this);
}

azslParser::SwitchBlockContext* azslParser::switchBlock() {
  SwitchBlockContext *_localctx = _tracker.createInstance<SwitchBlockContext>(_ctx, getState());
  enterRule(_localctx, 80, azslParser::RuleSwitchBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    match(azslParser::LeftBrace);
    setState(563);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Case

    || _la == azslParser::Default) {
      setState(560);
      switchSection();
      setState(565);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(566);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmbeddedStatementContext ------------------------------------------------------------------

azslParser::EmbeddedStatementContext::EmbeddedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::EmbeddedStatementContext::getRuleIndex() const {
  return azslParser::RuleEmbeddedStatement;
}

void azslParser::EmbeddedStatementContext::copyFrom(EmbeddedStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DoStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::DoStatementContext::Do() {
  return getToken(azslParser::Do, 0);
}

azslParser::EmbeddedStatementContext* azslParser::DoStatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

tree::TerminalNode* azslParser::DoStatementContext::While() {
  return getToken(azslParser::While, 0);
}

tree::TerminalNode* azslParser::DoStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::DoStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::DoStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::ExpressionExtContext* azslParser::DoStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::DoStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::DoStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::DoStatementContext::DoStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}
void azslParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}
//----------------- EmptyStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::EmptyStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::EmptyStatementContext::EmptyStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::EmptyStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStatement(this);
}
void azslParser::EmptyStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStatement(this);
}
//----------------- BlockStatementContext ------------------------------------------------------------------

azslParser::BlockContext* azslParser::BlockStatementContext::block() {
  return getRuleContext<azslParser::BlockContext>(0);
}

azslParser::BlockStatementContext::BlockStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::BlockStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlockStatement(this);
}
void azslParser::BlockStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlockStatement(this);
}
//----------------- WhileStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::WhileStatementContext::While() {
  return getToken(azslParser::While, 0);
}

tree::TerminalNode* azslParser::WhileStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::WhileStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::EmbeddedStatementContext* azslParser::WhileStatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

azslParser::ExpressionExtContext* azslParser::WhileStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::WhileStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::WhileStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::WhileStatementContext::WhileStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}
void azslParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}
//----------------- ExtenstionStatementContext ------------------------------------------------------------------

azslParser::CompilerExtensionStatementContext* azslParser::ExtenstionStatementContext::compilerExtensionStatement() {
  return getRuleContext<azslParser::CompilerExtensionStatementContext>(0);
}

azslParser::ExtenstionStatementContext::ExtenstionStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ExtenstionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtenstionStatement(this);
}
void azslParser::ExtenstionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtenstionStatement(this);
}
//----------------- BreakStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::BreakStatementContext::Break() {
  return getToken(azslParser::Break, 0);
}

tree::TerminalNode* azslParser::BreakStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::BreakStatementContext::BreakStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::BreakStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreakStatement(this);
}
void azslParser::BreakStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreakStatement(this);
}
//----------------- IfStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::IfStatementContext::If() {
  return getToken(azslParser::If, 0);
}

tree::TerminalNode* azslParser::IfStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::IfStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::ExpressionExtContext* azslParser::IfStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::EmbeddedStatementContext* azslParser::IfStatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::IfStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::IfStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::ElseClauseContext* azslParser::IfStatementContext::elseClause() {
  return getRuleContext<azslParser::ElseClauseContext>(0);
}

azslParser::IfStatementContext::IfStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}
void azslParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}
//----------------- SwitchStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::SwitchStatementContext::Switch() {
  return getToken(azslParser::Switch, 0);
}

tree::TerminalNode* azslParser::SwitchStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::SwitchStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::SwitchBlockContext* azslParser::SwitchStatementContext::switchBlock() {
  return getRuleContext<azslParser::SwitchBlockContext>(0);
}

azslParser::ExpressionExtContext* azslParser::SwitchStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::SwitchStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::SwitchStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::SwitchStatementContext::SwitchStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::SwitchStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchStatement(this);
}
void azslParser::SwitchStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchStatement(this);
}
//----------------- ExpressionStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ExpressionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::ExpressionExtContext* azslParser::ExpressionStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::ExpressionStatementContext::ExpressionStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}
void azslParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}
//----------------- ReturnStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ReturnStatementContext::Return() {
  return getToken(azslParser::Return, 0);
}

tree::TerminalNode* azslParser::ReturnStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::ExpressionExtContext* azslParser::ReturnStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::ReturnStatementContext::ReturnStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}
void azslParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}
//----------------- DiscardStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::DiscardStatementContext::Discard() {
  return getToken(azslParser::Discard, 0);
}

tree::TerminalNode* azslParser::DiscardStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::DiscardStatementContext::DiscardStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::DiscardStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiscardStatement(this);
}
void azslParser::DiscardStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiscardStatement(this);
}
//----------------- ForStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ForStatementContext::For() {
  return getToken(azslParser::For, 0);
}

tree::TerminalNode* azslParser::ForStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

std::vector<tree::TerminalNode *> azslParser::ForStatementContext::Semi() {
  return getTokens(azslParser::Semi);
}

tree::TerminalNode* azslParser::ForStatementContext::Semi(size_t i) {
  return getToken(azslParser::Semi, i);
}

tree::TerminalNode* azslParser::ForStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::EmbeddedStatementContext* azslParser::ForStatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::ForStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::ForStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::ForInitializerContext* azslParser::ForStatementContext::forInitializer() {
  return getRuleContext<azslParser::ForInitializerContext>(0);
}

std::vector<azslParser::ExpressionExtContext *> azslParser::ForStatementContext::expressionExt() {
  return getRuleContexts<azslParser::ExpressionExtContext>();
}

azslParser::ExpressionExtContext* azslParser::ForStatementContext::expressionExt(size_t i) {
  return getRuleContext<azslParser::ExpressionExtContext>(i);
}

azslParser::ForStatementContext::ForStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ForStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForStatement(this);
}
void azslParser::ForStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForStatement(this);
}
//----------------- TypeAliasingDefinitionStatementLabelContext ------------------------------------------------------------------

azslParser::TypeAliasingDefinitionStatementContext* azslParser::TypeAliasingDefinitionStatementLabelContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::TypeAliasingDefinitionStatementLabelContext::TypeAliasingDefinitionStatementLabelContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::TypeAliasingDefinitionStatementLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAliasingDefinitionStatementLabel(this);
}
void azslParser::TypeAliasingDefinitionStatementLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAliasingDefinitionStatementLabel(this);
}
//----------------- ContinueStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ContinueStatementContext::Continue() {
  return getToken(azslParser::Continue, 0);
}

tree::TerminalNode* azslParser::ContinueStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::ContinueStatementContext::ContinueStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ContinueStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinueStatement(this);
}
void azslParser::ContinueStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinueStatement(this);
}
azslParser::EmbeddedStatementContext* azslParser::embeddedStatement() {
  EmbeddedStatementContext *_localctx = _tracker.createInstance<EmbeddedStatementContext>(_ctx, getState());
  enterRule(_localctx, 82, azslParser::RuleEmbeddedStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(659);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<azslParser::EmptyStatementContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(568);
      match(azslParser::Semi);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<azslParser::BlockStatementContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(569);
      block();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<azslParser::ExpressionStatementContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(570);
      antlrcpp::downCast<ExpressionStatementContext *>(_localctx)->Expr = expressionExt(0);
      setState(571);
      match(azslParser::Semi);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<azslParser::IfStatementContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(576);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(573);
        attributeSpecifier();
        setState(578);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(579);
      match(azslParser::If);
      setState(580);
      match(azslParser::LeftParen);
      setState(581);
      antlrcpp::downCast<IfStatementContext *>(_localctx)->Condition = expressionExt(0);
      setState(582);
      match(azslParser::RightParen);
      setState(583);
      antlrcpp::downCast<IfStatementContext *>(_localctx)->Stmt = embeddedStatement();
      setState(585);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
      case 1: {
        setState(584);
        elseClause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<azslParser::SwitchStatementContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(590);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(587);
        attributeSpecifier();
        setState(592);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(593);
      match(azslParser::Switch);
      setState(594);
      match(azslParser::LeftParen);
      setState(595);
      antlrcpp::downCast<SwitchStatementContext *>(_localctx)->Expr = expressionExt(0);
      setState(596);
      match(azslParser::RightParen);
      setState(597);
      switchBlock();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<azslParser::WhileStatementContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(602);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(599);
        attributeSpecifier();
        setState(604);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(605);
      match(azslParser::While);
      setState(606);
      match(azslParser::LeftParen);
      setState(607);
      antlrcpp::downCast<WhileStatementContext *>(_localctx)->Condition = expressionExt(0);
      setState(608);
      match(azslParser::RightParen);
      setState(609);
      embeddedStatement();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<azslParser::DoStatementContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(614);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(611);
        attributeSpecifier();
        setState(616);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(617);
      match(azslParser::Do);
      setState(618);
      embeddedStatement();
      setState(619);
      match(azslParser::While);
      setState(620);
      match(azslParser::LeftParen);
      setState(621);
      antlrcpp::downCast<DoStatementContext *>(_localctx)->Condition = expressionExt(0);
      setState(622);
      match(azslParser::RightParen);
      setState(623);
      match(azslParser::Semi);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<azslParser::ForStatementContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(628);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(625);
        attributeSpecifier();
        setState(630);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(631);
      match(azslParser::For);
      setState(632);
      match(azslParser::LeftParen);
      setState(634);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & -25) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 256)) & -4572842471641301009) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 320)) & 8444393182743555) != 0)) {
        setState(633);
        forInitializer();
      }
      setState(636);
      match(azslParser::Semi);
      setState(638);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 210) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 210)) & 281474926379007) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 305)) & 211106870190081) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 369)) & 15) != 0)) {
        setState(637);
        antlrcpp::downCast<ForStatementContext *>(_localctx)->Condition = expressionExt(0);
      }
      setState(640);
      match(azslParser::Semi);
      setState(642);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 210) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 210)) & 281474926379007) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 305)) & 211106870190081) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 369)) & 15) != 0)) {
        setState(641);
        antlrcpp::downCast<ForStatementContext *>(_localctx)->iterator = expressionExt(0);
      }
      setState(644);
      match(azslParser::RightParen);
      setState(645);
      embeddedStatement();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<azslParser::BreakStatementContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(646);
      match(azslParser::Break);
      setState(647);
      match(azslParser::Semi);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<azslParser::ContinueStatementContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(648);
      match(azslParser::Continue);
      setState(649);
      match(azslParser::Semi);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<azslParser::DiscardStatementContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(650);
      match(azslParser::Discard);
      setState(651);
      match(azslParser::Semi);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<azslParser::ReturnStatementContext>(_localctx);
      enterOuterAlt(_localctx, 12);
      setState(652);
      match(azslParser::Return);
      setState(654);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 210) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 210)) & 281474926379007) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 305)) & 211106870190081) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 369)) & 15) != 0)) {
        setState(653);
        antlrcpp::downCast<ReturnStatementContext *>(_localctx)->Expr = expressionExt(0);
      }
      setState(656);
      match(azslParser::Semi);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<azslParser::ExtenstionStatementContext>(_localctx);
      enterOuterAlt(_localctx, 13);
      setState(657);
      compilerExtensionStatement();
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<azslParser::TypeAliasingDefinitionStatementLabelContext>(_localctx);
      enterOuterAlt(_localctx, 14);
      setState(658);
      typeAliasingDefinitionStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseClauseContext ------------------------------------------------------------------

azslParser::ElseClauseContext::ElseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ElseClauseContext::Else() {
  return getToken(azslParser::Else, 0);
}

azslParser::EmbeddedStatementContext* azslParser::ElseClauseContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}


size_t azslParser::ElseClauseContext::getRuleIndex() const {
  return azslParser::RuleElseClause;
}

void azslParser::ElseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseClause(this);
}

void azslParser::ElseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseClause(this);
}

azslParser::ElseClauseContext* azslParser::elseClause() {
  ElseClauseContext *_localctx = _tracker.createInstance<ElseClauseContext>(_ctx, getState());
  enterRule(_localctx, 84, azslParser::RuleElseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(661);
    match(azslParser::Else);
    setState(662);
    antlrcpp::downCast<ElseClauseContext *>(_localctx)->Stmt = embeddedStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::ExpressionContext::getRuleIndex() const {
  return azslParser::RuleExpression;
}

void azslParser::ExpressionContext::copyFrom(ExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ParenthesizedExpressionContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::ParenthesizedExpressionContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::ExpressionExtContext* azslParser::ParenthesizedExpressionContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}
void azslParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}
//----------------- MemberAccessExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext* azslParser::MemberAccessExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

tree::TerminalNode* azslParser::MemberAccessExpressionContext::Dot() {
  return getToken(azslParser::Dot, 0);
}

azslParser::IdExpressionContext* azslParser::MemberAccessExpressionContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}

azslParser::MemberAccessExpressionContext::MemberAccessExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::MemberAccessExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberAccessExpression(this);
}
void azslParser::MemberAccessExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberAccessExpression(this);
}
//----------------- PrefixUnaryExpressionContext ------------------------------------------------------------------

azslParser::PrefixUnaryOperatorContext* azslParser::PrefixUnaryExpressionContext::prefixUnaryOperator() {
  return getRuleContext<azslParser::PrefixUnaryOperatorContext>(0);
}

azslParser::ExpressionContext* azslParser::PrefixUnaryExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::PrefixUnaryExpressionContext::PrefixUnaryExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::PrefixUnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefixUnaryExpression(this);
}
void azslParser::PrefixUnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefixUnaryExpression(this);
}
//----------------- LiteralExpressionContext ------------------------------------------------------------------

azslParser::LiteralContext* azslParser::LiteralExpressionContext::literal() {
  return getRuleContext<azslParser::LiteralContext>(0);
}

azslParser::LiteralExpressionContext::LiteralExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::LiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralExpression(this);
}
void azslParser::LiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralExpression(this);
}
//----------------- ConditionalExpressionContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ConditionalExpressionContext::Question() {
  return getToken(azslParser::Question, 0);
}

tree::TerminalNode* azslParser::ConditionalExpressionContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::ExpressionContext* azslParser::ConditionalExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

std::vector<azslParser::ExpressionExtContext *> azslParser::ConditionalExpressionContext::expressionExt() {
  return getRuleContexts<azslParser::ExpressionExtContext>();
}

azslParser::ExpressionExtContext* azslParser::ConditionalExpressionContext::expressionExt(size_t i) {
  return getRuleContext<azslParser::ExpressionExtContext>(i);
}

azslParser::ConditionalExpressionContext::ConditionalExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::ConditionalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionalExpression(this);
}
void azslParser::ConditionalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionalExpression(this);
}
//----------------- PostfixUnaryExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext* azslParser::PostfixUnaryExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::PostfixUnaryOperatorContext* azslParser::PostfixUnaryExpressionContext::postfixUnaryOperator() {
  return getRuleContext<azslParser::PostfixUnaryOperatorContext>(0);
}

azslParser::PostfixUnaryExpressionContext::PostfixUnaryExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::PostfixUnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfixUnaryExpression(this);
}
void azslParser::PostfixUnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfixUnaryExpression(this);
}
//----------------- NumericConstructorExpressionContext ------------------------------------------------------------------

azslParser::ScalarOrVectorOrMatrixTypeContext* azslParser::NumericConstructorExpressionContext::scalarOrVectorOrMatrixType() {
  return getRuleContext<azslParser::ScalarOrVectorOrMatrixTypeContext>(0);
}

azslParser::ArgumentListContext* azslParser::NumericConstructorExpressionContext::argumentList() {
  return getRuleContext<azslParser::ArgumentListContext>(0);
}

azslParser::NumericConstructorExpressionContext::NumericConstructorExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::NumericConstructorExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericConstructorExpression(this);
}
void azslParser::NumericConstructorExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericConstructorExpression(this);
}
//----------------- FunctionCallExpressionContext ------------------------------------------------------------------

azslParser::ArgumentListContext* azslParser::FunctionCallExpressionContext::argumentList() {
  return getRuleContext<azslParser::ArgumentListContext>(0);
}

azslParser::ExpressionContext* azslParser::FunctionCallExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::FunctionCallExpressionContext::FunctionCallExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::FunctionCallExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCallExpression(this);
}
void azslParser::FunctionCallExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCallExpression(this);
}
//----------------- IdentifierExpressionContext ------------------------------------------------------------------

azslParser::IdExpressionContext* azslParser::IdentifierExpressionContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}

azslParser::IdentifierExpressionContext::IdentifierExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::IdentifierExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierExpression(this);
}
void azslParser::IdentifierExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierExpression(this);
}
//----------------- BinaryExpressionContext ------------------------------------------------------------------

std::vector<azslParser::ExpressionContext *> azslParser::BinaryExpressionContext::expression() {
  return getRuleContexts<azslParser::ExpressionContext>();
}

azslParser::ExpressionContext* azslParser::BinaryExpressionContext::expression(size_t i) {
  return getRuleContext<azslParser::ExpressionContext>(i);
}

azslParser::BinaryOperatorContext* azslParser::BinaryExpressionContext::binaryOperator() {
  return getRuleContext<azslParser::BinaryOperatorContext>(0);
}

azslParser::BinaryExpressionContext::BinaryExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::BinaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryExpression(this);
}
void azslParser::BinaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryExpression(this);
}
//----------------- AssignmentExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext* azslParser::AssignmentExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::AssignmentOperatorContext* azslParser::AssignmentExpressionContext::assignmentOperator() {
  return getRuleContext<azslParser::AssignmentOperatorContext>(0);
}

azslParser::ExpressionExtContext* azslParser::AssignmentExpressionContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::AssignmentExpressionContext::AssignmentExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}
void azslParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}
//----------------- CastExpressionContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::CastExpressionContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

azslParser::TypeContext* azslParser::CastExpressionContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::CastExpressionContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::ExpressionContext* azslParser::CastExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

std::vector<azslParser::ArrayRankSpecifierContext *> azslParser::CastExpressionContext::arrayRankSpecifier() {
  return getRuleContexts<azslParser::ArrayRankSpecifierContext>();
}

azslParser::ArrayRankSpecifierContext* azslParser::CastExpressionContext::arrayRankSpecifier(size_t i) {
  return getRuleContext<azslParser::ArrayRankSpecifierContext>(i);
}

azslParser::CastExpressionContext::CastExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::CastExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastExpression(this);
}
void azslParser::CastExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastExpression(this);
}
//----------------- ArrayAccessExpressionContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ArrayAccessExpressionContext::LeftBracket() {
  return getToken(azslParser::LeftBracket, 0);
}

tree::TerminalNode* azslParser::ArrayAccessExpressionContext::RightBracket() {
  return getToken(azslParser::RightBracket, 0);
}

std::vector<azslParser::ExpressionContext *> azslParser::ArrayAccessExpressionContext::expression() {
  return getRuleContexts<azslParser::ExpressionContext>();
}

azslParser::ExpressionContext* azslParser::ArrayAccessExpressionContext::expression(size_t i) {
  return getRuleContext<azslParser::ExpressionContext>(i);
}

azslParser::ArrayAccessExpressionContext::ArrayAccessExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::ArrayAccessExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayAccessExpression(this);
}
void azslParser::ArrayAccessExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayAccessExpression(this);
}

azslParser::ExpressionContext* azslParser::expression() {
   return expression(0);
}

azslParser::ExpressionContext* azslParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  azslParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  azslParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 86;
  enterRecursionRule(_localctx, 86, azslParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(688);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(665);
      literal();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<IdentifierExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(666);
      idExpression();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(667);
      match(azslParser::LeftParen);
      setState(668);
      antlrcpp::downCast<ParenthesizedExpressionContext *>(_localctx)->Expr = expressionExt(0);
      setState(669);
      match(azslParser::RightParen);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NumericConstructorExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(671);
      scalarOrVectorOrMatrixType();
      setState(672);
      argumentList();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<CastExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(674);
      match(azslParser::LeftParen);
      setState(675);
      type();
      setState(679);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(676);
        antlrcpp::downCast<CastExpressionContext *>(_localctx)->arrayRankSpecifierContext = arrayRankSpecifier();
        antlrcpp::downCast<CastExpressionContext *>(_localctx)->ArrayRankSpecifiers.push_back(antlrcpp::downCast<CastExpressionContext *>(_localctx)->arrayRankSpecifierContext);
        setState(681);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(682);
      match(azslParser::RightParen);
      setState(683);
      antlrcpp::downCast<CastExpressionContext *>(_localctx)->Expr = expression(6);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<PrefixUnaryExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(685);
      antlrcpp::downCast<PrefixUnaryExpressionContext *>(_localctx)->Operator = prefixUnaryOperator();
      setState(686);
      antlrcpp::downCast<PrefixUnaryExpressionContext *>(_localctx)->Expr = expression(4);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(718);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(716);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<BinaryExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(690);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(691);
          antlrcpp::downCast<BinaryExpressionContext *>(_localctx)->Operator = binaryOperator();
          setState(692);
          antlrcpp::downCast<BinaryExpressionContext *>(_localctx)->Right = expression(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<MemberAccessExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->LHSExpr = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(694);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(695);
          antlrcpp::downCast<MemberAccessExpressionContext *>(_localctx)->DotToken = match(azslParser::Dot);
          setState(696);
          antlrcpp::downCast<MemberAccessExpressionContext *>(_localctx)->Member = idExpression();
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ArrayAccessExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Expr = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(697);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(698);
          match(azslParser::LeftBracket);
          setState(699);
          antlrcpp::downCast<ArrayAccessExpressionContext *>(_localctx)->Index = expression(0);
          setState(700);
          match(azslParser::RightBracket);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<FunctionCallExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Expr = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(702);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(703);
          argumentList();
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<PostfixUnaryExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Expr = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(704);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(705);
          antlrcpp::downCast<PostfixUnaryExpressionContext *>(_localctx)->Operator = postfixUnaryOperator();
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<ConditionalExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Condition = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(706);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(707);
          match(azslParser::Question);
          setState(708);
          antlrcpp::downCast<ConditionalExpressionContext *>(_localctx)->TrueExpr = expressionExt(0);
          setState(709);
          match(azslParser::Colon);
          setState(710);
          antlrcpp::downCast<ConditionalExpressionContext *>(_localctx)->FalseExpr = expressionExt(0);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<AssignmentExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(712);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(713);
          antlrcpp::downCast<AssignmentExpressionContext *>(_localctx)->Operator = assignmentOperator();
          setState(714);
          antlrcpp::downCast<AssignmentExpressionContext *>(_localctx)->Right = expressionExt(0);
          break;
        }

        default:
          break;
        } 
      }
      setState(720);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ExpressionExtContext ------------------------------------------------------------------

azslParser::ExpressionExtContext::ExpressionExtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::ExpressionExtContext::getRuleIndex() const {
  return azslParser::RuleExpressionExt;
}

void azslParser::ExpressionExtContext::copyFrom(ExpressionExtContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- OtherExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext* azslParser::OtherExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::OtherExpressionContext::OtherExpressionContext(ExpressionExtContext *ctx) { copyFrom(ctx); }

void azslParser::OtherExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOtherExpression(this);
}
void azslParser::OtherExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOtherExpression(this);
}
//----------------- CommaExpressionContext ------------------------------------------------------------------

azslParser::ExpressionExtContext* azslParser::CommaExpressionContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

tree::TerminalNode* azslParser::CommaExpressionContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

azslParser::ExpressionContext* azslParser::CommaExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::CommaExpressionContext::CommaExpressionContext(ExpressionExtContext *ctx) { copyFrom(ctx); }

void azslParser::CommaExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommaExpression(this);
}
void azslParser::CommaExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommaExpression(this);
}

azslParser::ExpressionExtContext* azslParser::expressionExt() {
   return expressionExt(0);
}

azslParser::ExpressionExtContext* azslParser::expressionExt(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  azslParser::ExpressionExtContext *_localctx = _tracker.createInstance<ExpressionExtContext>(_ctx, parentState);
  azslParser::ExpressionExtContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 88;
  enterRecursionRule(_localctx, 88, azslParser::RuleExpressionExt, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<OtherExpressionContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(722);
    antlrcpp::downCast<OtherExpressionContext *>(_localctx)->Expr = expression(0);
    _ctx->stop = _input->LT(-1);
    setState(729);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<CommaExpressionContext>(_tracker.createInstance<ExpressionExtContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->Left = previousContext;
        pushNewRecursionContext(newContext, startState, RuleExpressionExt);
        setState(724);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(725);
        antlrcpp::downCast<CommaExpressionContext *>(_localctx)->Operator = match(azslParser::Comma);
        setState(726);
        antlrcpp::downCast<CommaExpressionContext *>(_localctx)->Right = expression(0); 
      }
      setState(731);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PostfixUnaryOperatorContext ------------------------------------------------------------------

azslParser::PostfixUnaryOperatorContext::PostfixUnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::PostfixUnaryOperatorContext::PlusPlus() {
  return getToken(azslParser::PlusPlus, 0);
}

tree::TerminalNode* azslParser::PostfixUnaryOperatorContext::MinusMinus() {
  return getToken(azslParser::MinusMinus, 0);
}


size_t azslParser::PostfixUnaryOperatorContext::getRuleIndex() const {
  return azslParser::RulePostfixUnaryOperator;
}

void azslParser::PostfixUnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfixUnaryOperator(this);
}

void azslParser::PostfixUnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfixUnaryOperator(this);
}

azslParser::PostfixUnaryOperatorContext* azslParser::postfixUnaryOperator() {
  PostfixUnaryOperatorContext *_localctx = _tracker.createInstance<PostfixUnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 90, azslParser::RulePostfixUnaryOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(732);
    _la = _input->LA(1);
    if (!(_la == azslParser::PlusPlus

    || _la == azslParser::MinusMinus)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrefixUnaryOperatorContext ------------------------------------------------------------------

azslParser::PrefixUnaryOperatorContext::PrefixUnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::Plus() {
  return getToken(azslParser::Plus, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::Minus() {
  return getToken(azslParser::Minus, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::Not() {
  return getToken(azslParser::Not, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::Tilde() {
  return getToken(azslParser::Tilde, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::PlusPlus() {
  return getToken(azslParser::PlusPlus, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::MinusMinus() {
  return getToken(azslParser::MinusMinus, 0);
}


size_t azslParser::PrefixUnaryOperatorContext::getRuleIndex() const {
  return azslParser::RulePrefixUnaryOperator;
}

void azslParser::PrefixUnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefixUnaryOperator(this);
}

void azslParser::PrefixUnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefixUnaryOperator(this);
}

azslParser::PrefixUnaryOperatorContext* azslParser::prefixUnaryOperator() {
  PrefixUnaryOperatorContext *_localctx = _tracker.createInstance<PrefixUnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 92, azslParser::RulePrefixUnaryOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(734);
    _la = _input->LA(1);
    if (!(((((_la - 318) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 318)) & 12303) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryOperatorContext ------------------------------------------------------------------

azslParser::BinaryOperatorContext::BinaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Star() {
  return getToken(azslParser::Star, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Div() {
  return getToken(azslParser::Div, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Mod() {
  return getToken(azslParser::Mod, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Plus() {
  return getToken(azslParser::Plus, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Minus() {
  return getToken(azslParser::Minus, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::LeftShift() {
  return getToken(azslParser::LeftShift, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::RightShift() {
  return getToken(azslParser::RightShift, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Less() {
  return getToken(azslParser::Less, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::LessEqual() {
  return getToken(azslParser::LessEqual, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::GreaterEqual() {
  return getToken(azslParser::GreaterEqual, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Equal() {
  return getToken(azslParser::Equal, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::NotEqual() {
  return getToken(azslParser::NotEqual, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::And() {
  return getToken(azslParser::And, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Caret() {
  return getToken(azslParser::Caret, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Or() {
  return getToken(azslParser::Or, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::AndAnd() {
  return getToken(azslParser::AndAnd, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::OrOr() {
  return getToken(azslParser::OrOr, 0);
}


size_t azslParser::BinaryOperatorContext::getRuleIndex() const {
  return azslParser::RuleBinaryOperator;
}

void azslParser::BinaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryOperator(this);
}

void azslParser::BinaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryOperator(this);
}

azslParser::BinaryOperatorContext* azslParser::binaryOperator() {
  BinaryOperatorContext *_localctx = _tracker.createInstance<BinaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 94, azslParser::RuleBinaryOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(736);
    _la = _input->LA(1);
    if (!(((((_la - 312) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 312)) & 206158691711) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

azslParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::StarAssign() {
  return getToken(azslParser::StarAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::DivAssign() {
  return getToken(azslParser::DivAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::ModAssign() {
  return getToken(azslParser::ModAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::PlusAssign() {
  return getToken(azslParser::PlusAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::MinusAssign() {
  return getToken(azslParser::MinusAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::LeftShiftAssign() {
  return getToken(azslParser::LeftShiftAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::RightShiftAssign() {
  return getToken(azslParser::RightShiftAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::AndAssign() {
  return getToken(azslParser::AndAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::XorAssign() {
  return getToken(azslParser::XorAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::OrAssign() {
  return getToken(azslParser::OrAssign, 0);
}


size_t azslParser::AssignmentOperatorContext::getRuleIndex() const {
  return azslParser::RuleAssignmentOperator;
}

void azslParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void azslParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

azslParser::AssignmentOperatorContext* azslParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 96, azslParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(738);
    _la = _input->LA(1);
    if (!(((((_la - 337) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 337)) & 2047) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentListContext ------------------------------------------------------------------

azslParser::ArgumentListContext::ArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ArgumentListContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::ArgumentListContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::ArgumentsContext* azslParser::ArgumentListContext::arguments() {
  return getRuleContext<azslParser::ArgumentsContext>(0);
}


size_t azslParser::ArgumentListContext::getRuleIndex() const {
  return azslParser::RuleArgumentList;
}

void azslParser::ArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgumentList(this);
}

void azslParser::ArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgumentList(this);
}

azslParser::ArgumentListContext* azslParser::argumentList() {
  ArgumentListContext *_localctx = _tracker.createInstance<ArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 98, azslParser::RuleArgumentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(740);
    match(azslParser::LeftParen);
    setState(742);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 281474926379007) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 305)) & 211106870190081) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 369)) & 15) != 0)) {
      setState(741);
      arguments();
    }
    setState(744);
    match(azslParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

azslParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::ExpressionContext *> azslParser::ArgumentsContext::expression() {
  return getRuleContexts<azslParser::ExpressionContext>();
}

azslParser::ExpressionContext* azslParser::ArgumentsContext::expression(size_t i) {
  return getRuleContext<azslParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::ArgumentsContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::ArgumentsContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::ArgumentsContext::getRuleIndex() const {
  return azslParser::RuleArguments;
}

void azslParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void azslParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}

azslParser::ArgumentsContext* azslParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 100, azslParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(746);
    expression(0);
    setState(751);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(747);
      match(azslParser::Comma);
      setState(748);
      expression(0);
      setState(753);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

azslParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TypeContext* azslParser::VariableDeclarationContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

azslParser::VariableDeclaratorsContext* azslParser::VariableDeclarationContext::variableDeclarators() {
  return getRuleContext<azslParser::VariableDeclaratorsContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::VariableDeclarationContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::VariableDeclarationContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::VariableDeclarationContext::getRuleIndex() const {
  return azslParser::RuleVariableDeclaration;
}

void azslParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void azslParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}

azslParser::VariableDeclarationContext* azslParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 102, azslParser::RuleVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(757);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(754);
      attributeSpecifierAny();
      setState(759);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(760);
    type();
    setState(761);
    variableDeclarators();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclaratorsContext ------------------------------------------------------------------

azslParser::VariableDeclaratorsContext::VariableDeclaratorsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::NamedVariableDeclaratorContext *> azslParser::VariableDeclaratorsContext::namedVariableDeclarator() {
  return getRuleContexts<azslParser::NamedVariableDeclaratorContext>();
}

azslParser::NamedVariableDeclaratorContext* azslParser::VariableDeclaratorsContext::namedVariableDeclarator(size_t i) {
  return getRuleContext<azslParser::NamedVariableDeclaratorContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::VariableDeclaratorsContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::VariableDeclaratorsContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::VariableDeclaratorsContext::getRuleIndex() const {
  return azslParser::RuleVariableDeclarators;
}

void azslParser::VariableDeclaratorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarators(this);
}

void azslParser::VariableDeclaratorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarators(this);
}

azslParser::VariableDeclaratorsContext* azslParser::variableDeclarators() {
  VariableDeclaratorsContext *_localctx = _tracker.createInstance<VariableDeclaratorsContext>(_ctx, getState());
  enterRule(_localctx, 104, azslParser::RuleVariableDeclarators);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(763);
    antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->namedVariableDeclaratorContext = namedVariableDeclarator();
    antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->VarDecls.push_back(antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->namedVariableDeclaratorContext);
    setState(768);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(764);
      match(azslParser::Comma);
      setState(765);
      antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->namedVariableDeclaratorContext = namedVariableDeclarator();
      antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->VarDecls.push_back(antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->namedVariableDeclaratorContext);
      setState(770);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnnamedVariableDeclaratorContext ------------------------------------------------------------------

azslParser::UnnamedVariableDeclaratorContext::UnnamedVariableDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::PackOffsetNodeContext* azslParser::UnnamedVariableDeclaratorContext::packOffsetNode() {
  return getRuleContext<azslParser::PackOffsetNodeContext>(0);
}

azslParser::VariableInitializerContext* azslParser::UnnamedVariableDeclaratorContext::variableInitializer() {
  return getRuleContext<azslParser::VariableInitializerContext>(0);
}

std::vector<azslParser::ArrayRankSpecifierContext *> azslParser::UnnamedVariableDeclaratorContext::arrayRankSpecifier() {
  return getRuleContexts<azslParser::ArrayRankSpecifierContext>();
}

azslParser::ArrayRankSpecifierContext* azslParser::UnnamedVariableDeclaratorContext::arrayRankSpecifier(size_t i) {
  return getRuleContext<azslParser::ArrayRankSpecifierContext>(i);
}

azslParser::HlslSemanticContext* azslParser::UnnamedVariableDeclaratorContext::hlslSemantic() {
  return getRuleContext<azslParser::HlslSemanticContext>(0);
}

azslParser::RegisterAllocationContext* azslParser::UnnamedVariableDeclaratorContext::registerAllocation() {
  return getRuleContext<azslParser::RegisterAllocationContext>(0);
}


size_t azslParser::UnnamedVariableDeclaratorContext::getRuleIndex() const {
  return azslParser::RuleUnnamedVariableDeclarator;
}

void azslParser::UnnamedVariableDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnnamedVariableDeclarator(this);
}

void azslParser::UnnamedVariableDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnnamedVariableDeclarator(this);
}

azslParser::UnnamedVariableDeclaratorContext* azslParser::unnamedVariableDeclarator() {
  UnnamedVariableDeclaratorContext *_localctx = _tracker.createInstance<UnnamedVariableDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 106, azslParser::RuleUnnamedVariableDeclarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(774);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket) {
      setState(771);
      antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->arrayRankSpecifierContext = arrayRankSpecifier();
      antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->ArrayRankSpecifiers.push_back(antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->arrayRankSpecifierContext);
      setState(776);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(778);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
    case 1: {
      setState(777);
      antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->SemanticOpt = hlslSemantic();
      break;
    }

    default:
      break;
    }
    setState(781);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
    case 1: {
      setState(780);
      packOffsetNode();
      break;
    }

    default:
      break;
    }
    setState(784);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(783);
      antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->RegisterAllocation = registerAllocation();
    }
    setState(787);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::LeftBrace

    || _la == azslParser::Assign) {
      setState(786);
      variableInitializer();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedVariableDeclaratorContext ------------------------------------------------------------------

azslParser::NamedVariableDeclaratorContext::NamedVariableDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::UnnamedVariableDeclaratorContext* azslParser::NamedVariableDeclaratorContext::unnamedVariableDeclarator() {
  return getRuleContext<azslParser::UnnamedVariableDeclaratorContext>(0);
}

tree::TerminalNode* azslParser::NamedVariableDeclaratorContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::NamedVariableDeclaratorContext::getRuleIndex() const {
  return azslParser::RuleNamedVariableDeclarator;
}

void azslParser::NamedVariableDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedVariableDeclarator(this);
}

void azslParser::NamedVariableDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedVariableDeclarator(this);
}

azslParser::NamedVariableDeclaratorContext* azslParser::namedVariableDeclarator() {
  NamedVariableDeclaratorContext *_localctx = _tracker.createInstance<NamedVariableDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 108, azslParser::RuleNamedVariableDeclarator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(789);
    antlrcpp::downCast<NamedVariableDeclaratorContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(790);
    unnamedVariableDeclarator();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableInitializerContext ------------------------------------------------------------------

azslParser::VariableInitializerContext::VariableInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::VariableInitializerContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::StandardVariableInitializerContext* azslParser::VariableInitializerContext::standardVariableInitializer() {
  return getRuleContext<azslParser::StandardVariableInitializerContext>(0);
}

azslParser::SamplerBodyDeclarationContext* azslParser::VariableInitializerContext::samplerBodyDeclaration() {
  return getRuleContext<azslParser::SamplerBodyDeclarationContext>(0);
}


size_t azslParser::VariableInitializerContext::getRuleIndex() const {
  return azslParser::RuleVariableInitializer;
}

void azslParser::VariableInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableInitializer(this);
}

void azslParser::VariableInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableInitializer(this);
}

azslParser::VariableInitializerContext* azslParser::variableInitializer() {
  VariableInitializerContext *_localctx = _tracker.createInstance<VariableInitializerContext>(_ctx, getState());
  enterRule(_localctx, 110, azslParser::RuleVariableInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(795);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Assign: {
        enterOuterAlt(_localctx, 1);
        setState(792);
        match(azslParser::Assign);
        setState(793);
        standardVariableInitializer();
        break;
      }

      case azslParser::LeftBrace: {
        enterOuterAlt(_localctx, 2);
        setState(794);
        samplerBodyDeclaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StandardVariableInitializerContext ------------------------------------------------------------------

azslParser::StandardVariableInitializerContext::StandardVariableInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StandardVariableInitializerContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

azslParser::ArrayElementInitializersContext* azslParser::StandardVariableInitializerContext::arrayElementInitializers() {
  return getRuleContext<azslParser::ArrayElementInitializersContext>(0);
}

tree::TerminalNode* azslParser::StandardVariableInitializerContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

azslParser::ExpressionContext* azslParser::StandardVariableInitializerContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}


size_t azslParser::StandardVariableInitializerContext::getRuleIndex() const {
  return azslParser::RuleStandardVariableInitializer;
}

void azslParser::StandardVariableInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandardVariableInitializer(this);
}

void azslParser::StandardVariableInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandardVariableInitializer(this);
}

azslParser::StandardVariableInitializerContext* azslParser::standardVariableInitializer() {
  StandardVariableInitializerContext *_localctx = _tracker.createInstance<StandardVariableInitializerContext>(_ctx, getState());
  enterRule(_localctx, 112, azslParser::RuleStandardVariableInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(802);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::LeftBrace: {
        enterOuterAlt(_localctx, 1);
        setState(797);
        match(azslParser::LeftBrace);
        setState(798);
        arrayElementInitializers();
        setState(799);
        match(azslParser::RightBrace);
        break;
      }

      case azslParser::Bool:
      case azslParser::Bool1:
      case azslParser::Bool2:
      case azslParser::Bool3:
      case azslParser::Bool4:
      case azslParser::Bool1x1:
      case azslParser::Bool1x2:
      case azslParser::Bool1x3:
      case azslParser::Bool1x4:
      case azslParser::Bool2x1:
      case azslParser::Bool2x2:
      case azslParser::Bool2x3:
      case azslParser::Bool2x4:
      case azslParser::Bool3x1:
      case azslParser::Bool3x2:
      case azslParser::Bool3x3:
      case azslParser::Bool3x4:
      case azslParser::Bool4x1:
      case azslParser::Bool4x2:
      case azslParser::Bool4x3:
      case azslParser::Bool4x4:
      case azslParser::Double:
      case azslParser::Double1:
      case azslParser::Double2:
      case azslParser::Double3:
      case azslParser::Double4:
      case azslParser::Double1x1:
      case azslParser::Double1x2:
      case azslParser::Double1x3:
      case azslParser::Double1x4:
      case azslParser::Double2x1:
      case azslParser::Double2x2:
      case azslParser::Double2x3:
      case azslParser::Double2x4:
      case azslParser::Double3x1:
      case azslParser::Double3x2:
      case azslParser::Double3x3:
      case azslParser::Double3x4:
      case azslParser::Double4x1:
      case azslParser::Double4x2:
      case azslParser::Double4x3:
      case azslParser::Double4x4:
      case azslParser::Float:
      case azslParser::Float1:
      case azslParser::Float2:
      case azslParser::Float3:
      case azslParser::Float4:
      case azslParser::Float1x1:
      case azslParser::Float1x2:
      case azslParser::Float1x3:
      case azslParser::Float1x4:
      case azslParser::Float2x1:
      case azslParser::Float2x2:
      case azslParser::Float2x3:
      case azslParser::Float2x4:
      case azslParser::Float3x1:
      case azslParser::Float3x2:
      case azslParser::Float3x3:
      case azslParser::Float3x4:
      case azslParser::Float4x1:
      case azslParser::Float4x2:
      case azslParser::Float4x3:
      case azslParser::Float4x4:
      case azslParser::Half:
      case azslParser::Half1:
      case azslParser::Half2:
      case azslParser::Half3:
      case azslParser::Half4:
      case azslParser::Half1x1:
      case azslParser::Half1x2:
      case azslParser::Half1x3:
      case azslParser::Half1x4:
      case azslParser::Half2x1:
      case azslParser::Half2x2:
      case azslParser::Half2x3:
      case azslParser::Half2x4:
      case azslParser::Half3x1:
      case azslParser::Half3x2:
      case azslParser::Half3x3:
      case azslParser::Half3x4:
      case azslParser::Half4x1:
      case azslParser::Half4x2:
      case azslParser::Half4x3:
      case azslParser::Half4x4:
      case azslParser::Int:
      case azslParser::Int16_t:
      case azslParser::Int32_t:
      case azslParser::Int64_t:
      case azslParser::Int1:
      case azslParser::Int2:
      case azslParser::Int3:
      case azslParser::Int4:
      case azslParser::Int1x1:
      case azslParser::Int1x2:
      case azslParser::Int1x3:
      case azslParser::Int1x4:
      case azslParser::Int2x1:
      case azslParser::Int2x2:
      case azslParser::Int2x3:
      case azslParser::Int2x4:
      case azslParser::Int3x1:
      case azslParser::Int3x2:
      case azslParser::Int3x3:
      case azslParser::Int3x4:
      case azslParser::Int4x1:
      case azslParser::Int4x2:
      case azslParser::Int4x3:
      case azslParser::Int4x4:
      case azslParser::Matrix:
      case azslParser::Uint:
      case azslParser::Uint1:
      case azslParser::Uint2:
      case azslParser::Uint3:
      case azslParser::Uint4:
      case azslParser::Uint1x1:
      case azslParser::Uint1x2:
      case azslParser::Uint1x3:
      case azslParser::Uint1x4:
      case azslParser::Uint2x1:
      case azslParser::Uint2x2:
      case azslParser::Uint2x3:
      case azslParser::Uint2x4:
      case azslParser::Uint3x1:
      case azslParser::Uint3x2:
      case azslParser::Uint3x3:
      case azslParser::Uint3x4:
      case azslParser::Uint4x1:
      case azslParser::Uint4x2:
      case azslParser::Uint4x3:
      case azslParser::Uint4x4:
      case azslParser::Uint16_t:
      case azslParser::Uint32_t:
      case azslParser::Uint64_t:
      case azslParser::Dword:
      case azslParser::Dword1:
      case azslParser::Dword2:
      case azslParser::Dword3:
      case azslParser::Dword4:
      case azslParser::Dword1x1:
      case azslParser::Dword1x2:
      case azslParser::Dword1x3:
      case azslParser::Dword1x4:
      case azslParser::Dword2x1:
      case azslParser::Dword2x2:
      case azslParser::Dword2x3:
      case azslParser::Dword2x4:
      case azslParser::Dword3x1:
      case azslParser::Dword3x2:
      case azslParser::Dword3x3:
      case azslParser::Dword3x4:
      case azslParser::Dword4x1:
      case azslParser::Dword4x2:
      case azslParser::Dword4x3:
      case azslParser::Dword4x4:
      case azslParser::Vector:
      case azslParser::LeftParen:
      case azslParser::Plus:
      case azslParser::PlusPlus:
      case azslParser::Minus:
      case azslParser::MinusMinus:
      case azslParser::Not:
      case azslParser::Tilde:
      case azslParser::ColonColon:
      case azslParser::True:
      case azslParser::False:
      case azslParser::Identifier:
      case azslParser::IntegerLiteral:
      case azslParser::FloatLiteral:
      case azslParser::StringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(801);
        antlrcpp::downCast<StandardVariableInitializerContext *>(_localctx)->Expr = expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayElementInitializersContext ------------------------------------------------------------------

azslParser::ArrayElementInitializersContext::ArrayElementInitializersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::StandardVariableInitializerContext *> azslParser::ArrayElementInitializersContext::standardVariableInitializer() {
  return getRuleContexts<azslParser::StandardVariableInitializerContext>();
}

azslParser::StandardVariableInitializerContext* azslParser::ArrayElementInitializersContext::standardVariableInitializer(size_t i) {
  return getRuleContext<azslParser::StandardVariableInitializerContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::ArrayElementInitializersContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::ArrayElementInitializersContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::ArrayElementInitializersContext::getRuleIndex() const {
  return azslParser::RuleArrayElementInitializers;
}

void azslParser::ArrayElementInitializersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayElementInitializers(this);
}

void azslParser::ArrayElementInitializersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayElementInitializers(this);
}

azslParser::ArrayElementInitializersContext* azslParser::arrayElementInitializers() {
  ArrayElementInitializersContext *_localctx = _tracker.createInstance<ArrayElementInitializersContext>(_ctx, getState());
  enterRule(_localctx, 114, azslParser::RuleArrayElementInitializers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(804);
    standardVariableInitializer();
    setState(809);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(805);
        match(azslParser::Comma);
        setState(806);
        standardVariableInitializer(); 
      }
      setState(811);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx);
    }
    setState(813);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Comma) {
      setState(812);
      match(azslParser::Comma);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayRankSpecifierContext ------------------------------------------------------------------

azslParser::ArrayRankSpecifierContext::ArrayRankSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ArrayRankSpecifierContext::LeftBracket() {
  return getToken(azslParser::LeftBracket, 0);
}

tree::TerminalNode* azslParser::ArrayRankSpecifierContext::RightBracket() {
  return getToken(azslParser::RightBracket, 0);
}

azslParser::ExpressionContext* azslParser::ArrayRankSpecifierContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}


size_t azslParser::ArrayRankSpecifierContext::getRuleIndex() const {
  return azslParser::RuleArrayRankSpecifier;
}

void azslParser::ArrayRankSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayRankSpecifier(this);
}

void azslParser::ArrayRankSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayRankSpecifier(this);
}

azslParser::ArrayRankSpecifierContext* azslParser::arrayRankSpecifier() {
  ArrayRankSpecifierContext *_localctx = _tracker.createInstance<ArrayRankSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 116, azslParser::RuleArrayRankSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(815);
    match(azslParser::LeftBracket);
    setState(817);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 281474926379007) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 305)) & 211106870190081) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 369)) & 15) != 0)) {
      setState(816);
      antlrcpp::downCast<ArrayRankSpecifierContext *>(_localctx)->Dimension = expression(0);
    }
    setState(819);
    match(azslParser::RightBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PackOffsetNodeContext ------------------------------------------------------------------

azslParser::PackOffsetNodeContext::PackOffsetNodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::Packoffset() {
  return getToken(azslParser::Packoffset, 0);
}

std::vector<tree::TerminalNode *> azslParser::PackOffsetNodeContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::Dot() {
  return getToken(azslParser::Dot, 0);
}


size_t azslParser::PackOffsetNodeContext::getRuleIndex() const {
  return azslParser::RulePackOffsetNode;
}

void azslParser::PackOffsetNodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackOffsetNode(this);
}

void azslParser::PackOffsetNodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackOffsetNode(this);
}

azslParser::PackOffsetNodeContext* azslParser::packOffsetNode() {
  PackOffsetNodeContext *_localctx = _tracker.createInstance<PackOffsetNodeContext>(_ctx, getState());
  enterRule(_localctx, 118, azslParser::RulePackOffsetNode);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(821);
    match(azslParser::Colon);
    setState(822);
    antlrcpp::downCast<PackOffsetNodeContext *>(_localctx)->PackoffsetKeyword = match(azslParser::Packoffset);
    setState(823);
    match(azslParser::LeftParen);
    setState(824);
    antlrcpp::downCast<PackOffsetNodeContext *>(_localctx)->PackOffsetRegister = match(azslParser::Identifier);
    setState(827);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Dot) {
      setState(825);
      match(azslParser::Dot);
      setState(826);
      antlrcpp::downCast<PackOffsetNodeContext *>(_localctx)->PackOffsetComponent = match(azslParser::Identifier);
    }
    setState(829);
    match(azslParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageFlagsContext ------------------------------------------------------------------

azslParser::StorageFlagsContext::StorageFlagsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::StorageFlagContext *> azslParser::StorageFlagsContext::storageFlag() {
  return getRuleContexts<azslParser::StorageFlagContext>();
}

azslParser::StorageFlagContext* azslParser::StorageFlagsContext::storageFlag(size_t i) {
  return getRuleContext<azslParser::StorageFlagContext>(i);
}


size_t azslParser::StorageFlagsContext::getRuleIndex() const {
  return azslParser::RuleStorageFlags;
}

void azslParser::StorageFlagsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageFlags(this);
}

void azslParser::StorageFlagsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageFlags(this);
}

azslParser::StorageFlagsContext* azslParser::storageFlags() {
  StorageFlagsContext *_localctx = _tracker.createInstance<StorageFlagsContext>(_ctx, getState());
  enterRule(_localctx, 120, azslParser::RuleStorageFlags);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(834);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(831);
        storageFlag(); 
      }
      setState(836);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageFlagContext ------------------------------------------------------------------

azslParser::StorageFlagContext::StorageFlagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StorageFlagContext::Const() {
  return getToken(azslParser::Const, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Unsigned() {
  return getToken(azslParser::Unsigned, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::RowMajor() {
  return getToken(azslParser::RowMajor, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::ColumnMajor() {
  return getToken(azslParser::ColumnMajor, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Extern() {
  return getToken(azslParser::Extern, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Inline() {
  return getToken(azslParser::Inline, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Rootconstant() {
  return getToken(azslParser::Rootconstant, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Option() {
  return getToken(azslParser::Option, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Precise() {
  return getToken(azslParser::Precise, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Shared() {
  return getToken(azslParser::Shared, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Groupshared() {
  return getToken(azslParser::Groupshared, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Static() {
  return getToken(azslParser::Static, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Uniform() {
  return getToken(azslParser::Uniform, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Volatile() {
  return getToken(azslParser::Volatile, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Globallycoherent() {
  return getToken(azslParser::Globallycoherent, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::SNorm() {
  return getToken(azslParser::SNorm, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::UNorm() {
  return getToken(azslParser::UNorm, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Linear() {
  return getToken(azslParser::Linear, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Centroid() {
  return getToken(azslParser::Centroid, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Nointerpolation() {
  return getToken(azslParser::Nointerpolation, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Noperspective() {
  return getToken(azslParser::Noperspective, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Sample() {
  return getToken(azslParser::Sample, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::In() {
  return getToken(azslParser::In, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Out() {
  return getToken(azslParser::Out, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Inout() {
  return getToken(azslParser::Inout, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Point() {
  return getToken(azslParser::Point, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Line_() {
  return getToken(azslParser::Line_, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Triangle() {
  return getToken(azslParser::Triangle, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::LineAdj() {
  return getToken(azslParser::LineAdj, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::TriangleAdj() {
  return getToken(azslParser::TriangleAdj, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::StorageFlagContext::getRuleIndex() const {
  return azslParser::RuleStorageFlag;
}

void azslParser::StorageFlagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageFlag(this);
}

void azslParser::StorageFlagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageFlag(this);
}

azslParser::StorageFlagContext* azslParser::storageFlag() {
  StorageFlagContext *_localctx = _tracker.createInstance<StorageFlagContext>(_ctx, getState());
  enterRule(_localctx, 122, azslParser::RuleStorageFlag);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(837);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 26306674688) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 16888498703302657) != 0) || ((((_la - 144) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 144)) & -4611562597710216249) != 0) || ((((_la - 209) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 209)) & 562950054084609) != 0) || _la == azslParser::Identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

azslParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StorageFlagsContext* azslParser::TypeContext::storageFlags() {
  return getRuleContext<azslParser::StorageFlagsContext>(0);
}

azslParser::PredefinedTypeContext* azslParser::TypeContext::predefinedType() {
  return getRuleContext<azslParser::PredefinedTypeContext>(0);
}

azslParser::UserDefinedTypeContext* azslParser::TypeContext::userDefinedType() {
  return getRuleContext<azslParser::UserDefinedTypeContext>(0);
}

azslParser::TypeofExpressionContext* azslParser::TypeContext::typeofExpression() {
  return getRuleContext<azslParser::TypeofExpressionContext>(0);
}

tree::TerminalNode* azslParser::TypeContext::Void() {
  return getToken(azslParser::Void, 0);
}


size_t azslParser::TypeContext::getRuleIndex() const {
  return azslParser::RuleType;
}

void azslParser::TypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType(this);
}

void azslParser::TypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType(this);
}

azslParser::TypeContext* azslParser::type() {
  TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
  enterRule(_localctx, 124, azslParser::RuleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(839);
    storageFlags();
    setState(844);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::AppendStructuredBuffer:
      case azslParser::Bool:
      case azslParser::Bool1:
      case azslParser::Bool2:
      case azslParser::Bool3:
      case azslParser::Bool4:
      case azslParser::Bool1x1:
      case azslParser::Bool1x2:
      case azslParser::Bool1x3:
      case azslParser::Bool1x4:
      case azslParser::Bool2x1:
      case azslParser::Bool2x2:
      case azslParser::Bool2x3:
      case azslParser::Bool2x4:
      case azslParser::Bool3x1:
      case azslParser::Bool3x2:
      case azslParser::Bool3x3:
      case azslParser::Bool3x4:
      case azslParser::Bool4x1:
      case azslParser::Bool4x2:
      case azslParser::Bool4x3:
      case azslParser::Bool4x4:
      case azslParser::Buffer:
      case azslParser::BuiltInTriangleIntersectionAttributes:
      case azslParser::ByteAddressBuffer:
      case azslParser::ConstantBuffer:
      case azslParser::ConstantBufferCamel:
      case azslParser::ConsumeStructuredBuffer:
      case azslParser::Double:
      case azslParser::Double1:
      case azslParser::Double2:
      case azslParser::Double3:
      case azslParser::Double4:
      case azslParser::Double1x1:
      case azslParser::Double1x2:
      case azslParser::Double1x3:
      case azslParser::Double1x4:
      case azslParser::Double2x1:
      case azslParser::Double2x2:
      case azslParser::Double2x3:
      case azslParser::Double2x4:
      case azslParser::Double3x1:
      case azslParser::Double3x2:
      case azslParser::Double3x3:
      case azslParser::Double3x4:
      case azslParser::Double4x1:
      case azslParser::Double4x2:
      case azslParser::Double4x3:
      case azslParser::Double4x4:
      case azslParser::Float:
      case azslParser::Float1:
      case azslParser::Float2:
      case azslParser::Float3:
      case azslParser::Float4:
      case azslParser::Float1x1:
      case azslParser::Float1x2:
      case azslParser::Float1x3:
      case azslParser::Float1x4:
      case azslParser::Float2x1:
      case azslParser::Float2x2:
      case azslParser::Float2x3:
      case azslParser::Float2x4:
      case azslParser::Float3x1:
      case azslParser::Float3x2:
      case azslParser::Float3x3:
      case azslParser::Float3x4:
      case azslParser::Float4x1:
      case azslParser::Float4x2:
      case azslParser::Float4x3:
      case azslParser::Float4x4:
      case azslParser::Half:
      case azslParser::Half1:
      case azslParser::Half2:
      case azslParser::Half3:
      case azslParser::Half4:
      case azslParser::Half1x1:
      case azslParser::Half1x2:
      case azslParser::Half1x3:
      case azslParser::Half1x4:
      case azslParser::Half2x1:
      case azslParser::Half2x2:
      case azslParser::Half2x3:
      case azslParser::Half2x4:
      case azslParser::Half3x1:
      case azslParser::Half3x2:
      case azslParser::Half3x3:
      case azslParser::Half3x4:
      case azslParser::Half4x1:
      case azslParser::Half4x2:
      case azslParser::Half4x3:
      case azslParser::Half4x4:
      case azslParser::InputPatch:
      case azslParser::Int:
      case azslParser::Int16_t:
      case azslParser::Int32_t:
      case azslParser::Int64_t:
      case azslParser::Int1:
      case azslParser::Int2:
      case azslParser::Int3:
      case azslParser::Int4:
      case azslParser::Int1x1:
      case azslParser::Int1x2:
      case azslParser::Int1x3:
      case azslParser::Int1x4:
      case azslParser::Int2x1:
      case azslParser::Int2x2:
      case azslParser::Int2x3:
      case azslParser::Int2x4:
      case azslParser::Int3x1:
      case azslParser::Int3x2:
      case azslParser::Int3x3:
      case azslParser::Int3x4:
      case azslParser::Int4x1:
      case azslParser::Int4x2:
      case azslParser::Int4x3:
      case azslParser::Int4x4:
      case azslParser::LineStream:
      case azslParser::Matrix:
      case azslParser::OutputPatch:
      case azslParser::PointStream:
      case azslParser::RasterizerOrderedBuffer:
      case azslParser::RasterizerOrderedByteAddressBuffer:
      case azslParser::RasterizerOrderedStructuredBuffer:
      case azslParser::RasterizerOrderedTexture1D:
      case azslParser::RasterizerOrderedTexture1DArray:
      case azslParser::RasterizerOrderedTexture2D:
      case azslParser::RasterizerOrderedTexture2DArray:
      case azslParser::RasterizerOrderedTexture3D:
      case azslParser::RayDesc:
      case azslParser::RaytracingAccelerationStructure:
      case azslParser::RWBuffer:
      case azslParser::RWByteAddressBuffer:
      case azslParser::RWStructuredBuffer:
      case azslParser::RWTexture1D:
      case azslParser::RWTexture1DArray:
      case azslParser::RWTexture2D:
      case azslParser::RWTexture2DArray:
      case azslParser::RWTexture3D:
      case azslParser::Sampler:
      case azslParser::SamplerCapitalS:
      case azslParser::SamplerComparisonState:
      case azslParser::SamplerStateCamel:
      case azslParser::SamplerState:
      case azslParser::StructuredBuffer:
      case azslParser::SubpassInput:
      case azslParser::SubpassInputMS:
      case azslParser::Texture1D:
      case azslParser::Texture1DArray:
      case azslParser::Texture2D:
      case azslParser::Texture2DArray:
      case azslParser::Texture2DMS:
      case azslParser::Texture2DMSArray:
      case azslParser::Texture3D:
      case azslParser::TextureCube:
      case azslParser::TextureCubeArray:
      case azslParser::TriangleStream:
      case azslParser::Uint:
      case azslParser::Uint1:
      case azslParser::Uint2:
      case azslParser::Uint3:
      case azslParser::Uint4:
      case azslParser::Uint1x1:
      case azslParser::Uint1x2:
      case azslParser::Uint1x3:
      case azslParser::Uint1x4:
      case azslParser::Uint2x1:
      case azslParser::Uint2x2:
      case azslParser::Uint2x3:
      case azslParser::Uint2x4:
      case azslParser::Uint3x1:
      case azslParser::Uint3x2:
      case azslParser::Uint3x3:
      case azslParser::Uint3x4:
      case azslParser::Uint4x1:
      case azslParser::Uint4x2:
      case azslParser::Uint4x3:
      case azslParser::Uint4x4:
      case azslParser::Uint16_t:
      case azslParser::Uint32_t:
      case azslParser::Uint64_t:
      case azslParser::Dword:
      case azslParser::Dword1:
      case azslParser::Dword2:
      case azslParser::Dword3:
      case azslParser::Dword4:
      case azslParser::Dword1x1:
      case azslParser::Dword1x2:
      case azslParser::Dword1x3:
      case azslParser::Dword1x4:
      case azslParser::Dword2x1:
      case azslParser::Dword2x2:
      case azslParser::Dword2x3:
      case azslParser::Dword2x4:
      case azslParser::Dword3x1:
      case azslParser::Dword3x2:
      case azslParser::Dword3x3:
      case azslParser::Dword3x4:
      case azslParser::Dword4x1:
      case azslParser::Dword4x2:
      case azslParser::Dword4x3:
      case azslParser::Dword4x4:
      case azslParser::Vector:
      case azslParser::StateObjectConfig:
      case azslParser::LocalRootSignature:
      case azslParser::GlobalRootSignature:
      case azslParser::SubobjectToExportsAssociation:
      case azslParser::RaytracingShaderConfig:
      case azslParser::RaytracingPipelineConfig:
      case azslParser::RaytracingPipelineConfig1:
      case azslParser::TriangleHitGroup:
      case azslParser::ProceduralPrimitiveHitGroup: {
        setState(840);
        predefinedType();
        break;
      }

      case azslParser::Class:
      case azslParser::Enum:
      case azslParser::Interface:
      case azslParser::Struct:
      case azslParser::ColonColon:
      case azslParser::Identifier: {
        setState(841);
        userDefinedType();
        break;
      }

      case azslParser::KW_Typeof: {
        setState(842);
        typeofExpression();
        break;
      }

      case azslParser::Void: {
        setState(843);
        match(azslParser::Void);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredefinedTypeContext ------------------------------------------------------------------

azslParser::PredefinedTypeContext::PredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::BufferPredefinedTypeContext* azslParser::PredefinedTypeContext::bufferPredefinedType() {
  return getRuleContext<azslParser::BufferPredefinedTypeContext>(0);
}

azslParser::ByteAddressBufferTypesContext* azslParser::PredefinedTypeContext::byteAddressBufferTypes() {
  return getRuleContext<azslParser::ByteAddressBufferTypesContext>(0);
}

azslParser::PatchPredefinedTypeContext* azslParser::PredefinedTypeContext::patchPredefinedType() {
  return getRuleContext<azslParser::PatchPredefinedTypeContext>(0);
}

azslParser::MatrixTypeContext* azslParser::PredefinedTypeContext::matrixType() {
  return getRuleContext<azslParser::MatrixTypeContext>(0);
}

azslParser::GenericMatrixPredefinedTypeContext* azslParser::PredefinedTypeContext::genericMatrixPredefinedType() {
  return getRuleContext<azslParser::GenericMatrixPredefinedTypeContext>(0);
}

azslParser::SamplerStatePredefinedTypeContext* azslParser::PredefinedTypeContext::samplerStatePredefinedType() {
  return getRuleContext<azslParser::SamplerStatePredefinedTypeContext>(0);
}

azslParser::ScalarTypeContext* azslParser::PredefinedTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

azslParser::StreamOutputPredefinedTypeContext* azslParser::PredefinedTypeContext::streamOutputPredefinedType() {
  return getRuleContext<azslParser::StreamOutputPredefinedTypeContext>(0);
}

azslParser::StructuredBufferPredefinedTypeContext* azslParser::PredefinedTypeContext::structuredBufferPredefinedType() {
  return getRuleContext<azslParser::StructuredBufferPredefinedTypeContext>(0);
}

azslParser::TexturePredefinedTypeContext* azslParser::PredefinedTypeContext::texturePredefinedType() {
  return getRuleContext<azslParser::TexturePredefinedTypeContext>(0);
}

azslParser::GenericTexturePredefinedTypeContext* azslParser::PredefinedTypeContext::genericTexturePredefinedType() {
  return getRuleContext<azslParser::GenericTexturePredefinedTypeContext>(0);
}

azslParser::MsTexturePredefinedTypeContext* azslParser::PredefinedTypeContext::msTexturePredefinedType() {
  return getRuleContext<azslParser::MsTexturePredefinedTypeContext>(0);
}

azslParser::VectorTypeContext* azslParser::PredefinedTypeContext::vectorType() {
  return getRuleContext<azslParser::VectorTypeContext>(0);
}

azslParser::GenericVectorTypeContext* azslParser::PredefinedTypeContext::genericVectorType() {
  return getRuleContext<azslParser::GenericVectorTypeContext>(0);
}

azslParser::ConstantBufferTemplatedContext* azslParser::PredefinedTypeContext::constantBufferTemplated() {
  return getRuleContext<azslParser::ConstantBufferTemplatedContext>(0);
}

azslParser::OtherViewResourceTypeContext* azslParser::PredefinedTypeContext::otherViewResourceType() {
  return getRuleContext<azslParser::OtherViewResourceTypeContext>(0);
}

azslParser::SubobjectTypeContext* azslParser::PredefinedTypeContext::subobjectType() {
  return getRuleContext<azslParser::SubobjectTypeContext>(0);
}

azslParser::RtxBuiltInTypesContext* azslParser::PredefinedTypeContext::rtxBuiltInTypes() {
  return getRuleContext<azslParser::RtxBuiltInTypesContext>(0);
}


size_t azslParser::PredefinedTypeContext::getRuleIndex() const {
  return azslParser::RulePredefinedType;
}

void azslParser::PredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredefinedType(this);
}

void azslParser::PredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredefinedType(this);
}

azslParser::PredefinedTypeContext* azslParser::predefinedType() {
  PredefinedTypeContext *_localctx = _tracker.createInstance<PredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 126, azslParser::RulePredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(864);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(846);
      bufferPredefinedType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(847);
      byteAddressBufferTypes();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(848);
      patchPredefinedType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(849);
      matrixType();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(850);
      genericMatrixPredefinedType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(851);
      samplerStatePredefinedType();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(852);
      scalarType();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(853);
      streamOutputPredefinedType();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(854);
      structuredBufferPredefinedType();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(855);
      texturePredefinedType();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(856);
      genericTexturePredefinedType();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(857);
      msTexturePredefinedType();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(858);
      vectorType();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(859);
      genericVectorType();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(860);
      constantBufferTemplated();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(861);
      otherViewResourceType();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(862);
      subobjectType();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(863);
      rtxBuiltInTypes();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubobjectTypeContext ------------------------------------------------------------------

azslParser::SubobjectTypeContext::SubobjectTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SubobjectTypeContext::StateObjectConfig() {
  return getToken(azslParser::StateObjectConfig, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::LocalRootSignature() {
  return getToken(azslParser::LocalRootSignature, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::GlobalRootSignature() {
  return getToken(azslParser::GlobalRootSignature, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::SubobjectToExportsAssociation() {
  return getToken(azslParser::SubobjectToExportsAssociation, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::RaytracingShaderConfig() {
  return getToken(azslParser::RaytracingShaderConfig, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::RaytracingPipelineConfig() {
  return getToken(azslParser::RaytracingPipelineConfig, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::RaytracingPipelineConfig1() {
  return getToken(azslParser::RaytracingPipelineConfig1, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::TriangleHitGroup() {
  return getToken(azslParser::TriangleHitGroup, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::ProceduralPrimitiveHitGroup() {
  return getToken(azslParser::ProceduralPrimitiveHitGroup, 0);
}


size_t azslParser::SubobjectTypeContext::getRuleIndex() const {
  return azslParser::RuleSubobjectType;
}

void azslParser::SubobjectTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubobjectType(this);
}

void azslParser::SubobjectTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubobjectType(this);
}

azslParser::SubobjectTypeContext* azslParser::subobjectType() {
  SubobjectTypeContext *_localctx = _tracker.createInstance<SubobjectTypeContext>(_ctx, getState());
  enterRule(_localctx, 128, azslParser::RuleSubobjectType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(866);
    _la = _input->LA(1);
    if (!(((((_la - 261) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 261)) & 511) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OtherViewResourceTypeContext ------------------------------------------------------------------

azslParser::OtherViewResourceTypeContext::OtherViewResourceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::OtherViewResourceTypeContext::RaytracingAccelerationStructure() {
  return getToken(azslParser::RaytracingAccelerationStructure, 0);
}


size_t azslParser::OtherViewResourceTypeContext::getRuleIndex() const {
  return azslParser::RuleOtherViewResourceType;
}

void azslParser::OtherViewResourceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOtherViewResourceType(this);
}

void azslParser::OtherViewResourceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOtherViewResourceType(this);
}

azslParser::OtherViewResourceTypeContext* azslParser::otherViewResourceType() {
  OtherViewResourceTypeContext *_localctx = _tracker.createInstance<OtherViewResourceTypeContext>(_ctx, getState());
  enterRule(_localctx, 130, azslParser::RuleOtherViewResourceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(868);
    match(azslParser::RaytracingAccelerationStructure);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RtxBuiltInTypesContext ------------------------------------------------------------------

azslParser::RtxBuiltInTypesContext::RtxBuiltInTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::RtxBuiltInTypesContext::BuiltInTriangleIntersectionAttributes() {
  return getToken(azslParser::BuiltInTriangleIntersectionAttributes, 0);
}

tree::TerminalNode* azslParser::RtxBuiltInTypesContext::RayDesc() {
  return getToken(azslParser::RayDesc, 0);
}


size_t azslParser::RtxBuiltInTypesContext::getRuleIndex() const {
  return azslParser::RuleRtxBuiltInTypes;
}

void azslParser::RtxBuiltInTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRtxBuiltInTypes(this);
}

void azslParser::RtxBuiltInTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRtxBuiltInTypes(this);
}

azslParser::RtxBuiltInTypesContext* azslParser::rtxBuiltInTypes() {
  RtxBuiltInTypesContext *_localctx = _tracker.createInstance<RtxBuiltInTypesContext>(_ctx, getState());
  enterRule(_localctx, 132, azslParser::RuleRtxBuiltInTypes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(870);
    _la = _input->LA(1);
    if (!(_la == azslParser::BuiltInTriangleIntersectionAttributes || _la == azslParser::RayDesc)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BufferPredefinedTypeContext ------------------------------------------------------------------

azslParser::BufferPredefinedTypeContext::BufferPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::BufferTypeContext* azslParser::BufferPredefinedTypeContext::bufferType() {
  return getRuleContext<azslParser::BufferTypeContext>(0);
}

tree::TerminalNode* azslParser::BufferPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarOrVectorOrMatrixTypeContext* azslParser::BufferPredefinedTypeContext::scalarOrVectorOrMatrixType() {
  return getRuleContext<azslParser::ScalarOrVectorOrMatrixTypeContext>(0);
}

tree::TerminalNode* azslParser::BufferPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}


size_t azslParser::BufferPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleBufferPredefinedType;
}

void azslParser::BufferPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBufferPredefinedType(this);
}

void azslParser::BufferPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBufferPredefinedType(this);
}

azslParser::BufferPredefinedTypeContext* azslParser::bufferPredefinedType() {
  BufferPredefinedTypeContext *_localctx = _tracker.createInstance<BufferPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 134, azslParser::RuleBufferPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(872);
    bufferType();
    setState(873);
    match(azslParser::Less);
    setState(874);
    scalarOrVectorOrMatrixType();
    setState(875);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BufferTypeContext ------------------------------------------------------------------

azslParser::BufferTypeContext::BufferTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BufferTypeContext::Buffer() {
  return getToken(azslParser::Buffer, 0);
}

tree::TerminalNode* azslParser::BufferTypeContext::RWBuffer() {
  return getToken(azslParser::RWBuffer, 0);
}

tree::TerminalNode* azslParser::BufferTypeContext::RasterizerOrderedBuffer() {
  return getToken(azslParser::RasterizerOrderedBuffer, 0);
}


size_t azslParser::BufferTypeContext::getRuleIndex() const {
  return azslParser::RuleBufferType;
}

void azslParser::BufferTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBufferType(this);
}

void azslParser::BufferTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBufferType(this);
}

azslParser::BufferTypeContext* azslParser::bufferType() {
  BufferTypeContext *_localctx = _tracker.createInstance<BufferTypeContext>(_ctx, getState());
  enterRule(_localctx, 136, azslParser::RuleBufferType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(877);
    _la = _input->LA(1);
    if (!(_la == azslParser::Buffer || _la == azslParser::RasterizerOrderedBuffer

    || _la == azslParser::RWBuffer)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ByteAddressBufferTypesContext ------------------------------------------------------------------

azslParser::ByteAddressBufferTypesContext::ByteAddressBufferTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ByteAddressBufferTypesContext::ByteAddressBuffer() {
  return getToken(azslParser::ByteAddressBuffer, 0);
}

tree::TerminalNode* azslParser::ByteAddressBufferTypesContext::RWByteAddressBuffer() {
  return getToken(azslParser::RWByteAddressBuffer, 0);
}

tree::TerminalNode* azslParser::ByteAddressBufferTypesContext::RasterizerOrderedByteAddressBuffer() {
  return getToken(azslParser::RasterizerOrderedByteAddressBuffer, 0);
}


size_t azslParser::ByteAddressBufferTypesContext::getRuleIndex() const {
  return azslParser::RuleByteAddressBufferTypes;
}

void azslParser::ByteAddressBufferTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterByteAddressBufferTypes(this);
}

void azslParser::ByteAddressBufferTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitByteAddressBufferTypes(this);
}

azslParser::ByteAddressBufferTypesContext* azslParser::byteAddressBufferTypes() {
  ByteAddressBufferTypesContext *_localctx = _tracker.createInstance<ByteAddressBufferTypesContext>(_ctx, getState());
  enterRule(_localctx, 138, azslParser::RuleByteAddressBufferTypes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(879);
    _la = _input->LA(1);
    if (!(_la == azslParser::ByteAddressBuffer || _la == azslParser::RasterizerOrderedByteAddressBuffer

    || _la == azslParser::RWByteAddressBuffer)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatchPredefinedTypeContext ------------------------------------------------------------------

azslParser::PatchPredefinedTypeContext::PatchPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::PatchTypeContext* azslParser::PatchPredefinedTypeContext::patchType() {
  return getRuleContext<azslParser::PatchTypeContext>(0);
}

tree::TerminalNode* azslParser::PatchPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

tree::TerminalNode* azslParser::PatchPredefinedTypeContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

tree::TerminalNode* azslParser::PatchPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

azslParser::UserDefinedTypeContext* azslParser::PatchPredefinedTypeContext::userDefinedType() {
  return getRuleContext<azslParser::UserDefinedTypeContext>(0);
}

tree::TerminalNode* azslParser::PatchPredefinedTypeContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}


size_t azslParser::PatchPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RulePatchPredefinedType;
}

void azslParser::PatchPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatchPredefinedType(this);
}

void azslParser::PatchPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatchPredefinedType(this);
}

azslParser::PatchPredefinedTypeContext* azslParser::patchPredefinedType() {
  PatchPredefinedTypeContext *_localctx = _tracker.createInstance<PatchPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 140, azslParser::RulePatchPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(881);
    patchType();
    setState(882);
    match(azslParser::Less);
    setState(883);
    antlrcpp::downCast<PatchPredefinedTypeContext *>(_localctx)->Name = userDefinedType();
    setState(884);
    match(azslParser::Comma);
    setState(885);
    antlrcpp::downCast<PatchPredefinedTypeContext *>(_localctx)->ControlPoints = match(azslParser::IntegerLiteral);
    setState(886);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatchTypeContext ------------------------------------------------------------------

azslParser::PatchTypeContext::PatchTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::PatchTypeContext::InputPatch() {
  return getToken(azslParser::InputPatch, 0);
}

tree::TerminalNode* azslParser::PatchTypeContext::OutputPatch() {
  return getToken(azslParser::OutputPatch, 0);
}


size_t azslParser::PatchTypeContext::getRuleIndex() const {
  return azslParser::RulePatchType;
}

void azslParser::PatchTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatchType(this);
}

void azslParser::PatchTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatchType(this);
}

azslParser::PatchTypeContext* azslParser::patchType() {
  PatchTypeContext *_localctx = _tracker.createInstance<PatchTypeContext>(_ctx, getState());
  enterRule(_localctx, 142, azslParser::RulePatchType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(888);
    _la = _input->LA(1);
    if (!(_la == azslParser::InputPatch

    || _la == azslParser::OutputPatch)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SamplerStatePredefinedTypeContext ------------------------------------------------------------------

azslParser::SamplerStatePredefinedTypeContext::SamplerStatePredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::Sampler() {
  return getToken(azslParser::Sampler, 0);
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::SamplerCapitalS() {
  return getToken(azslParser::SamplerCapitalS, 0);
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::SamplerState() {
  return getToken(azslParser::SamplerState, 0);
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::SamplerStateCamel() {
  return getToken(azslParser::SamplerStateCamel, 0);
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::SamplerComparisonState() {
  return getToken(azslParser::SamplerComparisonState, 0);
}


size_t azslParser::SamplerStatePredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleSamplerStatePredefinedType;
}

void azslParser::SamplerStatePredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSamplerStatePredefinedType(this);
}

void azslParser::SamplerStatePredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSamplerStatePredefinedType(this);
}

azslParser::SamplerStatePredefinedTypeContext* azslParser::samplerStatePredefinedType() {
  SamplerStatePredefinedTypeContext *_localctx = _tracker.createInstance<SamplerStatePredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 144, azslParser::RuleSamplerStatePredefinedType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(890);
    _la = _input->LA(1);
    if (!(((((_la - 183) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 183)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScalarTypeContext ------------------------------------------------------------------

azslParser::ScalarTypeContext::ScalarTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ScalarTypeContext::Bool() {
  return getToken(azslParser::Bool, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Int() {
  return getToken(azslParser::Int, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Int16_t() {
  return getToken(azslParser::Int16_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Int32_t() {
  return getToken(azslParser::Int32_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Int64_t() {
  return getToken(azslParser::Int64_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Uint() {
  return getToken(azslParser::Uint, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Uint16_t() {
  return getToken(azslParser::Uint16_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Uint32_t() {
  return getToken(azslParser::Uint32_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Uint64_t() {
  return getToken(azslParser::Uint64_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Dword() {
  return getToken(azslParser::Dword, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Half() {
  return getToken(azslParser::Half, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Float() {
  return getToken(azslParser::Float, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Double() {
  return getToken(azslParser::Double, 0);
}


size_t azslParser::ScalarTypeContext::getRuleIndex() const {
  return azslParser::RuleScalarType;
}

void azslParser::ScalarTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalarType(this);
}

void azslParser::ScalarTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalarType(this);
}

azslParser::ScalarTypeContext* azslParser::scalarType() {
  ScalarTypeContext *_localctx = _tracker.createInstance<ScalarTypeContext>(_ctx, getState());
  enterRule(_localctx, 146, azslParser::RuleScalarType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(892);
    _la = _input->LA(1);
    if (!(_la == azslParser::Bool

    || _la == azslParser::Double || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & 67553994444111873) != 0) || ((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 81788929) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamOutputPredefinedTypeContext ------------------------------------------------------------------

azslParser::StreamOutputPredefinedTypeContext::StreamOutputPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StreamOutputObjectTypeContext* azslParser::StreamOutputPredefinedTypeContext::streamOutputObjectType() {
  return getRuleContext<azslParser::StreamOutputObjectTypeContext>(0);
}

tree::TerminalNode* azslParser::StreamOutputPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::TypeContext* azslParser::StreamOutputPredefinedTypeContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::StreamOutputPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}


size_t azslParser::StreamOutputPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleStreamOutputPredefinedType;
}

void azslParser::StreamOutputPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamOutputPredefinedType(this);
}

void azslParser::StreamOutputPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamOutputPredefinedType(this);
}

azslParser::StreamOutputPredefinedTypeContext* azslParser::streamOutputPredefinedType() {
  StreamOutputPredefinedTypeContext *_localctx = _tracker.createInstance<StreamOutputPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 148, azslParser::RuleStreamOutputPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(894);
    streamOutputObjectType();
    setState(895);
    match(azslParser::Less);
    setState(896);
    type();
    setState(897);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamOutputObjectTypeContext ------------------------------------------------------------------

azslParser::StreamOutputObjectTypeContext::StreamOutputObjectTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StreamOutputObjectTypeContext::PointStream() {
  return getToken(azslParser::PointStream, 0);
}

tree::TerminalNode* azslParser::StreamOutputObjectTypeContext::LineStream() {
  return getToken(azslParser::LineStream, 0);
}

tree::TerminalNode* azslParser::StreamOutputObjectTypeContext::TriangleStream() {
  return getToken(azslParser::TriangleStream, 0);
}


size_t azslParser::StreamOutputObjectTypeContext::getRuleIndex() const {
  return azslParser::RuleStreamOutputObjectType;
}

void azslParser::StreamOutputObjectTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamOutputObjectType(this);
}

void azslParser::StreamOutputObjectTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamOutputObjectType(this);
}

azslParser::StreamOutputObjectTypeContext* azslParser::streamOutputObjectType() {
  StreamOutputObjectTypeContext *_localctx = _tracker.createInstance<StreamOutputObjectTypeContext>(_ctx, getState());
  enterRule(_localctx, 150, azslParser::RuleStreamOutputObjectType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(899);
    _la = _input->LA(1);
    if (!(((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2305843009213698049) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructuredBufferPredefinedTypeContext ------------------------------------------------------------------

azslParser::StructuredBufferPredefinedTypeContext::StructuredBufferPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StructuredBufferNameContext* azslParser::StructuredBufferPredefinedTypeContext::structuredBufferName() {
  return getRuleContext<azslParser::StructuredBufferNameContext>(0);
}

tree::TerminalNode* azslParser::StructuredBufferPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::TypeContext* azslParser::StructuredBufferPredefinedTypeContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::StructuredBufferPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}


size_t azslParser::StructuredBufferPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleStructuredBufferPredefinedType;
}

void azslParser::StructuredBufferPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructuredBufferPredefinedType(this);
}

void azslParser::StructuredBufferPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructuredBufferPredefinedType(this);
}

azslParser::StructuredBufferPredefinedTypeContext* azslParser::structuredBufferPredefinedType() {
  StructuredBufferPredefinedTypeContext *_localctx = _tracker.createInstance<StructuredBufferPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 152, azslParser::RuleStructuredBufferPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(901);
    structuredBufferName();
    setState(902);
    match(azslParser::Less);
    setState(903);
    type();
    setState(904);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructuredBufferNameContext ------------------------------------------------------------------

azslParser::StructuredBufferNameContext::StructuredBufferNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::AppendStructuredBuffer() {
  return getToken(azslParser::AppendStructuredBuffer, 0);
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::ConsumeStructuredBuffer() {
  return getToken(azslParser::ConsumeStructuredBuffer, 0);
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::RWStructuredBuffer() {
  return getToken(azslParser::RWStructuredBuffer, 0);
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::StructuredBuffer() {
  return getToken(azslParser::StructuredBuffer, 0);
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::RasterizerOrderedStructuredBuffer() {
  return getToken(azslParser::RasterizerOrderedStructuredBuffer, 0);
}


size_t azslParser::StructuredBufferNameContext::getRuleIndex() const {
  return azslParser::RuleStructuredBufferName;
}

void azslParser::StructuredBufferNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructuredBufferName(this);
}

void azslParser::StructuredBufferNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructuredBufferName(this);
}

azslParser::StructuredBufferNameContext* azslParser::structuredBufferName() {
  StructuredBufferNameContext *_localctx = _tracker.createInstance<StructuredBufferNameContext>(_ctx, getState());
  enterRule(_localctx, 154, azslParser::RuleStructuredBufferName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(906);
    _la = _input->LA(1);
    if (!(_la == azslParser::AppendStructuredBuffer

    || _la == azslParser::ConsumeStructuredBuffer || ((((_la - 163) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 163)) & 536879105) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextureTypeContext ------------------------------------------------------------------

azslParser::TextureTypeContext::TextureTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture1D() {
  return getToken(azslParser::Texture1D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture1DArray() {
  return getToken(azslParser::Texture1DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture1D() {
  return getToken(azslParser::RasterizerOrderedTexture1D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture1DArray() {
  return getToken(azslParser::RasterizerOrderedTexture1DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture2D() {
  return getToken(azslParser::Texture2D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture2DArray() {
  return getToken(azslParser::Texture2DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture2D() {
  return getToken(azslParser::RasterizerOrderedTexture2D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture2DArray() {
  return getToken(azslParser::RasterizerOrderedTexture2DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture3D() {
  return getToken(azslParser::Texture3D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture3D() {
  return getToken(azslParser::RasterizerOrderedTexture3D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::TextureCube() {
  return getToken(azslParser::TextureCube, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::TextureCubeArray() {
  return getToken(azslParser::TextureCubeArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture1D() {
  return getToken(azslParser::RWTexture1D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture1DArray() {
  return getToken(azslParser::RWTexture1DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture2D() {
  return getToken(azslParser::RWTexture2D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture2DArray() {
  return getToken(azslParser::RWTexture2DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture3D() {
  return getToken(azslParser::RWTexture3D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::SubpassInput() {
  return getToken(azslParser::SubpassInput, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::SubpassInputMS() {
  return getToken(azslParser::SubpassInputMS, 0);
}


size_t azslParser::TextureTypeContext::getRuleIndex() const {
  return azslParser::RuleTextureType;
}

void azslParser::TextureTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextureType(this);
}

void azslParser::TextureTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextureType(this);
}

azslParser::TextureTypeContext* azslParser::textureType() {
  TextureTypeContext *_localctx = _tracker.createInstance<TextureTypeContext>(_ctx, getState());
  enterRule(_localctx, 156, azslParser::RuleTextureType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(908);
    _la = _input->LA(1);
    if (!(((((_la - 164) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 164)) & 3978750582815) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TexturePredefinedTypeContext ------------------------------------------------------------------

azslParser::TexturePredefinedTypeContext::TexturePredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TextureTypeContext* azslParser::TexturePredefinedTypeContext::textureType() {
  return getRuleContext<azslParser::TextureTypeContext>(0);
}


size_t azslParser::TexturePredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleTexturePredefinedType;
}

void azslParser::TexturePredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTexturePredefinedType(this);
}

void azslParser::TexturePredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTexturePredefinedType(this);
}

azslParser::TexturePredefinedTypeContext* azslParser::texturePredefinedType() {
  TexturePredefinedTypeContext *_localctx = _tracker.createInstance<TexturePredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 158, azslParser::RuleTexturePredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(910);
    textureType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericTexturePredefinedTypeContext ------------------------------------------------------------------

azslParser::GenericTexturePredefinedTypeContext::GenericTexturePredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TextureTypeContext* azslParser::GenericTexturePredefinedTypeContext::textureType() {
  return getRuleContext<azslParser::TextureTypeContext>(0);
}

tree::TerminalNode* azslParser::GenericTexturePredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarOrVectorTypeContext* azslParser::GenericTexturePredefinedTypeContext::scalarOrVectorType() {
  return getRuleContext<azslParser::ScalarOrVectorTypeContext>(0);
}

tree::TerminalNode* azslParser::GenericTexturePredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}


size_t azslParser::GenericTexturePredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleGenericTexturePredefinedType;
}

void azslParser::GenericTexturePredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericTexturePredefinedType(this);
}

void azslParser::GenericTexturePredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericTexturePredefinedType(this);
}

azslParser::GenericTexturePredefinedTypeContext* azslParser::genericTexturePredefinedType() {
  GenericTexturePredefinedTypeContext *_localctx = _tracker.createInstance<GenericTexturePredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 160, azslParser::RuleGenericTexturePredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(912);
    textureType();
    setState(913);
    match(azslParser::Less);
    setState(914);
    scalarOrVectorType();
    setState(915);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextureTypeMSContext ------------------------------------------------------------------

azslParser::TextureTypeMSContext::TextureTypeMSContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TextureTypeMSContext::Texture2DMS() {
  return getToken(azslParser::Texture2DMS, 0);
}

tree::TerminalNode* azslParser::TextureTypeMSContext::Texture2DMSArray() {
  return getToken(azslParser::Texture2DMSArray, 0);
}


size_t azslParser::TextureTypeMSContext::getRuleIndex() const {
  return azslParser::RuleTextureTypeMS;
}

void azslParser::TextureTypeMSContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextureTypeMS(this);
}

void azslParser::TextureTypeMSContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextureTypeMS(this);
}

azslParser::TextureTypeMSContext* azslParser::textureTypeMS() {
  TextureTypeMSContext *_localctx = _tracker.createInstance<TextureTypeMSContext>(_ctx, getState());
  enterRule(_localctx, 162, azslParser::RuleTextureTypeMS);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(917);
    _la = _input->LA(1);
    if (!(_la == azslParser::Texture2DMS

    || _la == azslParser::Texture2DMSArray)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MsTexturePredefinedTypeContext ------------------------------------------------------------------

azslParser::MsTexturePredefinedTypeContext::MsTexturePredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TextureTypeMSContext* azslParser::MsTexturePredefinedTypeContext::textureTypeMS() {
  return getRuleContext<azslParser::TextureTypeMSContext>(0);
}

tree::TerminalNode* azslParser::MsTexturePredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarOrVectorTypeContext* azslParser::MsTexturePredefinedTypeContext::scalarOrVectorType() {
  return getRuleContext<azslParser::ScalarOrVectorTypeContext>(0);
}

tree::TerminalNode* azslParser::MsTexturePredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

tree::TerminalNode* azslParser::MsTexturePredefinedTypeContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

tree::TerminalNode* azslParser::MsTexturePredefinedTypeContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}


size_t azslParser::MsTexturePredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleMsTexturePredefinedType;
}

void azslParser::MsTexturePredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMsTexturePredefinedType(this);
}

void azslParser::MsTexturePredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMsTexturePredefinedType(this);
}

azslParser::MsTexturePredefinedTypeContext* azslParser::msTexturePredefinedType() {
  MsTexturePredefinedTypeContext *_localctx = _tracker.createInstance<MsTexturePredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 164, azslParser::RuleMsTexturePredefinedType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(919);
    textureTypeMS();
    setState(920);
    match(azslParser::Less);
    setState(921);
    scalarOrVectorType();
    setState(924);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Comma) {
      setState(922);
      match(azslParser::Comma);
      setState(923);
      antlrcpp::downCast<MsTexturePredefinedTypeContext *>(_localctx)->Samples = match(azslParser::IntegerLiteral);
    }
    setState(926);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VectorTypeContext ------------------------------------------------------------------

azslParser::VectorTypeContext::VectorTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::VectorTypeContext::Vector() {
  return getToken(azslParser::Vector, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Bool1() {
  return getToken(azslParser::Bool1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Bool2() {
  return getToken(azslParser::Bool2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Bool3() {
  return getToken(azslParser::Bool3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Bool4() {
  return getToken(azslParser::Bool4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Int1() {
  return getToken(azslParser::Int1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Int2() {
  return getToken(azslParser::Int2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Int3() {
  return getToken(azslParser::Int3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Int4() {
  return getToken(azslParser::Int4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Uint1() {
  return getToken(azslParser::Uint1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Uint2() {
  return getToken(azslParser::Uint2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Uint3() {
  return getToken(azslParser::Uint3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Uint4() {
  return getToken(azslParser::Uint4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Dword1() {
  return getToken(azslParser::Dword1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Dword2() {
  return getToken(azslParser::Dword2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Dword3() {
  return getToken(azslParser::Dword3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Dword4() {
  return getToken(azslParser::Dword4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Half1() {
  return getToken(azslParser::Half1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Half2() {
  return getToken(azslParser::Half2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Half3() {
  return getToken(azslParser::Half3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Half4() {
  return getToken(azslParser::Half4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Float1() {
  return getToken(azslParser::Float1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Float2() {
  return getToken(azslParser::Float2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Float3() {
  return getToken(azslParser::Float3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Float4() {
  return getToken(azslParser::Float4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Double1() {
  return getToken(azslParser::Double1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Double2() {
  return getToken(azslParser::Double2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Double3() {
  return getToken(azslParser::Double3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Double4() {
  return getToken(azslParser::Double4, 0);
}


size_t azslParser::VectorTypeContext::getRuleIndex() const {
  return azslParser::RuleVectorType;
}

void azslParser::VectorTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVectorType(this);
}

void azslParser::VectorTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVectorType(this);
}

azslParser::VectorTypeContext* azslParser::vectorType() {
  VectorTypeContext *_localctx = _tracker.createInstance<VectorTypeContext>(_ctx, getState());
  enterRule(_localctx, 166, azslParser::RuleVectorType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(928);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 32985348833400) != 0) || ((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & 540431955787776015) != 0) || ((((_la - 211) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 211)) & 70369750810639) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericVectorTypeContext ------------------------------------------------------------------

azslParser::GenericVectorTypeContext::GenericVectorTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::Vector() {
  return getToken(azslParser::Vector, 0);
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarTypeContext* azslParser::GenericVectorTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}


size_t azslParser::GenericVectorTypeContext::getRuleIndex() const {
  return azslParser::RuleGenericVectorType;
}

void azslParser::GenericVectorTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericVectorType(this);
}

void azslParser::GenericVectorTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericVectorType(this);
}

azslParser::GenericVectorTypeContext* azslParser::genericVectorType() {
  GenericVectorTypeContext *_localctx = _tracker.createInstance<GenericVectorTypeContext>(_ctx, getState());
  enterRule(_localctx, 168, azslParser::RuleGenericVectorType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(930);
    match(azslParser::Vector);
    setState(931);
    match(azslParser::Less);
    setState(932);
    scalarType();
    setState(933);
    match(azslParser::Comma);
    setState(934);
    antlrcpp::downCast<GenericVectorTypeContext *>(_localctx)->Size_ = match(azslParser::IntegerLiteral);
    setState(935);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScalarOrVectorTypeContext ------------------------------------------------------------------

azslParser::ScalarOrVectorTypeContext::ScalarOrVectorTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::ScalarTypeContext* azslParser::ScalarOrVectorTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

azslParser::VectorTypeContext* azslParser::ScalarOrVectorTypeContext::vectorType() {
  return getRuleContext<azslParser::VectorTypeContext>(0);
}


size_t azslParser::ScalarOrVectorTypeContext::getRuleIndex() const {
  return azslParser::RuleScalarOrVectorType;
}

void azslParser::ScalarOrVectorTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalarOrVectorType(this);
}

void azslParser::ScalarOrVectorTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalarOrVectorType(this);
}

azslParser::ScalarOrVectorTypeContext* azslParser::scalarOrVectorType() {
  ScalarOrVectorTypeContext *_localctx = _tracker.createInstance<ScalarOrVectorTypeContext>(_ctx, getState());
  enterRule(_localctx, 170, azslParser::RuleScalarOrVectorType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(939);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Bool:
      case azslParser::Double:
      case azslParser::Float:
      case azslParser::Half:
      case azslParser::Int:
      case azslParser::Int16_t:
      case azslParser::Int32_t:
      case azslParser::Int64_t:
      case azslParser::Uint:
      case azslParser::Uint16_t:
      case azslParser::Uint32_t:
      case azslParser::Uint64_t:
      case azslParser::Dword: {
        enterOuterAlt(_localctx, 1);
        setState(937);
        scalarType();
        break;
      }

      case azslParser::Bool1:
      case azslParser::Bool2:
      case azslParser::Bool3:
      case azslParser::Bool4:
      case azslParser::Double1:
      case azslParser::Double2:
      case azslParser::Double3:
      case azslParser::Double4:
      case azslParser::Float1:
      case azslParser::Float2:
      case azslParser::Float3:
      case azslParser::Float4:
      case azslParser::Half1:
      case azslParser::Half2:
      case azslParser::Half3:
      case azslParser::Half4:
      case azslParser::Int1:
      case azslParser::Int2:
      case azslParser::Int3:
      case azslParser::Int4:
      case azslParser::Uint1:
      case azslParser::Uint2:
      case azslParser::Uint3:
      case azslParser::Uint4:
      case azslParser::Dword1:
      case azslParser::Dword2:
      case azslParser::Dword3:
      case azslParser::Dword4:
      case azslParser::Vector: {
        enterOuterAlt(_localctx, 2);
        setState(938);
        vectorType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScalarOrVectorOrMatrixTypeContext ------------------------------------------------------------------

azslParser::ScalarOrVectorOrMatrixTypeContext::ScalarOrVectorOrMatrixTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::ScalarTypeContext* azslParser::ScalarOrVectorOrMatrixTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

azslParser::VectorTypeContext* azslParser::ScalarOrVectorOrMatrixTypeContext::vectorType() {
  return getRuleContext<azslParser::VectorTypeContext>(0);
}

azslParser::MatrixTypeContext* azslParser::ScalarOrVectorOrMatrixTypeContext::matrixType() {
  return getRuleContext<azslParser::MatrixTypeContext>(0);
}


size_t azslParser::ScalarOrVectorOrMatrixTypeContext::getRuleIndex() const {
  return azslParser::RuleScalarOrVectorOrMatrixType;
}

void azslParser::ScalarOrVectorOrMatrixTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalarOrVectorOrMatrixType(this);
}

void azslParser::ScalarOrVectorOrMatrixTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalarOrVectorOrMatrixType(this);
}

azslParser::ScalarOrVectorOrMatrixTypeContext* azslParser::scalarOrVectorOrMatrixType() {
  ScalarOrVectorOrMatrixTypeContext *_localctx = _tracker.createInstance<ScalarOrVectorOrMatrixTypeContext>(_ctx, getState());
  enterRule(_localctx, 172, azslParser::RuleScalarOrVectorOrMatrixType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(944);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Bool:
      case azslParser::Double:
      case azslParser::Float:
      case azslParser::Half:
      case azslParser::Int:
      case azslParser::Int16_t:
      case azslParser::Int32_t:
      case azslParser::Int64_t:
      case azslParser::Uint:
      case azslParser::Uint16_t:
      case azslParser::Uint32_t:
      case azslParser::Uint64_t:
      case azslParser::Dword: {
        enterOuterAlt(_localctx, 1);
        setState(941);
        scalarType();
        break;
      }

      case azslParser::Bool1:
      case azslParser::Bool2:
      case azslParser::Bool3:
      case azslParser::Bool4:
      case azslParser::Double1:
      case azslParser::Double2:
      case azslParser::Double3:
      case azslParser::Double4:
      case azslParser::Float1:
      case azslParser::Float2:
      case azslParser::Float3:
      case azslParser::Float4:
      case azslParser::Half1:
      case azslParser::Half2:
      case azslParser::Half3:
      case azslParser::Half4:
      case azslParser::Int1:
      case azslParser::Int2:
      case azslParser::Int3:
      case azslParser::Int4:
      case azslParser::Uint1:
      case azslParser::Uint2:
      case azslParser::Uint3:
      case azslParser::Uint4:
      case azslParser::Dword1:
      case azslParser::Dword2:
      case azslParser::Dword3:
      case azslParser::Dword4:
      case azslParser::Vector: {
        enterOuterAlt(_localctx, 2);
        setState(942);
        vectorType();
        break;
      }

      case azslParser::Bool1x1:
      case azslParser::Bool1x2:
      case azslParser::Bool1x3:
      case azslParser::Bool1x4:
      case azslParser::Bool2x1:
      case azslParser::Bool2x2:
      case azslParser::Bool2x3:
      case azslParser::Bool2x4:
      case azslParser::Bool3x1:
      case azslParser::Bool3x2:
      case azslParser::Bool3x3:
      case azslParser::Bool3x4:
      case azslParser::Bool4x1:
      case azslParser::Bool4x2:
      case azslParser::Bool4x3:
      case azslParser::Bool4x4:
      case azslParser::Double1x1:
      case azslParser::Double1x2:
      case azslParser::Double1x3:
      case azslParser::Double1x4:
      case azslParser::Double2x1:
      case azslParser::Double2x2:
      case azslParser::Double2x3:
      case azslParser::Double2x4:
      case azslParser::Double3x1:
      case azslParser::Double3x2:
      case azslParser::Double3x3:
      case azslParser::Double3x4:
      case azslParser::Double4x1:
      case azslParser::Double4x2:
      case azslParser::Double4x3:
      case azslParser::Double4x4:
      case azslParser::Float1x1:
      case azslParser::Float1x2:
      case azslParser::Float1x3:
      case azslParser::Float1x4:
      case azslParser::Float2x1:
      case azslParser::Float2x2:
      case azslParser::Float2x3:
      case azslParser::Float2x4:
      case azslParser::Float3x1:
      case azslParser::Float3x2:
      case azslParser::Float3x3:
      case azslParser::Float3x4:
      case azslParser::Float4x1:
      case azslParser::Float4x2:
      case azslParser::Float4x3:
      case azslParser::Float4x4:
      case azslParser::Half1x1:
      case azslParser::Half1x2:
      case azslParser::Half1x3:
      case azslParser::Half1x4:
      case azslParser::Half2x1:
      case azslParser::Half2x2:
      case azslParser::Half2x3:
      case azslParser::Half2x4:
      case azslParser::Half3x1:
      case azslParser::Half3x2:
      case azslParser::Half3x3:
      case azslParser::Half3x4:
      case azslParser::Half4x1:
      case azslParser::Half4x2:
      case azslParser::Half4x3:
      case azslParser::Half4x4:
      case azslParser::Int1x1:
      case azslParser::Int1x2:
      case azslParser::Int1x3:
      case azslParser::Int1x4:
      case azslParser::Int2x1:
      case azslParser::Int2x2:
      case azslParser::Int2x3:
      case azslParser::Int2x4:
      case azslParser::Int3x1:
      case azslParser::Int3x2:
      case azslParser::Int3x3:
      case azslParser::Int3x4:
      case azslParser::Int4x1:
      case azslParser::Int4x2:
      case azslParser::Int4x3:
      case azslParser::Int4x4:
      case azslParser::Matrix:
      case azslParser::Uint1x1:
      case azslParser::Uint1x2:
      case azslParser::Uint1x3:
      case azslParser::Uint1x4:
      case azslParser::Uint2x1:
      case azslParser::Uint2x2:
      case azslParser::Uint2x3:
      case azslParser::Uint2x4:
      case azslParser::Uint3x1:
      case azslParser::Uint3x2:
      case azslParser::Uint3x3:
      case azslParser::Uint3x4:
      case azslParser::Uint4x1:
      case azslParser::Uint4x2:
      case azslParser::Uint4x3:
      case azslParser::Uint4x4:
      case azslParser::Dword1x1:
      case azslParser::Dword1x2:
      case azslParser::Dword1x3:
      case azslParser::Dword1x4:
      case azslParser::Dword2x1:
      case azslParser::Dword2x2:
      case azslParser::Dword2x3:
      case azslParser::Dword2x4:
      case azslParser::Dword3x1:
      case azslParser::Dword3x2:
      case azslParser::Dword3x3:
      case azslParser::Dword3x4:
      case azslParser::Dword4x1:
      case azslParser::Dword4x2:
      case azslParser::Dword4x3:
      case azslParser::Dword4x4: {
        enterOuterAlt(_localctx, 3);
        setState(943);
        matrixType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatrixTypeContext ------------------------------------------------------------------

azslParser::MatrixTypeContext::MatrixTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MatrixTypeContext::Matrix() {
  return getToken(azslParser::Matrix, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool1x1() {
  return getToken(azslParser::Bool1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool1x2() {
  return getToken(azslParser::Bool1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool1x3() {
  return getToken(azslParser::Bool1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool1x4() {
  return getToken(azslParser::Bool1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool2x1() {
  return getToken(azslParser::Bool2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool2x2() {
  return getToken(azslParser::Bool2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool2x3() {
  return getToken(azslParser::Bool2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool2x4() {
  return getToken(azslParser::Bool2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool3x1() {
  return getToken(azslParser::Bool3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool3x2() {
  return getToken(azslParser::Bool3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool3x3() {
  return getToken(azslParser::Bool3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool3x4() {
  return getToken(azslParser::Bool3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool4x1() {
  return getToken(azslParser::Bool4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool4x2() {
  return getToken(azslParser::Bool4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool4x3() {
  return getToken(azslParser::Bool4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool4x4() {
  return getToken(azslParser::Bool4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int1x1() {
  return getToken(azslParser::Int1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int1x2() {
  return getToken(azslParser::Int1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int1x3() {
  return getToken(azslParser::Int1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int1x4() {
  return getToken(azslParser::Int1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int2x1() {
  return getToken(azslParser::Int2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int2x2() {
  return getToken(azslParser::Int2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int2x3() {
  return getToken(azslParser::Int2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int2x4() {
  return getToken(azslParser::Int2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int3x1() {
  return getToken(azslParser::Int3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int3x2() {
  return getToken(azslParser::Int3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int3x3() {
  return getToken(azslParser::Int3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int3x4() {
  return getToken(azslParser::Int3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int4x1() {
  return getToken(azslParser::Int4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int4x2() {
  return getToken(azslParser::Int4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int4x3() {
  return getToken(azslParser::Int4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int4x4() {
  return getToken(azslParser::Int4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint1x1() {
  return getToken(azslParser::Uint1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint1x2() {
  return getToken(azslParser::Uint1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint1x3() {
  return getToken(azslParser::Uint1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint1x4() {
  return getToken(azslParser::Uint1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint2x1() {
  return getToken(azslParser::Uint2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint2x2() {
  return getToken(azslParser::Uint2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint2x3() {
  return getToken(azslParser::Uint2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint2x4() {
  return getToken(azslParser::Uint2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint3x1() {
  return getToken(azslParser::Uint3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint3x2() {
  return getToken(azslParser::Uint3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint3x3() {
  return getToken(azslParser::Uint3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint3x4() {
  return getToken(azslParser::Uint3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint4x1() {
  return getToken(azslParser::Uint4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint4x2() {
  return getToken(azslParser::Uint4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint4x3() {
  return getToken(azslParser::Uint4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint4x4() {
  return getToken(azslParser::Uint4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword1x1() {
  return getToken(azslParser::Dword1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword1x2() {
  return getToken(azslParser::Dword1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword1x3() {
  return getToken(azslParser::Dword1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword1x4() {
  return getToken(azslParser::Dword1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword2x1() {
  return getToken(azslParser::Dword2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword2x2() {
  return getToken(azslParser::Dword2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword2x3() {
  return getToken(azslParser::Dword2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword2x4() {
  return getToken(azslParser::Dword2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword3x1() {
  return getToken(azslParser::Dword3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword3x2() {
  return getToken(azslParser::Dword3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword3x3() {
  return getToken(azslParser::Dword3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword3x4() {
  return getToken(azslParser::Dword3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword4x1() {
  return getToken(azslParser::Dword4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword4x2() {
  return getToken(azslParser::Dword4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword4x3() {
  return getToken(azslParser::Dword4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword4x4() {
  return getToken(azslParser::Dword4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half1x1() {
  return getToken(azslParser::Half1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half1x2() {
  return getToken(azslParser::Half1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half1x3() {
  return getToken(azslParser::Half1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half1x4() {
  return getToken(azslParser::Half1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half2x1() {
  return getToken(azslParser::Half2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half2x2() {
  return getToken(azslParser::Half2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half2x3() {
  return getToken(azslParser::Half2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half2x4() {
  return getToken(azslParser::Half2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half3x1() {
  return getToken(azslParser::Half3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half3x2() {
  return getToken(azslParser::Half3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half3x3() {
  return getToken(azslParser::Half3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half3x4() {
  return getToken(azslParser::Half3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half4x1() {
  return getToken(azslParser::Half4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half4x2() {
  return getToken(azslParser::Half4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half4x3() {
  return getToken(azslParser::Half4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half4x4() {
  return getToken(azslParser::Half4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float1x1() {
  return getToken(azslParser::Float1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float1x2() {
  return getToken(azslParser::Float1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float1x3() {
  return getToken(azslParser::Float1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float1x4() {
  return getToken(azslParser::Float1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float2x1() {
  return getToken(azslParser::Float2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float2x2() {
  return getToken(azslParser::Float2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float2x3() {
  return getToken(azslParser::Float2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float2x4() {
  return getToken(azslParser::Float2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float3x1() {
  return getToken(azslParser::Float3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float3x2() {
  return getToken(azslParser::Float3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float3x3() {
  return getToken(azslParser::Float3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float3x4() {
  return getToken(azslParser::Float3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float4x1() {
  return getToken(azslParser::Float4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float4x2() {
  return getToken(azslParser::Float4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float4x3() {
  return getToken(azslParser::Float4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float4x4() {
  return getToken(azslParser::Float4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double1x1() {
  return getToken(azslParser::Double1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double1x2() {
  return getToken(azslParser::Double1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double1x3() {
  return getToken(azslParser::Double1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double1x4() {
  return getToken(azslParser::Double1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double2x1() {
  return getToken(azslParser::Double2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double2x2() {
  return getToken(azslParser::Double2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double2x3() {
  return getToken(azslParser::Double2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double2x4() {
  return getToken(azslParser::Double2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double3x1() {
  return getToken(azslParser::Double3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double3x2() {
  return getToken(azslParser::Double3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double3x3() {
  return getToken(azslParser::Double3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double3x4() {
  return getToken(azslParser::Double3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double4x1() {
  return getToken(azslParser::Double4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double4x2() {
  return getToken(azslParser::Double4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double4x3() {
  return getToken(azslParser::Double4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double4x4() {
  return getToken(azslParser::Double4x4, 0);
}


size_t azslParser::MatrixTypeContext::getRuleIndex() const {
  return azslParser::RuleMatrixType;
}

void azslParser::MatrixTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatrixType(this);
}

void azslParser::MatrixTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatrixType(this);
}

azslParser::MatrixTypeContext* azslParser::matrixType() {
  MatrixTypeContext *_localctx = _tracker.createInstance<MatrixTypeContext>(_ctx, getState());
  enterRule(_localctx, 174, azslParser::RuleMatrixType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(946);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2305807824849993600) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & -36026598029197313) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & 8319) != 0) || ((((_la - 215) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 215)) & 4397979467775) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericMatrixPredefinedTypeContext ------------------------------------------------------------------

azslParser::GenericMatrixPredefinedTypeContext::GenericMatrixPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::Matrix() {
  return getToken(azslParser::Matrix, 0);
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarTypeContext* azslParser::GenericMatrixPredefinedTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

std::vector<tree::TerminalNode *> azslParser::GenericMatrixPredefinedTypeContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

std::vector<tree::TerminalNode *> azslParser::GenericMatrixPredefinedTypeContext::IntegerLiteral() {
  return getTokens(azslParser::IntegerLiteral);
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::IntegerLiteral(size_t i) {
  return getToken(azslParser::IntegerLiteral, i);
}


size_t azslParser::GenericMatrixPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleGenericMatrixPredefinedType;
}

void azslParser::GenericMatrixPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericMatrixPredefinedType(this);
}

void azslParser::GenericMatrixPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericMatrixPredefinedType(this);
}

azslParser::GenericMatrixPredefinedTypeContext* azslParser::genericMatrixPredefinedType() {
  GenericMatrixPredefinedTypeContext *_localctx = _tracker.createInstance<GenericMatrixPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 176, azslParser::RuleGenericMatrixPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(948);
    match(azslParser::Matrix);
    setState(949);
    match(azslParser::Less);
    setState(950);
    scalarType();
    setState(951);
    match(azslParser::Comma);
    setState(952);
    antlrcpp::downCast<GenericMatrixPredefinedTypeContext *>(_localctx)->Rows_ = match(azslParser::IntegerLiteral);
    setState(953);
    match(azslParser::Comma);
    setState(954);
    antlrcpp::downCast<GenericMatrixPredefinedTypeContext *>(_localctx)->Cols_ = match(azslParser::IntegerLiteral);
    setState(955);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RegisterAllocationContext ------------------------------------------------------------------

azslParser::RegisterAllocationContext::RegisterAllocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::RegisterAllocationContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

tree::TerminalNode* azslParser::RegisterAllocationContext::Register() {
  return getToken(azslParser::Register, 0);
}

tree::TerminalNode* azslParser::RegisterAllocationContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::RegisterAllocationContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::RegisterAllocationContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::RegisterAllocationContext::getRuleIndex() const {
  return azslParser::RuleRegisterAllocation;
}

void azslParser::RegisterAllocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRegisterAllocation(this);
}

void azslParser::RegisterAllocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRegisterAllocation(this);
}

azslParser::RegisterAllocationContext* azslParser::registerAllocation() {
  RegisterAllocationContext *_localctx = _tracker.createInstance<RegisterAllocationContext>(_ctx, getState());
  enterRule(_localctx, 178, azslParser::RuleRegisterAllocation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(957);
    match(azslParser::Colon);
    setState(958);
    match(azslParser::Register);
    setState(959);
    match(azslParser::LeftParen);
    setState(960);
    antlrcpp::downCast<RegisterAllocationContext *>(_localctx)->Address = match(azslParser::Identifier);
    setState(961);
    match(azslParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SamplerStatePropertyContext ------------------------------------------------------------------

azslParser::SamplerStatePropertyContext::SamplerStatePropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SamplerStatePropertyContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::SamplerStatePropertyContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

tree::TerminalNode* azslParser::SamplerStatePropertyContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::ExpressionContext* azslParser::SamplerStatePropertyContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}


size_t azslParser::SamplerStatePropertyContext::getRuleIndex() const {
  return azslParser::RuleSamplerStateProperty;
}

void azslParser::SamplerStatePropertyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSamplerStateProperty(this);
}

void azslParser::SamplerStatePropertyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSamplerStateProperty(this);
}

azslParser::SamplerStatePropertyContext* azslParser::samplerStateProperty() {
  SamplerStatePropertyContext *_localctx = _tracker.createInstance<SamplerStatePropertyContext>(_ctx, getState());
  enterRule(_localctx, 180, azslParser::RuleSamplerStateProperty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(963);
    antlrcpp::downCast<SamplerStatePropertyContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(964);
    antlrcpp::downCast<SamplerStatePropertyContext *>(_localctx)->EqualsToken = match(azslParser::Assign);
    setState(965);
    antlrcpp::downCast<SamplerStatePropertyContext *>(_localctx)->Expr = expression(0);
    setState(966);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

azslParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::LiteralContext::True() {
  return getToken(azslParser::True, 0);
}

tree::TerminalNode* azslParser::LiteralContext::False() {
  return getToken(azslParser::False, 0);
}

tree::TerminalNode* azslParser::LiteralContext::FloatLiteral() {
  return getToken(azslParser::FloatLiteral, 0);
}

tree::TerminalNode* azslParser::LiteralContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}

std::vector<tree::TerminalNode *> azslParser::LiteralContext::StringLiteral() {
  return getTokens(azslParser::StringLiteral);
}

tree::TerminalNode* azslParser::LiteralContext::StringLiteral(size_t i) {
  return getToken(azslParser::StringLiteral, i);
}


size_t azslParser::LiteralContext::getRuleIndex() const {
  return azslParser::RuleLiteral;
}

void azslParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void azslParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

azslParser::LiteralContext* azslParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 182, azslParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(977);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::True: {
        enterOuterAlt(_localctx, 1);
        setState(968);
        match(azslParser::True);
        break;
      }

      case azslParser::False: {
        enterOuterAlt(_localctx, 2);
        setState(969);
        match(azslParser::False);
        break;
      }

      case azslParser::FloatLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(970);
        match(azslParser::FloatLiteral);
        break;
      }

      case azslParser::IntegerLiteral: {
        enterOuterAlt(_localctx, 4);
        setState(971);
        match(azslParser::IntegerLiteral);
        break;
      }

      case azslParser::StringLiteral: {
        enterOuterAlt(_localctx, 5);
        setState(973); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(972);
                  match(azslParser::StringLiteral);
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(975); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeadingTypeFunctionSignatureContext ------------------------------------------------------------------

azslParser::LeadingTypeFunctionSignatureContext::LeadingTypeFunctionSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TypeContext* azslParser::LeadingTypeFunctionSignatureContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::ColonColon() {
  return getToken(azslParser::ColonColon, 0);
}

azslParser::GenericParameterListContext* azslParser::LeadingTypeFunctionSignatureContext::genericParameterList() {
  return getRuleContext<azslParser::GenericParameterListContext>(0);
}

azslParser::FunctionParamsContext* azslParser::LeadingTypeFunctionSignatureContext::functionParams() {
  return getRuleContext<azslParser::FunctionParamsContext>(0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::Override() {
  return getToken(azslParser::Override, 0);
}

azslParser::HlslSemanticContext* azslParser::LeadingTypeFunctionSignatureContext::hlslSemantic() {
  return getRuleContext<azslParser::HlslSemanticContext>(0);
}

azslParser::UserDefinedTypeContext* azslParser::LeadingTypeFunctionSignatureContext::userDefinedType() {
  return getRuleContext<azslParser::UserDefinedTypeContext>(0);
}


size_t azslParser::LeadingTypeFunctionSignatureContext::getRuleIndex() const {
  return azslParser::RuleLeadingTypeFunctionSignature;
}

void azslParser::LeadingTypeFunctionSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeadingTypeFunctionSignature(this);
}

void azslParser::LeadingTypeFunctionSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeadingTypeFunctionSignature(this);
}

azslParser::LeadingTypeFunctionSignatureContext* azslParser::leadingTypeFunctionSignature() {
  LeadingTypeFunctionSignatureContext *_localctx = _tracker.createInstance<LeadingTypeFunctionSignatureContext>(_ctx, getState());
  enterRule(_localctx, 184, azslParser::RuleLeadingTypeFunctionSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(979);
    type();
    setState(983);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      setState(980);
      antlrcpp::downCast<LeadingTypeFunctionSignatureContext *>(_localctx)->ClassName = userDefinedType();
      setState(981);
      match(azslParser::ColonColon);
      break;
    }

    default:
      break;
    }
    setState(985);
    antlrcpp::downCast<LeadingTypeFunctionSignatureContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(987);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Less) {
      setState(986);
      genericParameterList();
    }
    setState(989);
    match(azslParser::LeftParen);
    setState(991);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -25) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 38280596832665583) != 0) || ((((_la - 334) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 334)) & 34368126977) != 0)) {
      setState(990);
      functionParams();
    }
    setState(993);
    match(azslParser::RightParen);
    setState(995);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Override) {
      setState(994);
      match(azslParser::Override);
    }
    setState(998);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(997);
      hlslSemantic();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HlslFunctionDefinitionContext ------------------------------------------------------------------

azslParser::HlslFunctionDefinitionContext::HlslFunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::LeadingTypeFunctionSignatureContext* azslParser::HlslFunctionDefinitionContext::leadingTypeFunctionSignature() {
  return getRuleContext<azslParser::LeadingTypeFunctionSignatureContext>(0);
}

azslParser::BlockContext* azslParser::HlslFunctionDefinitionContext::block() {
  return getRuleContext<azslParser::BlockContext>(0);
}


size_t azslParser::HlslFunctionDefinitionContext::getRuleIndex() const {
  return azslParser::RuleHlslFunctionDefinition;
}

void azslParser::HlslFunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHlslFunctionDefinition(this);
}

void azslParser::HlslFunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHlslFunctionDefinition(this);
}

azslParser::HlslFunctionDefinitionContext* azslParser::hlslFunctionDefinition() {
  HlslFunctionDefinitionContext *_localctx = _tracker.createInstance<HlslFunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 186, azslParser::RuleHlslFunctionDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1000);
    leadingTypeFunctionSignature();
    setState(1001);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HlslFunctionDeclarationContext ------------------------------------------------------------------

azslParser::HlslFunctionDeclarationContext::HlslFunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::LeadingTypeFunctionSignatureContext* azslParser::HlslFunctionDeclarationContext::leadingTypeFunctionSignature() {
  return getRuleContext<azslParser::LeadingTypeFunctionSignatureContext>(0);
}

tree::TerminalNode* azslParser::HlslFunctionDeclarationContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::HlslFunctionDeclarationContext::getRuleIndex() const {
  return azslParser::RuleHlslFunctionDeclaration;
}

void azslParser::HlslFunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHlslFunctionDeclaration(this);
}

void azslParser::HlslFunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHlslFunctionDeclaration(this);
}

azslParser::HlslFunctionDeclarationContext* azslParser::hlslFunctionDeclaration() {
  HlslFunctionDeclarationContext *_localctx = _tracker.createInstance<HlslFunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 188, azslParser::RuleHlslFunctionDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1003);
    leadingTypeFunctionSignature();
    setState(1004);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserDefinedTypeContext ------------------------------------------------------------------

azslParser::UserDefinedTypeContext::UserDefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::IdExpressionContext* azslParser::UserDefinedTypeContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}

azslParser::AnyStructuredTypeDefinitionContext* azslParser::UserDefinedTypeContext::anyStructuredTypeDefinition() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionContext>(0);
}


size_t azslParser::UserDefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleUserDefinedType;
}

void azslParser::UserDefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserDefinedType(this);
}

void azslParser::UserDefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserDefinedType(this);
}

azslParser::UserDefinedTypeContext* azslParser::userDefinedType() {
  UserDefinedTypeContext *_localctx = _tracker.createInstance<UserDefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 190, azslParser::RuleUserDefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1008);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::ColonColon:
      case azslParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1006);
        idExpression();
        break;
      }

      case azslParser::Class:
      case azslParser::Enum:
      case azslParser::Interface:
      case azslParser::Struct: {
        enterOuterAlt(_localctx, 2);
        setState(1007);
        anyStructuredTypeDefinition();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssociatedTypeDeclarationContext ------------------------------------------------------------------

azslParser::AssociatedTypeDeclarationContext::AssociatedTypeDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AssociatedTypeDeclarationContext::KW_AssociatedType() {
  return getToken(azslParser::KW_AssociatedType, 0);
}

tree::TerminalNode* azslParser::AssociatedTypeDeclarationContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::AssociatedTypeDeclarationContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

azslParser::GenericConstraintContext* azslParser::AssociatedTypeDeclarationContext::genericConstraint() {
  return getRuleContext<azslParser::GenericConstraintContext>(0);
}


size_t azslParser::AssociatedTypeDeclarationContext::getRuleIndex() const {
  return azslParser::RuleAssociatedTypeDeclaration;
}

void azslParser::AssociatedTypeDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssociatedTypeDeclaration(this);
}

void azslParser::AssociatedTypeDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssociatedTypeDeclaration(this);
}

azslParser::AssociatedTypeDeclarationContext* azslParser::associatedTypeDeclaration() {
  AssociatedTypeDeclarationContext *_localctx = _tracker.createInstance<AssociatedTypeDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 192, azslParser::RuleAssociatedTypeDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1010);
    match(azslParser::KW_AssociatedType);
    setState(1011);
    antlrcpp::downCast<AssociatedTypeDeclarationContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(1013);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(1012);
      genericConstraint();
    }
    setState(1015);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedefStatementContext ------------------------------------------------------------------

azslParser::TypedefStatementContext::TypedefStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TypedefStatementContext::KW_Typedef() {
  return getToken(azslParser::KW_Typedef, 0);
}

tree::TerminalNode* azslParser::TypedefStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::TypeContext* azslParser::TypedefStatementContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::TypedefStatementContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::TypedefStatementContext::getRuleIndex() const {
  return azslParser::RuleTypedefStatement;
}

void azslParser::TypedefStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedefStatement(this);
}

void azslParser::TypedefStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedefStatement(this);
}

azslParser::TypedefStatementContext* azslParser::typedefStatement() {
  TypedefStatementContext *_localctx = _tracker.createInstance<TypedefStatementContext>(_ctx, getState());
  enterRule(_localctx, 194, azslParser::RuleTypedefStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1017);
    match(azslParser::KW_Typedef);
    setState(1018);
    antlrcpp::downCast<TypedefStatementContext *>(_localctx)->ExistingType = type();
    setState(1019);
    antlrcpp::downCast<TypedefStatementContext *>(_localctx)->NewTypeName = match(azslParser::Identifier);
    setState(1020);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypealiasStatementContext ------------------------------------------------------------------

azslParser::TypealiasStatementContext::TypealiasStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TypealiasStatementContext::KW_TypeAlias() {
  return getToken(azslParser::KW_TypeAlias, 0);
}

tree::TerminalNode* azslParser::TypealiasStatementContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::TypealiasStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::TypealiasStatementContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

azslParser::TypeContext* azslParser::TypealiasStatementContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}


size_t azslParser::TypealiasStatementContext::getRuleIndex() const {
  return azslParser::RuleTypealiasStatement;
}

void azslParser::TypealiasStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypealiasStatement(this);
}

void azslParser::TypealiasStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypealiasStatement(this);
}

azslParser::TypealiasStatementContext* azslParser::typealiasStatement() {
  TypealiasStatementContext *_localctx = _tracker.createInstance<TypealiasStatementContext>(_ctx, getState());
  enterRule(_localctx, 196, azslParser::RuleTypealiasStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1022);
    match(azslParser::KW_TypeAlias);
    setState(1023);
    antlrcpp::downCast<TypealiasStatementContext *>(_localctx)->NewTypeName = match(azslParser::Identifier);
    setState(1024);
    match(azslParser::Assign);
    setState(1025);
    antlrcpp::downCast<TypealiasStatementContext *>(_localctx)->ExistingType = type();
    setState(1026);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAliasingDefinitionStatementContext ------------------------------------------------------------------

azslParser::TypeAliasingDefinitionStatementContext::TypeAliasingDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TypealiasStatementContext* azslParser::TypeAliasingDefinitionStatementContext::typealiasStatement() {
  return getRuleContext<azslParser::TypealiasStatementContext>(0);
}

azslParser::TypedefStatementContext* azslParser::TypeAliasingDefinitionStatementContext::typedefStatement() {
  return getRuleContext<azslParser::TypedefStatementContext>(0);
}


size_t azslParser::TypeAliasingDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleTypeAliasingDefinitionStatement;
}

void azslParser::TypeAliasingDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAliasingDefinitionStatement(this);
}

void azslParser::TypeAliasingDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAliasingDefinitionStatement(this);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::typeAliasingDefinitionStatement() {
  TypeAliasingDefinitionStatementContext *_localctx = _tracker.createInstance<TypeAliasingDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 198, azslParser::RuleTypeAliasingDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1030);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::KW_TypeAlias: {
        enterOuterAlt(_localctx, 1);
        setState(1028);
        typealiasStatement();
        break;
      }

      case azslParser::KW_Typedef: {
        enterOuterAlt(_localctx, 2);
        setState(1029);
        typedefStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeofExpressionContext ------------------------------------------------------------------

azslParser::TypeofExpressionContext::TypeofExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TypeofExpressionContext::KW_Typeof() {
  return getToken(azslParser::KW_Typeof, 0);
}

tree::TerminalNode* azslParser::TypeofExpressionContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::TypeofExpressionContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::TypeContext* azslParser::TypeofExpressionContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

azslParser::ExpressionExtContext* azslParser::TypeofExpressionContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

tree::TerminalNode* azslParser::TypeofExpressionContext::ColonColon() {
  return getToken(azslParser::ColonColon, 0);
}

azslParser::IdExpressionContext* azslParser::TypeofExpressionContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}


size_t azslParser::TypeofExpressionContext::getRuleIndex() const {
  return azslParser::RuleTypeofExpression;
}

void azslParser::TypeofExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeofExpression(this);
}

void azslParser::TypeofExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeofExpression(this);
}

azslParser::TypeofExpressionContext* azslParser::typeofExpression() {
  TypeofExpressionContext *_localctx = _tracker.createInstance<TypeofExpressionContext>(_ctx, getState());
  enterRule(_localctx, 200, azslParser::RuleTypeofExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1032);
    match(azslParser::KW_Typeof);
    setState(1033);
    match(azslParser::LeftParen);
    setState(1036);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(1034);
      antlrcpp::downCast<TypeofExpressionContext *>(_localctx)->Expr = expressionExt(0);
      break;
    }

    case 2: {
      setState(1035);
      type();
      break;
    }

    default:
      break;
    }
    setState(1038);
    match(azslParser::RightParen);
    setState(1041);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(1039);
      match(azslParser::ColonColon);
      setState(1040);
      antlrcpp::downCast<TypeofExpressionContext *>(_localctx)->SubQualification = idExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericParameterListContext ------------------------------------------------------------------

azslParser::GenericParameterListContext::GenericParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericParameterListContext::Less() {
  return getToken(azslParser::Less, 0);
}

std::vector<azslParser::GenericTypeDefinitionContext *> azslParser::GenericParameterListContext::genericTypeDefinition() {
  return getRuleContexts<azslParser::GenericTypeDefinitionContext>();
}

azslParser::GenericTypeDefinitionContext* azslParser::GenericParameterListContext::genericTypeDefinition(size_t i) {
  return getRuleContext<azslParser::GenericTypeDefinitionContext>(i);
}

tree::TerminalNode* azslParser::GenericParameterListContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

std::vector<tree::TerminalNode *> azslParser::GenericParameterListContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::GenericParameterListContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::GenericParameterListContext::getRuleIndex() const {
  return azslParser::RuleGenericParameterList;
}

void azslParser::GenericParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericParameterList(this);
}

void azslParser::GenericParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericParameterList(this);
}

azslParser::GenericParameterListContext* azslParser::genericParameterList() {
  GenericParameterListContext *_localctx = _tracker.createInstance<GenericParameterListContext>(_ctx, getState());
  enterRule(_localctx, 202, azslParser::RuleGenericParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1043);
    match(azslParser::Less);
    setState(1044);
    genericTypeDefinition();
    setState(1049);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(1045);
      match(azslParser::Comma);
      setState(1046);
      genericTypeDefinition();
      setState(1051);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1052);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericTypeDefinitionContext ------------------------------------------------------------------

azslParser::GenericTypeDefinitionContext::GenericTypeDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericTypeDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

azslParser::GenericConstraintContext* azslParser::GenericTypeDefinitionContext::genericConstraint() {
  return getRuleContext<azslParser::GenericConstraintContext>(0);
}


size_t azslParser::GenericTypeDefinitionContext::getRuleIndex() const {
  return azslParser::RuleGenericTypeDefinition;
}

void azslParser::GenericTypeDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericTypeDefinition(this);
}

void azslParser::GenericTypeDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericTypeDefinition(this);
}

azslParser::GenericTypeDefinitionContext* azslParser::genericTypeDefinition() {
  GenericTypeDefinitionContext *_localctx = _tracker.createInstance<GenericTypeDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 204, azslParser::RuleGenericTypeDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1054);
    antlrcpp::downCast<GenericTypeDefinitionContext *>(_localctx)->GenericTypeName = match(azslParser::Identifier);
    setState(1056);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(1055);
      genericConstraint();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericConstraintContext ------------------------------------------------------------------

azslParser::GenericConstraintContext::GenericConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericConstraintContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::UserDefinedTypeContext* azslParser::GenericConstraintContext::userDefinedType() {
  return getRuleContext<azslParser::UserDefinedTypeContext>(0);
}


size_t azslParser::GenericConstraintContext::getRuleIndex() const {
  return azslParser::RuleGenericConstraint;
}

void azslParser::GenericConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericConstraint(this);
}

void azslParser::GenericConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericConstraint(this);
}

azslParser::GenericConstraintContext* azslParser::genericConstraint() {
  GenericConstraintContext *_localctx = _tracker.createInstance<GenericConstraintContext>(_ctx, getState());
  enterRule(_localctx, 206, azslParser::RuleGenericConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1058);
    match(azslParser::Colon);
    setState(1059);
    userDefinedType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LanguageDefinedConstraintContext ------------------------------------------------------------------

azslParser::LanguageDefinedConstraintContext::LanguageDefinedConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::LanguageDefinedConstraintContext::KW_Fundamental() {
  return getToken(azslParser::KW_Fundamental, 0);
}


size_t azslParser::LanguageDefinedConstraintContext::getRuleIndex() const {
  return azslParser::RuleLanguageDefinedConstraint;
}

void azslParser::LanguageDefinedConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLanguageDefinedConstraint(this);
}

void azslParser::LanguageDefinedConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLanguageDefinedConstraint(this);
}

azslParser::LanguageDefinedConstraintContext* azslParser::languageDefinedConstraint() {
  LanguageDefinedConstraintContext *_localctx = _tracker.createInstance<LanguageDefinedConstraintContext>(_ctx, getState());
  enterRule(_localctx, 208, azslParser::RuleLanguageDefinedConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1061);
    match(azslParser::KW_Fundamental);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

azslParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::HlslFunctionDeclarationContext* azslParser::FunctionDeclarationContext::hlslFunctionDeclaration() {
  return getRuleContext<azslParser::HlslFunctionDeclarationContext>(0);
}


size_t azslParser::FunctionDeclarationContext::getRuleIndex() const {
  return azslParser::RuleFunctionDeclaration;
}

void azslParser::FunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDeclaration(this);
}

void azslParser::FunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDeclaration(this);
}

azslParser::FunctionDeclarationContext* azslParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 210, azslParser::RuleFunctionDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1063);
    hlslFunctionDeclaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributedFunctionDeclarationContext ------------------------------------------------------------------

azslParser::AttributedFunctionDeclarationContext::AttributedFunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::FunctionDeclarationContext* azslParser::AttributedFunctionDeclarationContext::functionDeclaration() {
  return getRuleContext<azslParser::FunctionDeclarationContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AttributedFunctionDeclarationContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AttributedFunctionDeclarationContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AttributedFunctionDeclarationContext::getRuleIndex() const {
  return azslParser::RuleAttributedFunctionDeclaration;
}

void azslParser::AttributedFunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributedFunctionDeclaration(this);
}

void azslParser::AttributedFunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributedFunctionDeclaration(this);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::attributedFunctionDeclaration() {
  AttributedFunctionDeclarationContext *_localctx = _tracker.createInstance<AttributedFunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 212, azslParser::RuleAttributedFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1068);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(1065);
      attributeSpecifierAny();
      setState(1070);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1071);
    functionDeclaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDefinitionContext ------------------------------------------------------------------

azslParser::FunctionDefinitionContext::FunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::HlslFunctionDefinitionContext* azslParser::FunctionDefinitionContext::hlslFunctionDefinition() {
  return getRuleContext<azslParser::HlslFunctionDefinitionContext>(0);
}


size_t azslParser::FunctionDefinitionContext::getRuleIndex() const {
  return azslParser::RuleFunctionDefinition;
}

void azslParser::FunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDefinition(this);
}

void azslParser::FunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDefinition(this);
}

azslParser::FunctionDefinitionContext* azslParser::functionDefinition() {
  FunctionDefinitionContext *_localctx = _tracker.createInstance<FunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 214, azslParser::RuleFunctionDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1073);
    hlslFunctionDefinition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributedFunctionDefinitionContext ------------------------------------------------------------------

azslParser::AttributedFunctionDefinitionContext::AttributedFunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::FunctionDefinitionContext* azslParser::AttributedFunctionDefinitionContext::functionDefinition() {
  return getRuleContext<azslParser::FunctionDefinitionContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AttributedFunctionDefinitionContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AttributedFunctionDefinitionContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AttributedFunctionDefinitionContext::getRuleIndex() const {
  return azslParser::RuleAttributedFunctionDefinition;
}

void azslParser::AttributedFunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributedFunctionDefinition(this);
}

void azslParser::AttributedFunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributedFunctionDefinition(this);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::attributedFunctionDefinition() {
  AttributedFunctionDefinitionContext *_localctx = _tracker.createInstance<AttributedFunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 216, azslParser::RuleAttributedFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1078);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(1075);
      attributeSpecifierAny();
      setState(1080);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1081);
    functionDefinition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompilerExtensionStatementContext ------------------------------------------------------------------

azslParser::CompilerExtensionStatementContext::CompilerExtensionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_print_message() {
  return getToken(azslParser::KW_ext_print_message, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::StringLiteral() {
  return getToken(azslParser::StringLiteral, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_print_symbol() {
  return getToken(azslParser::KW_ext_print_symbol, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_prtsym_fully_qualified() {
  return getToken(azslParser::KW_ext_prtsym_fully_qualified, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_prtsym_least_qualified() {
  return getToken(azslParser::KW_ext_prtsym_least_qualified, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_prtsym_constint_value() {
  return getToken(azslParser::KW_ext_prtsym_constint_value, 0);
}

azslParser::IdExpressionContext* azslParser::CompilerExtensionStatementContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}

azslParser::TypeofExpressionContext* azslParser::CompilerExtensionStatementContext::typeofExpression() {
  return getRuleContext<azslParser::TypeofExpressionContext>(0);
}


size_t azslParser::CompilerExtensionStatementContext::getRuleIndex() const {
  return azslParser::RuleCompilerExtensionStatement;
}

void azslParser::CompilerExtensionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompilerExtensionStatement(this);
}

void azslParser::CompilerExtensionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompilerExtensionStatement(this);
}

azslParser::CompilerExtensionStatementContext* azslParser::compilerExtensionStatement() {
  CompilerExtensionStatementContext *_localctx = _tracker.createInstance<CompilerExtensionStatementContext>(_ctx, getState());
  enterRule(_localctx, 218, azslParser::RuleCompilerExtensionStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1099);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::KW_ext_print_message: {
        enterOuterAlt(_localctx, 1);
        setState(1083);
        match(azslParser::KW_ext_print_message);
        setState(1084);
        match(azslParser::LeftParen);
        setState(1085);
        antlrcpp::downCast<CompilerExtensionStatementContext *>(_localctx)->Message = match(azslParser::StringLiteral);
        setState(1086);
        match(azslParser::RightParen);
        setState(1087);
        match(azslParser::Semi);
        break;
      }

      case azslParser::KW_ext_print_symbol: {
        enterOuterAlt(_localctx, 2);
        setState(1088);
        match(azslParser::KW_ext_print_symbol);
        setState(1089);
        match(azslParser::LeftParen);
        setState(1092);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case azslParser::ColonColon:
          case azslParser::Identifier: {
            setState(1090);
            idExpression();
            break;
          }

          case azslParser::KW_Typeof: {
            setState(1091);
            typeofExpression();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1094);
        match(azslParser::Comma);
        setState(1095);
        _la = _input->LA(1);
        if (!(((((_la - 364) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 364)) & 7) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1096);
        match(azslParser::RightParen);
        setState(1097);
        match(azslParser::Semi);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgDefinitionContext ------------------------------------------------------------------

azslParser::SrgDefinitionContext::SrgDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SrgDefinitionContext::ShaderResourceGroup() {
  return getToken(azslParser::ShaderResourceGroup, 0);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<tree::TerminalNode *> azslParser::SrgDefinitionContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::Partial() {
  return getToken(azslParser::Partial, 0);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

std::vector<azslParser::SrgMemberDeclarationContext *> azslParser::SrgDefinitionContext::srgMemberDeclaration() {
  return getRuleContexts<azslParser::SrgMemberDeclarationContext>();
}

azslParser::SrgMemberDeclarationContext* azslParser::SrgDefinitionContext::srgMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::SrgMemberDeclarationContext>(i);
}


size_t azslParser::SrgDefinitionContext::getRuleIndex() const {
  return azslParser::RuleSrgDefinition;
}

void azslParser::SrgDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgDefinition(this);
}

void azslParser::SrgDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgDefinition(this);
}

azslParser::SrgDefinitionContext* azslParser::srgDefinition() {
  SrgDefinitionContext *_localctx = _tracker.createInstance<SrgDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 220, azslParser::RuleSrgDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1102);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Partial) {
      setState(1101);
      match(azslParser::Partial);
    }
    setState(1104);
    match(azslParser::ShaderResourceGroup);
    setState(1105);
    antlrcpp::downCast<SrgDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(1108);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(1106);
      match(azslParser::Colon);
      setState(1107);
      antlrcpp::downCast<SrgDefinitionContext *>(_localctx)->Semantic = match(azslParser::Identifier);
    }
    setState(1110);
    match(azslParser::LeftBrace);
    setState(1114);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -25) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 38280596832665583) != 0) || ((((_la - 334) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 334)) & 34371272705) != 0)) {
      setState(1111);
      srgMemberDeclaration();
      setState(1116);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1117);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributedSrgDefinitionContext ------------------------------------------------------------------

azslParser::AttributedSrgDefinitionContext::AttributedSrgDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::SrgDefinitionContext* azslParser::AttributedSrgDefinitionContext::srgDefinition() {
  return getRuleContext<azslParser::SrgDefinitionContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AttributedSrgDefinitionContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AttributedSrgDefinitionContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AttributedSrgDefinitionContext::getRuleIndex() const {
  return azslParser::RuleAttributedSrgDefinition;
}

void azslParser::AttributedSrgDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributedSrgDefinition(this);
}

void azslParser::AttributedSrgDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributedSrgDefinition(this);
}

azslParser::AttributedSrgDefinitionContext* azslParser::attributedSrgDefinition() {
  AttributedSrgDefinitionContext *_localctx = _tracker.createInstance<AttributedSrgDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 222, azslParser::RuleAttributedSrgDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1122);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(1119);
      attributeSpecifierAny();
      setState(1124);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1125);
    srgDefinition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgMemberDeclarationContext ------------------------------------------------------------------

azslParser::SrgMemberDeclarationContext::SrgMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StructDefinitionStatementContext* azslParser::SrgMemberDeclarationContext::structDefinitionStatement() {
  return getRuleContext<azslParser::StructDefinitionStatementContext>(0);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::SrgMemberDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::SrgMemberDeclarationContext::attributedFunctionDefinition() {
  return getRuleContext<azslParser::AttributedFunctionDefinitionContext>(0);
}

azslParser::VariableDeclarationStatementContext* azslParser::SrgMemberDeclarationContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::EnumDefinitionStatementContext* azslParser::SrgMemberDeclarationContext::enumDefinitionStatement() {
  return getRuleContext<azslParser::EnumDefinitionStatementContext>(0);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::SrgMemberDeclarationContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::AttributeSpecifierAnyContext* azslParser::SrgMemberDeclarationContext::attributeSpecifierAny() {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(0);
}


size_t azslParser::SrgMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSrgMemberDeclaration;
}

void azslParser::SrgMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgMemberDeclaration(this);
}

void azslParser::SrgMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgMemberDeclaration(this);
}

azslParser::SrgMemberDeclarationContext* azslParser::srgMemberDeclaration() {
  SrgMemberDeclarationContext *_localctx = _tracker.createInstance<SrgMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 224, azslParser::RuleSrgMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1134);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1127);
      structDefinitionStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1128);
      attributedFunctionDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1129);
      attributedFunctionDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1130);
      variableDeclarationStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1131);
      enumDefinitionStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1132);
      typeAliasingDefinitionStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1133);
      attributeSpecifierAny();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgSemanticContext ------------------------------------------------------------------

azslParser::SrgSemanticContext::SrgSemanticContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SrgSemanticContext::ShaderResourceGroupSemantic() {
  return getToken(azslParser::ShaderResourceGroupSemantic, 0);
}

azslParser::SrgSemanticBodyDeclarationContext* azslParser::SrgSemanticContext::srgSemanticBodyDeclaration() {
  return getRuleContext<azslParser::SrgSemanticBodyDeclarationContext>(0);
}

tree::TerminalNode* azslParser::SrgSemanticContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::SrgSemanticContext::getRuleIndex() const {
  return azslParser::RuleSrgSemantic;
}

void azslParser::SrgSemanticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgSemantic(this);
}

void azslParser::SrgSemanticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgSemantic(this);
}

azslParser::SrgSemanticContext* azslParser::srgSemantic() {
  SrgSemanticContext *_localctx = _tracker.createInstance<SrgSemanticContext>(_ctx, getState());
  enterRule(_localctx, 226, azslParser::RuleSrgSemantic);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1136);
    match(azslParser::ShaderResourceGroupSemantic);
    setState(1137);
    antlrcpp::downCast<SrgSemanticContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(1138);
    srgSemanticBodyDeclaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributedSrgSemanticContext ------------------------------------------------------------------

azslParser::AttributedSrgSemanticContext::AttributedSrgSemanticContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::SrgSemanticContext* azslParser::AttributedSrgSemanticContext::srgSemantic() {
  return getRuleContext<azslParser::SrgSemanticContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AttributedSrgSemanticContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AttributedSrgSemanticContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AttributedSrgSemanticContext::getRuleIndex() const {
  return azslParser::RuleAttributedSrgSemantic;
}

void azslParser::AttributedSrgSemanticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributedSrgSemantic(this);
}

void azslParser::AttributedSrgSemanticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributedSrgSemantic(this);
}

azslParser::AttributedSrgSemanticContext* azslParser::attributedSrgSemantic() {
  AttributedSrgSemanticContext *_localctx = _tracker.createInstance<AttributedSrgSemanticContext>(_ctx, getState());
  enterRule(_localctx, 228, azslParser::RuleAttributedSrgSemantic);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1143);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(1140);
      attributeSpecifierAny();
      setState(1145);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1146);
    srgSemantic();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgSemanticBodyDeclarationContext ------------------------------------------------------------------

azslParser::SrgSemanticBodyDeclarationContext::SrgSemanticBodyDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SrgSemanticBodyDeclarationContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::SrgSemanticBodyDeclarationContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<azslParser::SrgSemanticMemberDeclarationContext *> azslParser::SrgSemanticBodyDeclarationContext::srgSemanticMemberDeclaration() {
  return getRuleContexts<azslParser::SrgSemanticMemberDeclarationContext>();
}

azslParser::SrgSemanticMemberDeclarationContext* azslParser::SrgSemanticBodyDeclarationContext::srgSemanticMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::SrgSemanticMemberDeclarationContext>(i);
}


size_t azslParser::SrgSemanticBodyDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSrgSemanticBodyDeclaration;
}

void azslParser::SrgSemanticBodyDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgSemanticBodyDeclaration(this);
}

void azslParser::SrgSemanticBodyDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgSemanticBodyDeclaration(this);
}

azslParser::SrgSemanticBodyDeclarationContext* azslParser::srgSemanticBodyDeclaration() {
  SrgSemanticBodyDeclarationContext *_localctx = _tracker.createInstance<SrgSemanticBodyDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 230, azslParser::RuleSrgSemanticBodyDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1148);
    match(azslParser::LeftBrace);
    setState(1152);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::FrequencyId

    || _la == azslParser::ShaderVariantFallback) {
      setState(1149);
      srgSemanticMemberDeclaration();
      setState(1154);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1155);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgSemanticMemberDeclarationContext ------------------------------------------------------------------

azslParser::SrgSemanticMemberDeclarationContext::SrgSemanticMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SrgSemanticMemberDeclarationContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::SrgSemanticMemberDeclarationContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::SrgSemanticMemberDeclarationContext::FrequencyId() {
  return getToken(azslParser::FrequencyId, 0);
}

azslParser::LiteralContext* azslParser::SrgSemanticMemberDeclarationContext::literal() {
  return getRuleContext<azslParser::LiteralContext>(0);
}

tree::TerminalNode* azslParser::SrgSemanticMemberDeclarationContext::ShaderVariantFallback() {
  return getToken(azslParser::ShaderVariantFallback, 0);
}


size_t azslParser::SrgSemanticMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSrgSemanticMemberDeclaration;
}

void azslParser::SrgSemanticMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgSemanticMemberDeclaration(this);
}

void azslParser::SrgSemanticMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgSemanticMemberDeclaration(this);
}

azslParser::SrgSemanticMemberDeclarationContext* azslParser::srgSemanticMemberDeclaration() {
  SrgSemanticMemberDeclarationContext *_localctx = _tracker.createInstance<SrgSemanticMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 232, azslParser::RuleSrgSemanticMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1167);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::FrequencyId: {
        enterOuterAlt(_localctx, 1);
        setState(1157);
        antlrcpp::downCast<SrgSemanticMemberDeclarationContext *>(_localctx)->Frequency = match(azslParser::FrequencyId);
        setState(1158);
        match(azslParser::Assign);
        setState(1159);
        antlrcpp::downCast<SrgSemanticMemberDeclarationContext *>(_localctx)->FrequencyValue = literal();
        setState(1160);
        match(azslParser::Semi);
        break;
      }

      case azslParser::ShaderVariantFallback: {
        enterOuterAlt(_localctx, 2);
        setState(1162);
        antlrcpp::downCast<SrgSemanticMemberDeclarationContext *>(_localctx)->VariantFallback = match(azslParser::ShaderVariantFallback);
        setState(1163);
        match(azslParser::Assign);
        setState(1164);
        antlrcpp::downCast<SrgSemanticMemberDeclarationContext *>(_localctx)->VariantFallbackValue = literal();
        setState(1165);
        match(azslParser::Semi);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SamplerBodyDeclarationContext ------------------------------------------------------------------

azslParser::SamplerBodyDeclarationContext::SamplerBodyDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SamplerBodyDeclarationContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::SamplerBodyDeclarationContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<azslParser::SamplerMemberDeclarationContext *> azslParser::SamplerBodyDeclarationContext::samplerMemberDeclaration() {
  return getRuleContexts<azslParser::SamplerMemberDeclarationContext>();
}

azslParser::SamplerMemberDeclarationContext* azslParser::SamplerBodyDeclarationContext::samplerMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::SamplerMemberDeclarationContext>(i);
}


size_t azslParser::SamplerBodyDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSamplerBodyDeclaration;
}

void azslParser::SamplerBodyDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSamplerBodyDeclaration(this);
}

void azslParser::SamplerBodyDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSamplerBodyDeclaration(this);
}

azslParser::SamplerBodyDeclarationContext* azslParser::samplerBodyDeclaration() {
  SamplerBodyDeclarationContext *_localctx = _tracker.createInstance<SamplerBodyDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 234, azslParser::RuleSamplerBodyDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1169);
    match(azslParser::LeftBrace);
    setState(1173);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 270) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 270)) & 8191) != 0)) {
      setState(1170);
      samplerMemberDeclaration();
      setState(1175);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1176);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SamplerMemberDeclarationContext ------------------------------------------------------------------

azslParser::SamplerMemberDeclarationContext::SamplerMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::MaxAnisotropyOptionContext* azslParser::SamplerMemberDeclarationContext::maxAnisotropyOption() {
  return getRuleContext<azslParser::MaxAnisotropyOptionContext>(0);
}

azslParser::MinFilterOptionContext* azslParser::SamplerMemberDeclarationContext::minFilterOption() {
  return getRuleContext<azslParser::MinFilterOptionContext>(0);
}

azslParser::MagFilterOptionContext* azslParser::SamplerMemberDeclarationContext::magFilterOption() {
  return getRuleContext<azslParser::MagFilterOptionContext>(0);
}

azslParser::MipFilterOptionContext* azslParser::SamplerMemberDeclarationContext::mipFilterOption() {
  return getRuleContext<azslParser::MipFilterOptionContext>(0);
}

azslParser::ReductionTypeOptionContext* azslParser::SamplerMemberDeclarationContext::reductionTypeOption() {
  return getRuleContext<azslParser::ReductionTypeOptionContext>(0);
}

azslParser::ComparisonFunctionOptionContext* azslParser::SamplerMemberDeclarationContext::comparisonFunctionOption() {
  return getRuleContext<azslParser::ComparisonFunctionOptionContext>(0);
}

azslParser::AddressUOptionContext* azslParser::SamplerMemberDeclarationContext::addressUOption() {
  return getRuleContext<azslParser::AddressUOptionContext>(0);
}

azslParser::AddressVOptionContext* azslParser::SamplerMemberDeclarationContext::addressVOption() {
  return getRuleContext<azslParser::AddressVOptionContext>(0);
}

azslParser::AddressWOptionContext* azslParser::SamplerMemberDeclarationContext::addressWOption() {
  return getRuleContext<azslParser::AddressWOptionContext>(0);
}

azslParser::MinLodOptionContext* azslParser::SamplerMemberDeclarationContext::minLodOption() {
  return getRuleContext<azslParser::MinLodOptionContext>(0);
}

azslParser::MaxLodOptionContext* azslParser::SamplerMemberDeclarationContext::maxLodOption() {
  return getRuleContext<azslParser::MaxLodOptionContext>(0);
}

azslParser::MipLodBiasOptionContext* azslParser::SamplerMemberDeclarationContext::mipLodBiasOption() {
  return getRuleContext<azslParser::MipLodBiasOptionContext>(0);
}

azslParser::BorderColorOptionContext* azslParser::SamplerMemberDeclarationContext::borderColorOption() {
  return getRuleContext<azslParser::BorderColorOptionContext>(0);
}


size_t azslParser::SamplerMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSamplerMemberDeclaration;
}

void azslParser::SamplerMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSamplerMemberDeclaration(this);
}

void azslParser::SamplerMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSamplerMemberDeclaration(this);
}

azslParser::SamplerMemberDeclarationContext* azslParser::samplerMemberDeclaration() {
  SamplerMemberDeclarationContext *_localctx = _tracker.createInstance<SamplerMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 236, azslParser::RuleSamplerMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1191);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::MAX_ANISOTROPY: {
        enterOuterAlt(_localctx, 1);
        setState(1178);
        maxAnisotropyOption();
        break;
      }

      case azslParser::MIN_FILTER: {
        enterOuterAlt(_localctx, 2);
        setState(1179);
        minFilterOption();
        break;
      }

      case azslParser::MAG_FILTER: {
        enterOuterAlt(_localctx, 3);
        setState(1180);
        magFilterOption();
        break;
      }

      case azslParser::MIP_FILTER: {
        enterOuterAlt(_localctx, 4);
        setState(1181);
        mipFilterOption();
        break;
      }

      case azslParser::REDUCTION_TYPE: {
        enterOuterAlt(_localctx, 5);
        setState(1182);
        reductionTypeOption();
        break;
      }

      case azslParser::COMPARISON_FUNC: {
        enterOuterAlt(_localctx, 6);
        setState(1183);
        comparisonFunctionOption();
        break;
      }

      case azslParser::ADDRESS_U: {
        enterOuterAlt(_localctx, 7);
        setState(1184);
        addressUOption();
        break;
      }

      case azslParser::ADDRESS_V: {
        enterOuterAlt(_localctx, 8);
        setState(1185);
        addressVOption();
        break;
      }

      case azslParser::ADDRESS_W: {
        enterOuterAlt(_localctx, 9);
        setState(1186);
        addressWOption();
        break;
      }

      case azslParser::MIN_LOD: {
        enterOuterAlt(_localctx, 10);
        setState(1187);
        minLodOption();
        break;
      }

      case azslParser::MAX_LOD: {
        enterOuterAlt(_localctx, 11);
        setState(1188);
        maxLodOption();
        break;
      }

      case azslParser::MIP_LOD_BIAS: {
        enterOuterAlt(_localctx, 12);
        setState(1189);
        mipLodBiasOption();
        break;
      }

      case azslParser::BORDER_COLOR: {
        enterOuterAlt(_localctx, 13);
        setState(1190);
        borderColorOption();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MaxAnisotropyOptionContext ------------------------------------------------------------------

azslParser::MaxAnisotropyOptionContext::MaxAnisotropyOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MaxAnisotropyOptionContext::MAX_ANISOTROPY() {
  return getToken(azslParser::MAX_ANISOTROPY, 0);
}

tree::TerminalNode* azslParser::MaxAnisotropyOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::MaxAnisotropyOptionContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}

tree::TerminalNode* azslParser::MaxAnisotropyOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MaxAnisotropyOptionContext::getRuleIndex() const {
  return azslParser::RuleMaxAnisotropyOption;
}

void azslParser::MaxAnisotropyOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMaxAnisotropyOption(this);
}

void azslParser::MaxAnisotropyOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMaxAnisotropyOption(this);
}

azslParser::MaxAnisotropyOptionContext* azslParser::maxAnisotropyOption() {
  MaxAnisotropyOptionContext *_localctx = _tracker.createInstance<MaxAnisotropyOptionContext>(_ctx, getState());
  enterRule(_localctx, 238, azslParser::RuleMaxAnisotropyOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1193);
    match(azslParser::MAX_ANISOTROPY);
    setState(1194);
    match(azslParser::Assign);
    setState(1195);
    match(azslParser::IntegerLiteral);
    setState(1196);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MinFilterOptionContext ------------------------------------------------------------------

azslParser::MinFilterOptionContext::MinFilterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MinFilterOptionContext::MIN_FILTER() {
  return getToken(azslParser::MIN_FILTER, 0);
}

tree::TerminalNode* azslParser::MinFilterOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::FilterModeEnumContext* azslParser::MinFilterOptionContext::filterModeEnum() {
  return getRuleContext<azslParser::FilterModeEnumContext>(0);
}

tree::TerminalNode* azslParser::MinFilterOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MinFilterOptionContext::getRuleIndex() const {
  return azslParser::RuleMinFilterOption;
}

void azslParser::MinFilterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMinFilterOption(this);
}

void azslParser::MinFilterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMinFilterOption(this);
}

azslParser::MinFilterOptionContext* azslParser::minFilterOption() {
  MinFilterOptionContext *_localctx = _tracker.createInstance<MinFilterOptionContext>(_ctx, getState());
  enterRule(_localctx, 240, azslParser::RuleMinFilterOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1198);
    match(azslParser::MIN_FILTER);
    setState(1199);
    match(azslParser::Assign);
    setState(1200);
    filterModeEnum();
    setState(1201);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MagFilterOptionContext ------------------------------------------------------------------

azslParser::MagFilterOptionContext::MagFilterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MagFilterOptionContext::MAG_FILTER() {
  return getToken(azslParser::MAG_FILTER, 0);
}

tree::TerminalNode* azslParser::MagFilterOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::FilterModeEnumContext* azslParser::MagFilterOptionContext::filterModeEnum() {
  return getRuleContext<azslParser::FilterModeEnumContext>(0);
}

tree::TerminalNode* azslParser::MagFilterOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MagFilterOptionContext::getRuleIndex() const {
  return azslParser::RuleMagFilterOption;
}

void azslParser::MagFilterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMagFilterOption(this);
}

void azslParser::MagFilterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMagFilterOption(this);
}

azslParser::MagFilterOptionContext* azslParser::magFilterOption() {
  MagFilterOptionContext *_localctx = _tracker.createInstance<MagFilterOptionContext>(_ctx, getState());
  enterRule(_localctx, 242, azslParser::RuleMagFilterOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1203);
    match(azslParser::MAG_FILTER);
    setState(1204);
    match(azslParser::Assign);
    setState(1205);
    filterModeEnum();
    setState(1206);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MipFilterOptionContext ------------------------------------------------------------------

azslParser::MipFilterOptionContext::MipFilterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MipFilterOptionContext::MIP_FILTER() {
  return getToken(azslParser::MIP_FILTER, 0);
}

tree::TerminalNode* azslParser::MipFilterOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::FilterModeEnumContext* azslParser::MipFilterOptionContext::filterModeEnum() {
  return getRuleContext<azslParser::FilterModeEnumContext>(0);
}

tree::TerminalNode* azslParser::MipFilterOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MipFilterOptionContext::getRuleIndex() const {
  return azslParser::RuleMipFilterOption;
}

void azslParser::MipFilterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMipFilterOption(this);
}

void azslParser::MipFilterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMipFilterOption(this);
}

azslParser::MipFilterOptionContext* azslParser::mipFilterOption() {
  MipFilterOptionContext *_localctx = _tracker.createInstance<MipFilterOptionContext>(_ctx, getState());
  enterRule(_localctx, 244, azslParser::RuleMipFilterOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1208);
    match(azslParser::MIP_FILTER);
    setState(1209);
    match(azslParser::Assign);
    setState(1210);
    filterModeEnum();
    setState(1211);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReductionTypeOptionContext ------------------------------------------------------------------

azslParser::ReductionTypeOptionContext::ReductionTypeOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ReductionTypeOptionContext::REDUCTION_TYPE() {
  return getToken(azslParser::REDUCTION_TYPE, 0);
}

tree::TerminalNode* azslParser::ReductionTypeOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::ReductionTypeEnumContext* azslParser::ReductionTypeOptionContext::reductionTypeEnum() {
  return getRuleContext<azslParser::ReductionTypeEnumContext>(0);
}

tree::TerminalNode* azslParser::ReductionTypeOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::ReductionTypeOptionContext::getRuleIndex() const {
  return azslParser::RuleReductionTypeOption;
}

void azslParser::ReductionTypeOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReductionTypeOption(this);
}

void azslParser::ReductionTypeOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReductionTypeOption(this);
}

azslParser::ReductionTypeOptionContext* azslParser::reductionTypeOption() {
  ReductionTypeOptionContext *_localctx = _tracker.createInstance<ReductionTypeOptionContext>(_ctx, getState());
  enterRule(_localctx, 246, azslParser::RuleReductionTypeOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1213);
    match(azslParser::REDUCTION_TYPE);
    setState(1214);
    match(azslParser::Assign);
    setState(1215);
    reductionTypeEnum();
    setState(1216);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonFunctionOptionContext ------------------------------------------------------------------

azslParser::ComparisonFunctionOptionContext::ComparisonFunctionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ComparisonFunctionOptionContext::COMPARISON_FUNC() {
  return getToken(azslParser::COMPARISON_FUNC, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::ComparisonFunctionEnumContext* azslParser::ComparisonFunctionOptionContext::comparisonFunctionEnum() {
  return getRuleContext<azslParser::ComparisonFunctionEnumContext>(0);
}

tree::TerminalNode* azslParser::ComparisonFunctionOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::ComparisonFunctionOptionContext::getRuleIndex() const {
  return azslParser::RuleComparisonFunctionOption;
}

void azslParser::ComparisonFunctionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonFunctionOption(this);
}

void azslParser::ComparisonFunctionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonFunctionOption(this);
}

azslParser::ComparisonFunctionOptionContext* azslParser::comparisonFunctionOption() {
  ComparisonFunctionOptionContext *_localctx = _tracker.createInstance<ComparisonFunctionOptionContext>(_ctx, getState());
  enterRule(_localctx, 248, azslParser::RuleComparisonFunctionOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1218);
    match(azslParser::COMPARISON_FUNC);
    setState(1219);
    match(azslParser::Assign);
    setState(1220);
    comparisonFunctionEnum();
    setState(1221);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddressUOptionContext ------------------------------------------------------------------

azslParser::AddressUOptionContext::AddressUOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AddressUOptionContext::ADDRESS_U() {
  return getToken(azslParser::ADDRESS_U, 0);
}

tree::TerminalNode* azslParser::AddressUOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::AddressModeEnumContext* azslParser::AddressUOptionContext::addressModeEnum() {
  return getRuleContext<azslParser::AddressModeEnumContext>(0);
}

tree::TerminalNode* azslParser::AddressUOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::AddressUOptionContext::getRuleIndex() const {
  return azslParser::RuleAddressUOption;
}

void azslParser::AddressUOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddressUOption(this);
}

void azslParser::AddressUOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddressUOption(this);
}

azslParser::AddressUOptionContext* azslParser::addressUOption() {
  AddressUOptionContext *_localctx = _tracker.createInstance<AddressUOptionContext>(_ctx, getState());
  enterRule(_localctx, 250, azslParser::RuleAddressUOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1223);
    match(azslParser::ADDRESS_U);
    setState(1224);
    match(azslParser::Assign);
    setState(1225);
    addressModeEnum();
    setState(1226);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddressVOptionContext ------------------------------------------------------------------

azslParser::AddressVOptionContext::AddressVOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AddressVOptionContext::ADDRESS_V() {
  return getToken(azslParser::ADDRESS_V, 0);
}

tree::TerminalNode* azslParser::AddressVOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::AddressModeEnumContext* azslParser::AddressVOptionContext::addressModeEnum() {
  return getRuleContext<azslParser::AddressModeEnumContext>(0);
}

tree::TerminalNode* azslParser::AddressVOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::AddressVOptionContext::getRuleIndex() const {
  return azslParser::RuleAddressVOption;
}

void azslParser::AddressVOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddressVOption(this);
}

void azslParser::AddressVOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddressVOption(this);
}

azslParser::AddressVOptionContext* azslParser::addressVOption() {
  AddressVOptionContext *_localctx = _tracker.createInstance<AddressVOptionContext>(_ctx, getState());
  enterRule(_localctx, 252, azslParser::RuleAddressVOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1228);
    match(azslParser::ADDRESS_V);
    setState(1229);
    match(azslParser::Assign);
    setState(1230);
    addressModeEnum();
    setState(1231);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddressWOptionContext ------------------------------------------------------------------

azslParser::AddressWOptionContext::AddressWOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AddressWOptionContext::ADDRESS_W() {
  return getToken(azslParser::ADDRESS_W, 0);
}

tree::TerminalNode* azslParser::AddressWOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::AddressModeEnumContext* azslParser::AddressWOptionContext::addressModeEnum() {
  return getRuleContext<azslParser::AddressModeEnumContext>(0);
}

tree::TerminalNode* azslParser::AddressWOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::AddressWOptionContext::getRuleIndex() const {
  return azslParser::RuleAddressWOption;
}

void azslParser::AddressWOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddressWOption(this);
}

void azslParser::AddressWOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddressWOption(this);
}

azslParser::AddressWOptionContext* azslParser::addressWOption() {
  AddressWOptionContext *_localctx = _tracker.createInstance<AddressWOptionContext>(_ctx, getState());
  enterRule(_localctx, 254, azslParser::RuleAddressWOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1233);
    match(azslParser::ADDRESS_W);
    setState(1234);
    match(azslParser::Assign);
    setState(1235);
    addressModeEnum();
    setState(1236);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MinLodOptionContext ------------------------------------------------------------------

azslParser::MinLodOptionContext::MinLodOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MinLodOptionContext::MIN_LOD() {
  return getToken(azslParser::MIN_LOD, 0);
}

tree::TerminalNode* azslParser::MinLodOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::MinLodOptionContext::FloatLiteral() {
  return getToken(azslParser::FloatLiteral, 0);
}

tree::TerminalNode* azslParser::MinLodOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MinLodOptionContext::getRuleIndex() const {
  return azslParser::RuleMinLodOption;
}

void azslParser::MinLodOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMinLodOption(this);
}

void azslParser::MinLodOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMinLodOption(this);
}

azslParser::MinLodOptionContext* azslParser::minLodOption() {
  MinLodOptionContext *_localctx = _tracker.createInstance<MinLodOptionContext>(_ctx, getState());
  enterRule(_localctx, 256, azslParser::RuleMinLodOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1238);
    match(azslParser::MIN_LOD);
    setState(1239);
    match(azslParser::Assign);
    setState(1240);
    match(azslParser::FloatLiteral);
    setState(1241);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MaxLodOptionContext ------------------------------------------------------------------

azslParser::MaxLodOptionContext::MaxLodOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MaxLodOptionContext::MAX_LOD() {
  return getToken(azslParser::MAX_LOD, 0);
}

tree::TerminalNode* azslParser::MaxLodOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::MaxLodOptionContext::FloatLiteral() {
  return getToken(azslParser::FloatLiteral, 0);
}

tree::TerminalNode* azslParser::MaxLodOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MaxLodOptionContext::getRuleIndex() const {
  return azslParser::RuleMaxLodOption;
}

void azslParser::MaxLodOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMaxLodOption(this);
}

void azslParser::MaxLodOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMaxLodOption(this);
}

azslParser::MaxLodOptionContext* azslParser::maxLodOption() {
  MaxLodOptionContext *_localctx = _tracker.createInstance<MaxLodOptionContext>(_ctx, getState());
  enterRule(_localctx, 258, azslParser::RuleMaxLodOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1243);
    match(azslParser::MAX_LOD);
    setState(1244);
    match(azslParser::Assign);
    setState(1245);
    match(azslParser::FloatLiteral);
    setState(1246);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MipLodBiasOptionContext ------------------------------------------------------------------

azslParser::MipLodBiasOptionContext::MipLodBiasOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MipLodBiasOptionContext::MIP_LOD_BIAS() {
  return getToken(azslParser::MIP_LOD_BIAS, 0);
}

tree::TerminalNode* azslParser::MipLodBiasOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::MipLodBiasOptionContext::FloatLiteral() {
  return getToken(azslParser::FloatLiteral, 0);
}

tree::TerminalNode* azslParser::MipLodBiasOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MipLodBiasOptionContext::getRuleIndex() const {
  return azslParser::RuleMipLodBiasOption;
}

void azslParser::MipLodBiasOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMipLodBiasOption(this);
}

void azslParser::MipLodBiasOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMipLodBiasOption(this);
}

azslParser::MipLodBiasOptionContext* azslParser::mipLodBiasOption() {
  MipLodBiasOptionContext *_localctx = _tracker.createInstance<MipLodBiasOptionContext>(_ctx, getState());
  enterRule(_localctx, 260, azslParser::RuleMipLodBiasOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1248);
    match(azslParser::MIP_LOD_BIAS);
    setState(1249);
    match(azslParser::Assign);
    setState(1250);
    match(azslParser::FloatLiteral);
    setState(1251);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BorderColorOptionContext ------------------------------------------------------------------

azslParser::BorderColorOptionContext::BorderColorOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BorderColorOptionContext::BORDER_COLOR() {
  return getToken(azslParser::BORDER_COLOR, 0);
}

tree::TerminalNode* azslParser::BorderColorOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::BorderColorEnumContext* azslParser::BorderColorOptionContext::borderColorEnum() {
  return getRuleContext<azslParser::BorderColorEnumContext>(0);
}

tree::TerminalNode* azslParser::BorderColorOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::BorderColorOptionContext::getRuleIndex() const {
  return azslParser::RuleBorderColorOption;
}

void azslParser::BorderColorOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBorderColorOption(this);
}

void azslParser::BorderColorOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBorderColorOption(this);
}

azslParser::BorderColorOptionContext* azslParser::borderColorOption() {
  BorderColorOptionContext *_localctx = _tracker.createInstance<BorderColorOptionContext>(_ctx, getState());
  enterRule(_localctx, 262, azslParser::RuleBorderColorOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1253);
    match(azslParser::BORDER_COLOR);
    setState(1254);
    match(azslParser::Assign);
    setState(1255);
    borderColorEnum();
    setState(1256);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterModeEnumContext ------------------------------------------------------------------

azslParser::FilterModeEnumContext::FilterModeEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::FilterModeEnumContext::FILTER_MODE_POINT() {
  return getToken(azslParser::FILTER_MODE_POINT, 0);
}

tree::TerminalNode* azslParser::FilterModeEnumContext::FILTER_MODE_LINEAR() {
  return getToken(azslParser::FILTER_MODE_LINEAR, 0);
}


size_t azslParser::FilterModeEnumContext::getRuleIndex() const {
  return azslParser::RuleFilterModeEnum;
}

void azslParser::FilterModeEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterModeEnum(this);
}

void azslParser::FilterModeEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterModeEnum(this);
}

azslParser::FilterModeEnumContext* azslParser::filterModeEnum() {
  FilterModeEnumContext *_localctx = _tracker.createInstance<FilterModeEnumContext>(_ctx, getState());
  enterRule(_localctx, 264, azslParser::RuleFilterModeEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1258);
    _la = _input->LA(1);
    if (!(_la == azslParser::FILTER_MODE_POINT

    || _la == azslParser::FILTER_MODE_LINEAR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReductionTypeEnumContext ------------------------------------------------------------------

azslParser::ReductionTypeEnumContext::ReductionTypeEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ReductionTypeEnumContext::REDUCTION_TYPE_FILTER() {
  return getToken(azslParser::REDUCTION_TYPE_FILTER, 0);
}

tree::TerminalNode* azslParser::ReductionTypeEnumContext::REDUCTION_TYPE_COMPARISON() {
  return getToken(azslParser::REDUCTION_TYPE_COMPARISON, 0);
}

tree::TerminalNode* azslParser::ReductionTypeEnumContext::REDUCTION_TYPE_MINIMUM() {
  return getToken(azslParser::REDUCTION_TYPE_MINIMUM, 0);
}

tree::TerminalNode* azslParser::ReductionTypeEnumContext::REDUCTION_TYPE_MAXIMUM() {
  return getToken(azslParser::REDUCTION_TYPE_MAXIMUM, 0);
}


size_t azslParser::ReductionTypeEnumContext::getRuleIndex() const {
  return azslParser::RuleReductionTypeEnum;
}

void azslParser::ReductionTypeEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReductionTypeEnum(this);
}

void azslParser::ReductionTypeEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReductionTypeEnum(this);
}

azslParser::ReductionTypeEnumContext* azslParser::reductionTypeEnum() {
  ReductionTypeEnumContext *_localctx = _tracker.createInstance<ReductionTypeEnumContext>(_ctx, getState());
  enterRule(_localctx, 266, azslParser::RuleReductionTypeEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1260);
    _la = _input->LA(1);
    if (!(((((_la - 285) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 285)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddressModeEnumContext ------------------------------------------------------------------

azslParser::AddressModeEnumContext::AddressModeEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_WRAP() {
  return getToken(azslParser::ADDRESS_MODE_WRAP, 0);
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_MIRROR() {
  return getToken(azslParser::ADDRESS_MODE_MIRROR, 0);
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_CLAMP() {
  return getToken(azslParser::ADDRESS_MODE_CLAMP, 0);
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_BORDER() {
  return getToken(azslParser::ADDRESS_MODE_BORDER, 0);
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_MIRROR_ONCE() {
  return getToken(azslParser::ADDRESS_MODE_MIRROR_ONCE, 0);
}


size_t azslParser::AddressModeEnumContext::getRuleIndex() const {
  return azslParser::RuleAddressModeEnum;
}

void azslParser::AddressModeEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddressModeEnum(this);
}

void azslParser::AddressModeEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddressModeEnum(this);
}

azslParser::AddressModeEnumContext* azslParser::addressModeEnum() {
  AddressModeEnumContext *_localctx = _tracker.createInstance<AddressModeEnumContext>(_ctx, getState());
  enterRule(_localctx, 268, azslParser::RuleAddressModeEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1262);
    _la = _input->LA(1);
    if (!(((((_la - 289) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 289)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonFunctionEnumContext ------------------------------------------------------------------

azslParser::ComparisonFunctionEnumContext::ComparisonFunctionEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_NEVER() {
  return getToken(azslParser::COMPARISON_FUNCTION_NEVER, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_LESS() {
  return getToken(azslParser::COMPARISON_FUNCTION_LESS, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_EQUAL() {
  return getToken(azslParser::COMPARISON_FUNCTION_EQUAL, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_LESS_EQUAL() {
  return getToken(azslParser::COMPARISON_FUNCTION_LESS_EQUAL, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_GREATER() {
  return getToken(azslParser::COMPARISON_FUNCTION_GREATER, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_NOT_EQUAL() {
  return getToken(azslParser::COMPARISON_FUNCTION_NOT_EQUAL, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_GREATER_EQUAL() {
  return getToken(azslParser::COMPARISON_FUNCTION_GREATER_EQUAL, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_ALWAYS() {
  return getToken(azslParser::COMPARISON_FUNCTION_ALWAYS, 0);
}


size_t azslParser::ComparisonFunctionEnumContext::getRuleIndex() const {
  return azslParser::RuleComparisonFunctionEnum;
}

void azslParser::ComparisonFunctionEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonFunctionEnum(this);
}

void azslParser::ComparisonFunctionEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonFunctionEnum(this);
}

azslParser::ComparisonFunctionEnumContext* azslParser::comparisonFunctionEnum() {
  ComparisonFunctionEnumContext *_localctx = _tracker.createInstance<ComparisonFunctionEnumContext>(_ctx, getState());
  enterRule(_localctx, 270, azslParser::RuleComparisonFunctionEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1264);
    _la = _input->LA(1);
    if (!(((((_la - 294) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 294)) & 255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BorderColorEnumContext ------------------------------------------------------------------

azslParser::BorderColorEnumContext::BorderColorEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BorderColorEnumContext::BORDER_COLOR_OPAQUE_BLACK() {
  return getToken(azslParser::BORDER_COLOR_OPAQUE_BLACK, 0);
}

tree::TerminalNode* azslParser::BorderColorEnumContext::BORDER_COLOR_TRANSPARENT_BLACK() {
  return getToken(azslParser::BORDER_COLOR_TRANSPARENT_BLACK, 0);
}

tree::TerminalNode* azslParser::BorderColorEnumContext::BORDER_COLOR_OPAQUE_WHITE() {
  return getToken(azslParser::BORDER_COLOR_OPAQUE_WHITE, 0);
}


size_t azslParser::BorderColorEnumContext::getRuleIndex() const {
  return azslParser::RuleBorderColorEnum;
}

void azslParser::BorderColorEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBorderColorEnum(this);
}

void azslParser::BorderColorEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBorderColorEnum(this);
}

azslParser::BorderColorEnumContext* azslParser::borderColorEnum() {
  BorderColorEnumContext *_localctx = _tracker.createInstance<BorderColorEnumContext>(_ctx, getState());
  enterRule(_localctx, 272, azslParser::RuleBorderColorEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1266);
    _la = _input->LA(1);
    if (!(((((_la - 302) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 302)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool azslParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 43: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 44: return expressionExtSempred(antlrcpp::downCast<ExpressionExtContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool azslParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 3);
    case 1: return precpred(_ctx, 10);
    case 2: return precpred(_ctx, 9);
    case 3: return precpred(_ctx, 8);
    case 4: return precpred(_ctx, 5);
    case 5: return precpred(_ctx, 2);
    case 6: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool azslParser::expressionExtSempred(ExpressionExtContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void azslParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  azslparserParserInitialize();
#else
  ::antlr4::internal::call_once(azslparserParserOnceFlag, azslparserParserInitialize);
#endif
}
