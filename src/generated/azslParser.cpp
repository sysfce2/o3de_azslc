
// Generated from ../azslParser.g4 by ANTLR 4.13.2


#include "azslParserListener.h"

#include "azslParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct AzslParserStaticData final {
  AzslParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  AzslParserStaticData(const AzslParserStaticData&) = delete;
  AzslParserStaticData(AzslParserStaticData&&) = delete;
  AzslParserStaticData& operator=(const AzslParserStaticData&) = delete;
  AzslParserStaticData& operator=(AzslParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag azslparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<AzslParserStaticData> azslparserParserStaticData = nullptr;

void azslparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (azslparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(azslparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<AzslParserStaticData>(
    std::vector<std::string>{
      "compilationUnit", "topLevelDeclaration", "idExpression", "unqualifiedId", 
      "qualifiedId", "nestedNameSpecifier", "classDefinitionStatement", 
      "classDefinition", "baseList", "classMemberDeclaration", "structDefinitionStatement", 
      "structDefinition", "structMemberDeclaration", "anyStructuredTypeDefinitionStatement", 
      "enumDefinitionStatement", "enumDefinition", "enumKey", "enumeratorListDefinition", 
      "enumeratorDeclarator", "anyStructuredTypeDefinition", "interfaceDefinitionStatement", 
      "interfaceDefinition", "interfaceMemberDeclaration", "constantBufferTemplated", 
      "variableDeclarationStatement", "functionParams", "functionParam", 
      "hlslSemantic", "hlslSemanticName", "attributeArguments", "attributeArgumentList", 
      "attribute", "attributeSpecifier", "attributeSpecifierSequence", "attributeSpecifierAny", 
      "block", "statement", "forInitializer", "switchLabel", "switchSection", 
      "switchBlock", "embeddedStatement", "elseClause", "expression", "expressionExt", 
      "postfixUnaryOperator", "prefixUnaryOperator", "binaryOperator", "assignmentOperator", 
      "argumentList", "arguments", "variableDeclaration", "variableDeclarators", 
      "unnamedVariableDeclarator", "namedVariableDeclarator", "variableInitializer", 
      "standardVariableInitializer", "arrayElementInitializers", "arrayRankSpecifier", 
      "packOffsetNode", "storageFlags", "storageFlag", "type", "predefinedType", 
      "subobjectType", "otherViewResourceType", "rtxBuiltInTypes", "bufferPredefinedType", 
      "bufferType", "byteAddressBufferTypes", "patchPredefinedType", "patchType", 
      "samplerStatePredefinedType", "scalarType", "streamOutputPredefinedType", 
      "streamOutputObjectType", "structuredBufferPredefinedType", "structuredBufferName", 
      "textureType", "texturePredefinedType", "genericTexturePredefinedType", 
      "textureTypeMS", "msTexturePredefinedType", "subpassInputType", "subpassInputPredefinedType", 
      "genericSubpassInputPredefinedType", "vectorType", "genericVectorType", 
      "scalarOrVectorType", "scalarOrVectorOrMatrixType", "matrixType", 
      "genericMatrixPredefinedType", "registerAllocation", "samplerStateProperty", 
      "literal", "leadingTypeFunctionSignature", "hlslFunctionDefinition", 
      "hlslFunctionDeclaration", "userDefinedType", "associatedTypeDeclaration", 
      "typedefStatement", "typealiasStatement", "typeAliasingDefinitionStatement", 
      "typeofExpression", "genericParameterList", "genericTypeDefinition", 
      "genericConstraint", "languageDefinedConstraint", "functionDeclaration", 
      "attributedFunctionDeclaration", "functionDefinition", "attributedFunctionDefinition", 
      "compilerExtensionStatement", "srgDefinition", "attributedSrgDefinition", 
      "srgMemberDeclaration", "srgSemantic", "attributedSrgSemantic", "srgSemanticBodyDeclaration", 
      "srgSemanticMemberDeclaration", "samplerBodyDeclaration", "samplerMemberDeclaration", 
      "maxAnisotropyOption", "minFilterOption", "magFilterOption", "mipFilterOption", 
      "reductionTypeOption", "comparisonFunctionOption", "addressUOption", 
      "addressVOption", "addressWOption", "minLodOption", "maxLodOption", 
      "mipLodBiasOption", "borderColorOption", "filterModeEnum", "reductionTypeEnum", 
      "addressModeEnum", "comparisonFunctionEnum", "borderColorEnum"
    },
    std::vector<std::string>{
      "", "'AppendStructuredBuffer'", "'bool'", "'bool1'", "'bool2'", "'bool3'", 
      "'bool4'", "'bool1x1'", "'bool1x2'", "'bool1x3'", "'bool1x4'", "'bool2x1'", 
      "'bool2x2'", "'bool2x3'", "'bool2x4'", "'bool3x1'", "'bool3x2'", "'bool3x3'", 
      "'bool3x4'", "'bool4x1'", "'bool4x2'", "'bool4x3'", "'bool4x4'", "'Buffer'", 
      "'BuiltInTriangleIntersectionAttributes'", "'ByteAddressBuffer'", 
      "'break'", "'case'", "'cbuffer'", "'centroid'", "'constantbuffer'", 
      "'ConstantBuffer'", "'class'", "'column_major'", "'const'", "'ConsumeStructuredBuffer'", 
      "'continue'", "'default'", "'discard'", "'do'", "'double'", "'double1'", 
      "'double2'", "'double3'", "'double4'", "'double1x1'", "'double1x2'", 
      "'double1x3'", "'double1x4'", "'double2x1'", "'double2x2'", "'double2x3'", 
      "'double2x4'", "'double3x1'", "'double3x2'", "'double3x3'", "'double3x4'", 
      "'double4x1'", "'double4x2'", "'double4x3'", "'double4x4'", "'else'", 
      "'enum'", "'export'", "'extern'", "'FeedbackTexture2D'", "'FeedbackTexture2DArray'", 
      "'float'", "'float1'", "'float2'", "'float3'", "'float4'", "'float1x1'", 
      "'float1x2'", "'float1x3'", "'float1x4'", "'float2x1'", "'float2x2'", 
      "'float2x3'", "'float2x4'", "'float3x1'", "'float3x2'", "'float3x3'", 
      "'float3x4'", "'float4x1'", "'float4x2'", "'float4x3'", "'float4x4'", 
      "'for'", "'groupshared'", "'globallycoherent'", "'global'", "'half'", 
      "'half1'", "'half2'", "'half3'", "'half4'", "'half1x1'", "'half1x2'", 
      "'half1x3'", "'half1x4'", "'half2x1'", "'half2x2'", "'half2x3'", "'half2x4'", 
      "'half3x1'", "'half3x2'", "'half3x3'", "'half3x4'", "'half4x1'", "'half4x2'", 
      "'half4x3'", "'half4x4'", "'if'", "'in'", "'inline'", "'rootconstant'", 
      "", "'InputPatch'", "'int'", "'int16_t'", "'int32_t'", "'int64_t'", 
      "'int1'", "'int2'", "'int3'", "'int4'", "'int1x1'", "'int1x2'", "'int1x3'", 
      "'int1x4'", "'int2x1'", "'int2x2'", "'int2x3'", "'int2x4'", "'int3x1'", 
      "'int3x2'", "'int3x3'", "'int3x4'", "'int4x1'", "'int4x2'", "'int4x3'", 
      "'int4x4'", "'interface'", "'line'", "'lineadj'", "'linear'", "'LineStream'", 
      "'long'", "'matrix'", "'nointerpolation'", "'noperspective'", "'option'", 
      "'out'", "'OutputPatch'", "'override'", "'partial'", "'packoffset'", 
      "'point'", "'PointStream'", "'precise'", "'RasterizerOrderedBuffer'", 
      "'RasterizerOrderedByteAddressBuffer'", "'RasterizerOrderedStructuredBuffer'", 
      "'RasterizerOrderedTexture1D'", "'RasterizerOrderedTexture1DArray'", 
      "'RasterizerOrderedTexture2D'", "'RasterizerOrderedTexture2DArray'", 
      "'RasterizerOrderedTexture3D'", "'RayDesc'", "'RaytracingAccelerationStructure'", 
      "'register'", "'return'", "'row_major'", "'RWBuffer'", "'RWByteAddressBuffer'", 
      "'RWStructuredBuffer'", "'RWTexture1D'", "'RWTexture1DArray'", "'RWTexture2D'", 
      "'RWTexture2DArray'", "'RWTexture3D'", "'sample'", "'sampler'", "'Sampler'", 
      "'SamplerComparisonState'", "'SamplerState'", "'sampler_state'", "'shared'", 
      "'snorm'", "'static'", "'struct'", "'StructuredBuffer'", "'SubpassInput'", 
      "'SubpassInputMS'", "'SubpassInputDS'", "'SubpassInputDSMS'", "'switch'", 
      "'tbuffer'", "'Texture1D'", "'Texture1DArray'", "'Texture2D'", "'Texture2DArray'", 
      "'Texture2DMS'", "'Texture2DMSArray'", "'Texture3D'", "'TextureCube'", 
      "'TextureCubeArray'", "'triangle'", "'triangleadj'", "'TriangleStream'", 
      "'uniform'", "'uint'", "'uint1'", "'uint2'", "'uint3'", "'uint4'", 
      "'uint1x1'", "'uint1x2'", "'uint1x3'", "'uint1x4'", "'uint2x1'", "'uint2x2'", 
      "'uint2x3'", "'uint2x4'", "'uint3x1'", "'uint3x2'", "'uint3x3'", "'uint3x4'", 
      "'uint4x1'", "'uint4x2'", "'uint4x3'", "'uint4x4'", "'uint16_t'", 
      "'uint32_t'", "'uint64_t'", "'unorm'", "'unsigned'", "'dword'", "'dword1'", 
      "'dword2'", "'dword3'", "'dword4'", "'dword1x1'", "'dword1x2'", "'dword1x3'", 
      "'dword1x4'", "'dword2x1'", "'dword2x2'", "'dword2x3'", "'dword2x4'", 
      "'dword3x1'", "'dword3x2'", "'dword3x3'", "'dword3x4'", "'dword4x1'", 
      "'dword4x2'", "'dword4x3'", "'dword4x4'", "'vector'", "'volatile'", 
      "'void'", "'while'", "'StateObjectConfig'", "'LocalRootSignature'", 
      "'GlobalRootSignature'", "'SubobjectToExportsAssociation'", "'RaytracingShaderConfig'", 
      "'RaytracingPipelineConfig'", "'RaytracingPipelineConfig1'", "'TriangleHitGroup'", 
      "'ProceduralPrimitiveHitGroup'", "'AddressU'", "'AddressV'", "'AddressW'", 
      "'BorderColor'", "'MinFilter'", "'MagFilter'", "'MipFilter'", "'MaxAnisotropy'", 
      "'MaxLOD'", "'MinLOD'", "'MipLODBias'", "'ComparisonFunc'", "'ReductionType'", 
      "'Point'", "'Linear'", "'Filter'", "'Comparison'", "'Minimum'", "'Maximum'", 
      "'Wrap'", "'Mirror'", "'Clamp'", "'Border'", "'MirrorOnce'", "'Never'", 
      "'Less'", "'Equal'", "'LessEqual'", "'Greater'", "'NotEqual'", "'GreaterEqual'", 
      "'Always'", "'OpaqueBlack'", "'TransparentBlack'", "'OpaqueWhite'", 
      "'('", "')'", "'['", "']'", "'{'", "'}'", "'[['", "'<'", "'<='", "'>'", 
      "'>='", "'<<'", "'>>'", "'+'", "'++'", "'-'", "'--'", "'*'", "'/'", 
      "'%'", "'&'", "'|'", "'&&'", "'||'", "'^'", "'!'", "'~'", "'\\u003F'", 
      "':'", "'::'", "';'", "','", "'='", "'*='", "'/='", "'%='", "'+='", 
      "'-='", "'<<='", "'>>='", "'&='", "'^='", "'|='", "'=='", "'!='", 
      "'.'", "'true'", "'false'", "'associatedtype'", "'typealias'", "'typedef'", 
      "'fundamental'", "'typeof'", "'FrequencyId'", "'ShaderVariantFallback'", 
      "'ShaderResourceGroupSemantic'", "'ShaderResourceGroup'", "'__azslc_print_message'", 
      "'__azslc_print_symbol'", "'__azslc_prtsym_fully_qualified'", "'__azslc_prtsym_least_qualified'", 
      "'__azslc_prtsym_constint_value'"
    },
    std::vector<std::string>{
      "", "AppendStructuredBuffer", "Bool", "Bool1", "Bool2", "Bool3", "Bool4", 
      "Bool1x1", "Bool1x2", "Bool1x3", "Bool1x4", "Bool2x1", "Bool2x2", 
      "Bool2x3", "Bool2x4", "Bool3x1", "Bool3x2", "Bool3x3", "Bool3x4", 
      "Bool4x1", "Bool4x2", "Bool4x3", "Bool4x4", "Buffer", "BuiltInTriangleIntersectionAttributes", 
      "ByteAddressBuffer", "Break", "Case", "CBuffer", "Centroid", "ConstantBuffer", 
      "ConstantBufferCamel", "Class", "ColumnMajor", "Const", "ConsumeStructuredBuffer", 
      "Continue", "Default", "Discard", "Do", "Double", "Double1", "Double2", 
      "Double3", "Double4", "Double1x1", "Double1x2", "Double1x3", "Double1x4", 
      "Double2x1", "Double2x2", "Double2x3", "Double2x4", "Double3x1", "Double3x2", 
      "Double3x3", "Double3x4", "Double4x1", "Double4x2", "Double4x3", "Double4x4", 
      "Else", "Enum", "Export", "Extern", "FeedbackTexture2D", "FeedbackTexture2DArray", 
      "Float", "Float1", "Float2", "Float3", "Float4", "Float1x1", "Float1x2", 
      "Float1x3", "Float1x4", "Float2x1", "Float2x2", "Float2x3", "Float2x4", 
      "Float3x1", "Float3x2", "Float3x3", "Float3x4", "Float4x1", "Float4x2", 
      "Float4x3", "Float4x4", "For", "Groupshared", "Globallycoherent", 
      "Global", "Half", "Half1", "Half2", "Half3", "Half4", "Half1x1", "Half1x2", 
      "Half1x3", "Half1x4", "Half2x1", "Half2x2", "Half2x3", "Half2x4", 
      "Half3x1", "Half3x2", "Half3x3", "Half3x4", "Half4x1", "Half4x2", 
      "Half4x3", "Half4x4", "If", "In", "Inline", "Rootconstant", "Inout", 
      "InputPatch", "Int", "Int16_t", "Int32_t", "Int64_t", "Int1", "Int2", 
      "Int3", "Int4", "Int1x1", "Int1x2", "Int1x3", "Int1x4", "Int2x1", 
      "Int2x2", "Int2x3", "Int2x4", "Int3x1", "Int3x2", "Int3x3", "Int3x4", 
      "Int4x1", "Int4x2", "Int4x3", "Int4x4", "Interface", "Line_", "LineAdj", 
      "Linear", "LineStream", "Long", "Matrix", "Nointerpolation", "Noperspective", 
      "Option", "Out", "OutputPatch", "Override", "Partial", "Packoffset", 
      "Point", "PointStream", "Precise", "RasterizerOrderedBuffer", "RasterizerOrderedByteAddressBuffer", 
      "RasterizerOrderedStructuredBuffer", "RasterizerOrderedTexture1D", 
      "RasterizerOrderedTexture1DArray", "RasterizerOrderedTexture2D", "RasterizerOrderedTexture2DArray", 
      "RasterizerOrderedTexture3D", "RayDesc", "RaytracingAccelerationStructure", 
      "Register", "Return", "RowMajor", "RWBuffer", "RWByteAddressBuffer", 
      "RWStructuredBuffer", "RWTexture1D", "RWTexture1DArray", "RWTexture2D", 
      "RWTexture2DArray", "RWTexture3D", "Sample", "Sampler", "SamplerCapitalS", 
      "SamplerComparisonState", "SamplerStateCamel", "SamplerState", "Shared", 
      "SNorm", "Static", "Struct", "StructuredBuffer", "SubpassInput", "SubpassInputMS", 
      "SubpassInputDS", "SubpassInputDSMS", "Switch", "TBuffer", "Texture1D", 
      "Texture1DArray", "Texture2D", "Texture2DArray", "Texture2DMS", "Texture2DMSArray", 
      "Texture3D", "TextureCube", "TextureCubeArray", "Triangle", "TriangleAdj", 
      "TriangleStream", "Uniform", "Uint", "Uint1", "Uint2", "Uint3", "Uint4", 
      "Uint1x1", "Uint1x2", "Uint1x3", "Uint1x4", "Uint2x1", "Uint2x2", 
      "Uint2x3", "Uint2x4", "Uint3x1", "Uint3x2", "Uint3x3", "Uint3x4", 
      "Uint4x1", "Uint4x2", "Uint4x3", "Uint4x4", "Uint16_t", "Uint32_t", 
      "Uint64_t", "UNorm", "Unsigned", "Dword", "Dword1", "Dword2", "Dword3", 
      "Dword4", "Dword1x1", "Dword1x2", "Dword1x3", "Dword1x4", "Dword2x1", 
      "Dword2x2", "Dword2x3", "Dword2x4", "Dword3x1", "Dword3x2", "Dword3x3", 
      "Dword3x4", "Dword4x1", "Dword4x2", "Dword4x3", "Dword4x4", "Vector", 
      "Volatile", "Void", "While", "StateObjectConfig", "LocalRootSignature", 
      "GlobalRootSignature", "SubobjectToExportsAssociation", "RaytracingShaderConfig", 
      "RaytracingPipelineConfig", "RaytracingPipelineConfig1", "TriangleHitGroup", 
      "ProceduralPrimitiveHitGroup", "ADDRESS_U", "ADDRESS_V", "ADDRESS_W", 
      "BORDER_COLOR", "MIN_FILTER", "MAG_FILTER", "MIP_FILTER", "MAX_ANISOTROPY", 
      "MAX_LOD", "MIN_LOD", "MIP_LOD_BIAS", "COMPARISON_FUNC", "REDUCTION_TYPE", 
      "FILTER_MODE_POINT", "FILTER_MODE_LINEAR", "REDUCTION_TYPE_FILTER", 
      "REDUCTION_TYPE_COMPARISON", "REDUCTION_TYPE_MINIMUM", "REDUCTION_TYPE_MAXIMUM", 
      "ADDRESS_MODE_WRAP", "ADDRESS_MODE_MIRROR", "ADDRESS_MODE_CLAMP", 
      "ADDRESS_MODE_BORDER", "ADDRESS_MODE_MIRROR_ONCE", "COMPARISON_FUNCTION_NEVER", 
      "COMPARISON_FUNCTION_LESS", "COMPARISON_FUNCTION_EQUAL", "COMPARISON_FUNCTION_LESS_EQUAL", 
      "COMPARISON_FUNCTION_GREATER", "COMPARISON_FUNCTION_NOT_EQUAL", "COMPARISON_FUNCTION_GREATER_EQUAL", 
      "COMPARISON_FUNCTION_ALWAYS", "BORDER_COLOR_OPAQUE_BLACK", "BORDER_COLOR_TRANSPARENT_BLACK", 
      "BORDER_COLOR_OPAQUE_WHITE", "LeftParen", "RightParen", "LeftBracket", 
      "RightBracket", "LeftBrace", "RightBrace", "LeftDoubleBracket", "Less", 
      "LessEqual", "Greater", "GreaterEqual", "LeftShift", "RightShift", 
      "Plus", "PlusPlus", "Minus", "MinusMinus", "Star", "Div", "Mod", "And", 
      "Or", "AndAnd", "OrOr", "Caret", "Not", "Tilde", "Question", "Colon", 
      "ColonColon", "Semi", "Comma", "Assign", "StarAssign", "DivAssign", 
      "ModAssign", "PlusAssign", "MinusAssign", "LeftShiftAssign", "RightShiftAssign", 
      "AndAssign", "XorAssign", "OrAssign", "Equal", "NotEqual", "Dot", 
      "True", "False", "KW_AssociatedType", "KW_TypeAlias", "KW_Typedef", 
      "KW_Fundamental", "KW_Typeof", "FrequencyId", "ShaderVariantFallback", 
      "ShaderResourceGroupSemantic", "ShaderResourceGroup", "KW_ext_print_message", 
      "KW_ext_print_symbol", "KW_ext_prtsym_fully_qualified", "KW_ext_prtsym_least_qualified", 
      "KW_ext_prtsym_constint_value", "HLSLSemanticStream", "HLSLSemanticSystem", 
      "Identifier", "IntegerLiteral", "FloatLiteral", "StringLiteral", "PragmaDirective", 
      "LineDirective", "Whitespace", "Newline", "BlockComment", "LineComment"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,380,1286,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,1,0,
  	5,0,282,8,0,10,0,12,0,285,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  	1,1,1,1,3,1,299,8,1,1,2,1,2,3,2,303,8,2,1,3,1,3,1,4,1,4,1,4,1,5,3,5,311,
  	8,5,1,5,1,5,5,5,315,8,5,10,5,12,5,318,9,5,1,6,1,6,1,6,1,7,1,7,1,7,3,7,
  	326,8,7,1,7,1,7,5,7,330,8,7,10,7,12,7,333,9,7,1,7,1,7,1,8,1,8,1,8,1,8,
  	5,8,341,8,8,10,8,12,8,344,9,8,1,9,1,9,1,9,1,9,1,9,1,9,3,9,352,8,9,1,10,
  	1,10,1,10,1,11,1,11,1,11,1,11,5,11,361,8,11,10,11,12,11,364,9,11,1,11,
  	1,11,1,12,1,12,1,12,1,12,1,12,1,12,3,12,374,8,12,1,13,5,13,377,8,13,10,
  	13,12,13,380,9,13,1,13,1,13,1,13,1,14,1,14,1,14,1,15,1,15,1,15,1,15,3,
  	15,392,8,15,1,15,1,15,1,16,1,16,1,16,3,16,399,8,16,1,17,1,17,1,17,5,17,
  	404,8,17,10,17,12,17,407,9,17,1,17,3,17,410,8,17,1,18,1,18,1,18,3,18,
  	415,8,18,1,19,1,19,1,19,1,19,3,19,421,8,19,1,20,1,20,1,20,1,21,1,21,1,
  	21,1,21,5,21,430,8,21,10,21,12,21,433,9,21,1,21,1,21,1,22,1,22,1,22,3,
  	22,440,8,22,1,23,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,25,1,25,1,25,1,
  	25,5,25,454,8,25,10,25,12,25,457,9,25,3,25,459,8,25,1,26,5,26,462,8,26,
  	10,26,12,26,465,9,26,1,26,1,26,3,26,469,8,26,1,26,1,26,1,27,1,27,1,27,
  	1,28,1,28,1,29,1,29,1,29,5,29,481,8,29,10,29,12,29,484,9,29,1,30,1,30,
  	1,30,1,30,1,31,1,31,1,31,1,31,3,31,494,8,31,1,31,1,31,3,31,498,8,31,1,
  	31,1,31,3,31,502,8,31,1,31,1,31,3,31,506,8,31,3,31,508,8,31,1,32,1,32,
  	1,32,1,32,1,33,1,33,1,33,1,33,5,33,518,8,33,10,33,12,33,521,9,33,1,33,
  	1,33,1,33,1,34,1,34,3,34,528,8,34,1,35,1,35,5,35,532,8,35,10,35,12,35,
  	535,9,35,1,35,1,35,1,36,1,36,1,36,3,36,542,8,36,1,37,1,37,3,37,546,8,
  	37,1,38,1,38,1,38,1,38,1,38,1,38,3,38,554,8,38,1,39,4,39,557,8,39,11,
  	39,12,39,558,1,39,4,39,562,8,39,11,39,12,39,563,1,40,1,40,5,40,568,8,
  	40,10,40,12,40,571,9,40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,1,41,5,41,
  	581,8,41,10,41,12,41,584,9,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,592,
  	8,41,1,41,5,41,595,8,41,10,41,12,41,598,9,41,1,41,1,41,1,41,1,41,1,41,
  	1,41,1,41,5,41,607,8,41,10,41,12,41,610,9,41,1,41,1,41,1,41,1,41,1,41,
  	1,41,1,41,5,41,619,8,41,10,41,12,41,622,9,41,1,41,1,41,1,41,1,41,1,41,
  	1,41,1,41,1,41,1,41,5,41,633,8,41,10,41,12,41,636,9,41,1,41,1,41,1,41,
  	3,41,641,8,41,1,41,1,41,3,41,645,8,41,1,41,1,41,3,41,649,8,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,661,8,41,1,41,1,41,1,
  	41,3,41,666,8,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,
  	43,1,43,1,43,1,43,1,43,1,43,5,43,684,8,43,10,43,12,43,687,9,43,1,43,1,
  	43,1,43,1,43,1,43,1,43,3,43,695,8,43,1,43,1,43,1,43,1,43,1,43,1,43,1,
  	43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,
  	43,1,43,1,43,1,43,1,43,1,43,5,43,723,8,43,10,43,12,43,726,9,43,1,44,1,
  	44,1,44,1,44,1,44,1,44,5,44,734,8,44,10,44,12,44,737,9,44,1,45,1,45,1,
  	46,1,46,1,47,1,47,1,48,1,48,1,49,1,49,3,49,749,8,49,1,49,1,49,1,50,1,
  	50,1,50,5,50,756,8,50,10,50,12,50,759,9,50,1,51,5,51,762,8,51,10,51,12,
  	51,765,9,51,1,51,1,51,1,51,1,52,1,52,1,52,5,52,773,8,52,10,52,12,52,776,
  	9,52,1,53,5,53,779,8,53,10,53,12,53,782,9,53,1,53,3,53,785,8,53,1,53,
  	3,53,788,8,53,1,53,3,53,791,8,53,1,53,3,53,794,8,53,1,54,1,54,1,54,1,
  	55,1,55,1,55,3,55,802,8,55,1,56,1,56,1,56,1,56,1,56,3,56,809,8,56,1,57,
  	1,57,1,57,5,57,814,8,57,10,57,12,57,817,9,57,1,57,3,57,820,8,57,1,58,
  	1,58,3,58,824,8,58,1,58,1,58,1,59,1,59,1,59,1,59,1,59,1,59,3,59,834,8,
  	59,1,59,1,59,1,60,5,60,839,8,60,10,60,12,60,842,9,60,1,61,1,61,1,62,1,
  	62,1,62,1,62,1,62,3,62,851,8,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,
  	63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,873,
  	8,63,1,64,1,64,1,65,1,65,1,66,1,66,1,67,1,67,1,67,1,67,1,67,1,68,1,68,
  	1,69,1,69,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,71,1,71,1,72,1,72,1,73,
  	1,73,1,74,1,74,1,74,1,74,1,74,1,75,1,75,1,76,1,76,1,76,1,76,1,76,1,77,
  	1,77,1,78,1,78,1,79,1,79,1,80,1,80,1,80,1,80,1,80,1,81,1,81,1,82,1,82,
  	1,82,1,82,1,82,3,82,933,8,82,1,82,1,82,1,83,1,83,1,84,1,84,1,85,1,85,
  	1,85,1,85,1,85,1,86,1,86,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,88,1,88,
  	3,88,957,8,88,1,89,1,89,1,89,3,89,962,8,89,1,90,1,90,1,91,1,91,1,91,1,
  	91,1,91,1,91,1,91,1,91,1,91,1,92,1,92,1,92,1,92,1,92,1,92,1,93,1,93,1,
  	93,1,93,1,93,1,94,1,94,1,94,1,94,1,94,4,94,991,8,94,11,94,12,94,992,3,
  	94,995,8,94,1,95,1,95,1,95,1,95,3,95,1001,8,95,1,95,1,95,3,95,1005,8,
  	95,1,95,1,95,3,95,1009,8,95,1,95,1,95,3,95,1013,8,95,1,95,3,95,1016,8,
  	95,1,96,1,96,1,96,1,97,1,97,1,97,1,98,1,98,3,98,1026,8,98,1,99,1,99,1,
  	99,3,99,1031,8,99,1,99,1,99,1,100,1,100,1,100,1,100,1,100,1,101,1,101,
  	1,101,1,101,1,101,1,101,1,102,1,102,3,102,1048,8,102,1,103,1,103,1,103,
  	1,103,3,103,1054,8,103,1,103,1,103,1,103,3,103,1059,8,103,1,104,1,104,
  	1,104,1,104,5,104,1065,8,104,10,104,12,104,1068,9,104,1,104,1,104,1,105,
  	1,105,3,105,1074,8,105,1,106,1,106,1,106,1,107,1,107,1,108,1,108,1,109,
  	5,109,1084,8,109,10,109,12,109,1087,9,109,1,109,1,109,1,110,1,110,1,111,
  	5,111,1094,8,111,10,111,12,111,1097,9,111,1,111,1,111,1,112,1,112,1,112,
  	1,112,1,112,1,112,1,112,1,112,1,112,3,112,1110,8,112,1,112,1,112,1,112,
  	1,112,1,112,3,112,1117,8,112,1,113,3,113,1120,8,113,1,113,1,113,1,113,
  	1,113,3,113,1126,8,113,1,113,1,113,5,113,1130,8,113,10,113,12,113,1133,
  	9,113,1,113,1,113,1,114,5,114,1138,8,114,10,114,12,114,1141,9,114,1,114,
  	1,114,1,115,1,115,1,115,1,115,1,115,1,115,1,115,3,115,1152,8,115,1,116,
  	1,116,1,116,1,116,1,117,5,117,1159,8,117,10,117,12,117,1162,9,117,1,117,
  	1,117,1,118,1,118,5,118,1168,8,118,10,118,12,118,1171,9,118,1,118,1,118,
  	1,119,1,119,1,119,1,119,1,119,1,119,1,119,1,119,1,119,1,119,3,119,1185,
  	8,119,1,120,1,120,5,120,1189,8,120,10,120,12,120,1192,9,120,1,120,1,120,
  	1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,
  	1,121,3,121,1209,8,121,1,122,1,122,1,122,1,122,1,122,1,123,1,123,1,123,
  	1,123,1,123,1,124,1,124,1,124,1,124,1,124,1,125,1,125,1,125,1,125,1,125,
  	1,126,1,126,1,126,1,126,1,126,1,127,1,127,1,127,1,127,1,127,1,128,1,128,
  	1,128,1,128,1,128,1,129,1,129,1,129,1,129,1,129,1,130,1,130,1,130,1,130,
  	1,130,1,131,1,131,1,131,1,131,1,131,1,132,1,132,1,132,1,132,1,132,1,133,
  	1,133,1,133,1,133,1,133,1,134,1,134,1,134,1,134,1,134,1,135,1,135,1,136,
  	1,136,1,137,1,137,1,138,1,138,1,139,1,139,1,139,1,840,2,86,88,140,0,2,
  	4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
  	52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,
  	98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,
  	134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,
  	170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,
  	206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,
  	242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,
  	278,0,28,2,0,32,32,191,191,1,0,30,31,1,0,369,371,2,0,321,321,323,323,
  	2,0,320,323,332,333,4,0,314,320,322,322,324,331,350,351,1,0,339,349,17,
  	0,29,29,33,34,64,64,89,90,114,117,144,146,150,153,158,158,160,160,173,
  	173,182,182,188,190,208,209,211,211,236,237,260,260,371,371,1,0,263,271,
  	2,0,24,24,169,169,3,0,23,23,161,161,174,174,3,0,25,25,162,162,175,175,
  	2,0,118,118,154,154,1,0,183,187,8,0,2,2,40,40,67,67,92,92,119,122,212,
  	212,233,235,238,238,3,0,147,147,159,159,210,210,5,0,1,1,35,35,163,163,
  	176,176,192,192,4,0,164,168,177,181,199,202,205,207,1,0,203,204,1,0,193,
  	196,8,0,3,6,41,44,68,71,93,96,123,126,213,216,239,242,259,259,8,0,7,22,
  	45,60,72,87,97,112,127,142,149,149,217,232,243,258,1,0,366,368,1,0,285,
  	286,1,0,287,290,1,0,291,295,1,0,296,303,1,0,304,306,1330,0,283,1,0,0,
  	0,2,298,1,0,0,0,4,302,1,0,0,0,6,304,1,0,0,0,8,306,1,0,0,0,10,310,1,0,
  	0,0,12,319,1,0,0,0,14,322,1,0,0,0,16,336,1,0,0,0,18,351,1,0,0,0,20,353,
  	1,0,0,0,22,356,1,0,0,0,24,373,1,0,0,0,26,378,1,0,0,0,28,384,1,0,0,0,30,
  	387,1,0,0,0,32,398,1,0,0,0,34,400,1,0,0,0,36,411,1,0,0,0,38,420,1,0,0,
  	0,40,422,1,0,0,0,42,425,1,0,0,0,44,439,1,0,0,0,46,441,1,0,0,0,48,446,
  	1,0,0,0,50,458,1,0,0,0,52,463,1,0,0,0,54,472,1,0,0,0,56,475,1,0,0,0,58,
  	477,1,0,0,0,60,485,1,0,0,0,62,507,1,0,0,0,64,509,1,0,0,0,66,513,1,0,0,
  	0,68,527,1,0,0,0,70,529,1,0,0,0,72,541,1,0,0,0,74,545,1,0,0,0,76,553,
  	1,0,0,0,78,556,1,0,0,0,80,565,1,0,0,0,82,665,1,0,0,0,84,667,1,0,0,0,86,
  	694,1,0,0,0,88,727,1,0,0,0,90,738,1,0,0,0,92,740,1,0,0,0,94,742,1,0,0,
  	0,96,744,1,0,0,0,98,746,1,0,0,0,100,752,1,0,0,0,102,763,1,0,0,0,104,769,
  	1,0,0,0,106,780,1,0,0,0,108,795,1,0,0,0,110,801,1,0,0,0,112,808,1,0,0,
  	0,114,810,1,0,0,0,116,821,1,0,0,0,118,827,1,0,0,0,120,840,1,0,0,0,122,
  	843,1,0,0,0,124,845,1,0,0,0,126,872,1,0,0,0,128,874,1,0,0,0,130,876,1,
  	0,0,0,132,878,1,0,0,0,134,880,1,0,0,0,136,885,1,0,0,0,138,887,1,0,0,0,
  	140,889,1,0,0,0,142,896,1,0,0,0,144,898,1,0,0,0,146,900,1,0,0,0,148,902,
  	1,0,0,0,150,907,1,0,0,0,152,909,1,0,0,0,154,914,1,0,0,0,156,916,1,0,0,
  	0,158,918,1,0,0,0,160,920,1,0,0,0,162,925,1,0,0,0,164,927,1,0,0,0,166,
  	936,1,0,0,0,168,938,1,0,0,0,170,940,1,0,0,0,172,945,1,0,0,0,174,947,1,
  	0,0,0,176,956,1,0,0,0,178,961,1,0,0,0,180,963,1,0,0,0,182,965,1,0,0,0,
  	184,974,1,0,0,0,186,980,1,0,0,0,188,994,1,0,0,0,190,996,1,0,0,0,192,1017,
  	1,0,0,0,194,1020,1,0,0,0,196,1025,1,0,0,0,198,1027,1,0,0,0,200,1034,1,
  	0,0,0,202,1039,1,0,0,0,204,1047,1,0,0,0,206,1049,1,0,0,0,208,1060,1,0,
  	0,0,210,1071,1,0,0,0,212,1075,1,0,0,0,214,1078,1,0,0,0,216,1080,1,0,0,
  	0,218,1085,1,0,0,0,220,1090,1,0,0,0,222,1095,1,0,0,0,224,1116,1,0,0,0,
  	226,1119,1,0,0,0,228,1139,1,0,0,0,230,1151,1,0,0,0,232,1153,1,0,0,0,234,
  	1160,1,0,0,0,236,1165,1,0,0,0,238,1184,1,0,0,0,240,1186,1,0,0,0,242,1208,
  	1,0,0,0,244,1210,1,0,0,0,246,1215,1,0,0,0,248,1220,1,0,0,0,250,1225,1,
  	0,0,0,252,1230,1,0,0,0,254,1235,1,0,0,0,256,1240,1,0,0,0,258,1245,1,0,
  	0,0,260,1250,1,0,0,0,262,1255,1,0,0,0,264,1260,1,0,0,0,266,1265,1,0,0,
  	0,268,1270,1,0,0,0,270,1275,1,0,0,0,272,1277,1,0,0,0,274,1279,1,0,0,0,
  	276,1281,1,0,0,0,278,1283,1,0,0,0,280,282,3,2,1,0,281,280,1,0,0,0,282,
  	285,1,0,0,0,283,281,1,0,0,0,283,284,1,0,0,0,284,286,1,0,0,0,285,283,1,
  	0,0,0,286,287,5,0,0,1,287,1,1,0,0,0,288,299,3,26,13,0,289,299,3,48,24,
  	0,290,299,3,222,111,0,291,299,3,218,109,0,292,299,3,66,33,0,293,299,3,
  	224,112,0,294,299,3,204,102,0,295,299,3,228,114,0,296,299,3,234,117,0,
  	297,299,5,337,0,0,298,288,1,0,0,0,298,289,1,0,0,0,298,290,1,0,0,0,298,
  	291,1,0,0,0,298,292,1,0,0,0,298,293,1,0,0,0,298,294,1,0,0,0,298,295,1,
  	0,0,0,298,296,1,0,0,0,298,297,1,0,0,0,299,3,1,0,0,0,300,303,3,6,3,0,301,
  	303,3,8,4,0,302,300,1,0,0,0,302,301,1,0,0,0,303,5,1,0,0,0,304,305,5,371,
  	0,0,305,7,1,0,0,0,306,307,3,10,5,0,307,308,3,6,3,0,308,9,1,0,0,0,309,
  	311,5,336,0,0,310,309,1,0,0,0,310,311,1,0,0,0,311,316,1,0,0,0,312,313,
  	5,371,0,0,313,315,5,336,0,0,314,312,1,0,0,0,315,318,1,0,0,0,316,314,1,
  	0,0,0,316,317,1,0,0,0,317,11,1,0,0,0,318,316,1,0,0,0,319,320,3,14,7,0,
  	320,321,5,337,0,0,321,13,1,0,0,0,322,323,5,32,0,0,323,325,5,371,0,0,324,
  	326,3,16,8,0,325,324,1,0,0,0,325,326,1,0,0,0,326,327,1,0,0,0,327,331,
  	5,311,0,0,328,330,3,18,9,0,329,328,1,0,0,0,330,333,1,0,0,0,331,329,1,
  	0,0,0,331,332,1,0,0,0,332,334,1,0,0,0,333,331,1,0,0,0,334,335,5,312,0,
  	0,335,15,1,0,0,0,336,337,5,335,0,0,337,342,3,4,2,0,338,339,5,338,0,0,
  	339,341,3,4,2,0,340,338,1,0,0,0,341,344,1,0,0,0,342,340,1,0,0,0,342,343,
  	1,0,0,0,343,17,1,0,0,0,344,342,1,0,0,0,345,352,3,48,24,0,346,352,3,222,
  	111,0,347,352,3,218,109,0,348,352,3,204,102,0,349,352,3,26,13,0,350,352,
  	3,68,34,0,351,345,1,0,0,0,351,346,1,0,0,0,351,347,1,0,0,0,351,348,1,0,
  	0,0,351,349,1,0,0,0,351,350,1,0,0,0,352,19,1,0,0,0,353,354,3,22,11,0,
  	354,355,5,337,0,0,355,21,1,0,0,0,356,357,5,191,0,0,357,358,5,371,0,0,
  	358,362,5,311,0,0,359,361,3,24,12,0,360,359,1,0,0,0,361,364,1,0,0,0,362,
  	360,1,0,0,0,362,363,1,0,0,0,363,365,1,0,0,0,364,362,1,0,0,0,365,366,5,
  	312,0,0,366,23,1,0,0,0,367,374,3,48,24,0,368,374,3,222,111,0,369,374,
  	3,218,109,0,370,374,3,26,13,0,371,374,3,204,102,0,372,374,3,68,34,0,373,
  	367,1,0,0,0,373,368,1,0,0,0,373,369,1,0,0,0,373,370,1,0,0,0,373,371,1,
  	0,0,0,373,372,1,0,0,0,374,25,1,0,0,0,375,377,3,68,34,0,376,375,1,0,0,
  	0,377,380,1,0,0,0,378,376,1,0,0,0,378,379,1,0,0,0,379,381,1,0,0,0,380,
  	378,1,0,0,0,381,382,3,38,19,0,382,383,5,337,0,0,383,27,1,0,0,0,384,385,
  	3,30,15,0,385,386,5,337,0,0,386,29,1,0,0,0,387,388,3,32,16,0,388,389,
  	5,371,0,0,389,391,5,311,0,0,390,392,3,34,17,0,391,390,1,0,0,0,391,392,
  	1,0,0,0,392,393,1,0,0,0,393,394,5,312,0,0,394,31,1,0,0,0,395,399,5,62,
  	0,0,396,397,5,62,0,0,397,399,7,0,0,0,398,395,1,0,0,0,398,396,1,0,0,0,
  	399,33,1,0,0,0,400,405,3,36,18,0,401,402,5,338,0,0,402,404,3,36,18,0,
  	403,401,1,0,0,0,404,407,1,0,0,0,405,403,1,0,0,0,405,406,1,0,0,0,406,409,
  	1,0,0,0,407,405,1,0,0,0,408,410,5,338,0,0,409,408,1,0,0,0,409,410,1,0,
  	0,0,410,35,1,0,0,0,411,414,5,371,0,0,412,413,5,339,0,0,413,415,3,86,43,
  	0,414,412,1,0,0,0,414,415,1,0,0,0,415,37,1,0,0,0,416,421,3,14,7,0,417,
  	421,3,42,21,0,418,421,3,22,11,0,419,421,3,30,15,0,420,416,1,0,0,0,420,
  	417,1,0,0,0,420,418,1,0,0,0,420,419,1,0,0,0,421,39,1,0,0,0,422,423,3,
  	42,21,0,423,424,5,337,0,0,424,41,1,0,0,0,425,426,5,143,0,0,426,427,5,
  	371,0,0,427,431,5,311,0,0,428,430,3,44,22,0,429,428,1,0,0,0,430,433,1,
  	0,0,0,431,429,1,0,0,0,431,432,1,0,0,0,432,434,1,0,0,0,433,431,1,0,0,0,
  	434,435,5,312,0,0,435,43,1,0,0,0,436,440,3,218,109,0,437,440,3,198,99,
  	0,438,440,3,26,13,0,439,436,1,0,0,0,439,437,1,0,0,0,439,438,1,0,0,0,440,
  	45,1,0,0,0,441,442,7,1,0,0,442,443,5,314,0,0,443,444,3,124,62,0,444,445,
  	5,316,0,0,445,47,1,0,0,0,446,447,3,102,51,0,447,448,5,337,0,0,448,49,
  	1,0,0,0,449,459,5,261,0,0,450,455,3,52,26,0,451,452,5,338,0,0,452,454,
  	3,52,26,0,453,451,1,0,0,0,454,457,1,0,0,0,455,453,1,0,0,0,455,456,1,0,
  	0,0,456,459,1,0,0,0,457,455,1,0,0,0,458,449,1,0,0,0,458,450,1,0,0,0,459,
  	51,1,0,0,0,460,462,3,68,34,0,461,460,1,0,0,0,462,465,1,0,0,0,463,461,
  	1,0,0,0,463,464,1,0,0,0,464,466,1,0,0,0,465,463,1,0,0,0,466,468,3,124,
  	62,0,467,469,5,371,0,0,468,467,1,0,0,0,468,469,1,0,0,0,469,470,1,0,0,
  	0,470,471,3,106,53,0,471,53,1,0,0,0,472,473,5,335,0,0,473,474,3,56,28,
  	0,474,55,1,0,0,0,475,476,7,2,0,0,476,57,1,0,0,0,477,482,3,188,94,0,478,
  	479,5,338,0,0,479,481,3,188,94,0,480,478,1,0,0,0,481,484,1,0,0,0,482,
  	480,1,0,0,0,482,483,1,0,0,0,483,59,1,0,0,0,484,482,1,0,0,0,485,486,5,
  	307,0,0,486,487,3,58,29,0,487,488,5,308,0,0,488,61,1,0,0,0,489,490,5,
  	91,0,0,490,493,5,336,0,0,491,492,5,371,0,0,492,494,5,336,0,0,493,491,
  	1,0,0,0,493,494,1,0,0,0,494,495,1,0,0,0,495,497,5,371,0,0,496,498,3,60,
  	30,0,497,496,1,0,0,0,497,498,1,0,0,0,498,508,1,0,0,0,499,500,5,371,0,
  	0,500,502,5,336,0,0,501,499,1,0,0,0,501,502,1,0,0,0,502,503,1,0,0,0,503,
  	505,5,371,0,0,504,506,3,60,30,0,505,504,1,0,0,0,505,506,1,0,0,0,506,508,
  	1,0,0,0,507,489,1,0,0,0,507,501,1,0,0,0,508,63,1,0,0,0,509,510,5,309,
  	0,0,510,511,3,62,31,0,511,512,5,310,0,0,512,65,1,0,0,0,513,514,5,313,
  	0,0,514,519,3,62,31,0,515,516,5,338,0,0,516,518,3,62,31,0,517,515,1,0,
  	0,0,518,521,1,0,0,0,519,517,1,0,0,0,519,520,1,0,0,0,520,522,1,0,0,0,521,
  	519,1,0,0,0,522,523,5,310,0,0,523,524,5,310,0,0,524,67,1,0,0,0,525,528,
  	3,64,32,0,526,528,3,66,33,0,527,525,1,0,0,0,527,526,1,0,0,0,528,69,1,
  	0,0,0,529,533,5,311,0,0,530,532,3,72,36,0,531,530,1,0,0,0,532,535,1,0,
  	0,0,533,531,1,0,0,0,533,534,1,0,0,0,534,536,1,0,0,0,535,533,1,0,0,0,536,
  	537,5,312,0,0,537,71,1,0,0,0,538,542,3,48,24,0,539,542,3,82,41,0,540,
  	542,3,26,13,0,541,538,1,0,0,0,541,539,1,0,0,0,541,540,1,0,0,0,542,73,
  	1,0,0,0,543,546,3,102,51,0,544,546,3,88,44,0,545,543,1,0,0,0,545,544,
  	1,0,0,0,546,75,1,0,0,0,547,548,5,27,0,0,548,549,3,86,43,0,549,550,5,335,
  	0,0,550,554,1,0,0,0,551,552,5,37,0,0,552,554,5,335,0,0,553,547,1,0,0,
  	0,553,551,1,0,0,0,554,77,1,0,0,0,555,557,3,76,38,0,556,555,1,0,0,0,557,
  	558,1,0,0,0,558,556,1,0,0,0,558,559,1,0,0,0,559,561,1,0,0,0,560,562,3,
  	72,36,0,561,560,1,0,0,0,562,563,1,0,0,0,563,561,1,0,0,0,563,564,1,0,0,
  	0,564,79,1,0,0,0,565,569,5,311,0,0,566,568,3,78,39,0,567,566,1,0,0,0,
  	568,571,1,0,0,0,569,567,1,0,0,0,569,570,1,0,0,0,570,572,1,0,0,0,571,569,
  	1,0,0,0,572,573,5,312,0,0,573,81,1,0,0,0,574,666,5,337,0,0,575,666,3,
  	70,35,0,576,577,3,88,44,0,577,578,5,337,0,0,578,666,1,0,0,0,579,581,3,
  	64,32,0,580,579,1,0,0,0,581,584,1,0,0,0,582,580,1,0,0,0,582,583,1,0,0,
  	0,583,585,1,0,0,0,584,582,1,0,0,0,585,586,5,113,0,0,586,587,5,307,0,0,
  	587,588,3,88,44,0,588,589,5,308,0,0,589,591,3,82,41,0,590,592,3,84,42,
  	0,591,590,1,0,0,0,591,592,1,0,0,0,592,666,1,0,0,0,593,595,3,64,32,0,594,
  	593,1,0,0,0,595,598,1,0,0,0,596,594,1,0,0,0,596,597,1,0,0,0,597,599,1,
  	0,0,0,598,596,1,0,0,0,599,600,5,197,0,0,600,601,5,307,0,0,601,602,3,88,
  	44,0,602,603,5,308,0,0,603,604,3,80,40,0,604,666,1,0,0,0,605,607,3,64,
  	32,0,606,605,1,0,0,0,607,610,1,0,0,0,608,606,1,0,0,0,608,609,1,0,0,0,
  	609,611,1,0,0,0,610,608,1,0,0,0,611,612,5,262,0,0,612,613,5,307,0,0,613,
  	614,3,88,44,0,614,615,5,308,0,0,615,616,3,82,41,0,616,666,1,0,0,0,617,
  	619,3,64,32,0,618,617,1,0,0,0,619,622,1,0,0,0,620,618,1,0,0,0,620,621,
  	1,0,0,0,621,623,1,0,0,0,622,620,1,0,0,0,623,624,5,39,0,0,624,625,3,82,
  	41,0,625,626,5,262,0,0,626,627,5,307,0,0,627,628,3,88,44,0,628,629,5,
  	308,0,0,629,630,5,337,0,0,630,666,1,0,0,0,631,633,3,64,32,0,632,631,1,
  	0,0,0,633,636,1,0,0,0,634,632,1,0,0,0,634,635,1,0,0,0,635,637,1,0,0,0,
  	636,634,1,0,0,0,637,638,5,88,0,0,638,640,5,307,0,0,639,641,3,74,37,0,
  	640,639,1,0,0,0,640,641,1,0,0,0,641,642,1,0,0,0,642,644,5,337,0,0,643,
  	645,3,88,44,0,644,643,1,0,0,0,644,645,1,0,0,0,645,646,1,0,0,0,646,648,
  	5,337,0,0,647,649,3,88,44,0,648,647,1,0,0,0,648,649,1,0,0,0,649,650,1,
  	0,0,0,650,651,5,308,0,0,651,666,3,82,41,0,652,653,5,26,0,0,653,666,5,
  	337,0,0,654,655,5,36,0,0,655,666,5,337,0,0,656,657,5,38,0,0,657,666,5,
  	337,0,0,658,660,5,172,0,0,659,661,3,88,44,0,660,659,1,0,0,0,660,661,1,
  	0,0,0,661,662,1,0,0,0,662,666,5,337,0,0,663,666,3,224,112,0,664,666,3,
  	204,102,0,665,574,1,0,0,0,665,575,1,0,0,0,665,576,1,0,0,0,665,582,1,0,
  	0,0,665,596,1,0,0,0,665,608,1,0,0,0,665,620,1,0,0,0,665,634,1,0,0,0,665,
  	652,1,0,0,0,665,654,1,0,0,0,665,656,1,0,0,0,665,658,1,0,0,0,665,663,1,
  	0,0,0,665,664,1,0,0,0,666,83,1,0,0,0,667,668,5,61,0,0,668,669,3,82,41,
  	0,669,85,1,0,0,0,670,671,6,43,-1,0,671,695,3,188,94,0,672,695,3,4,2,0,
  	673,674,5,307,0,0,674,675,3,88,44,0,675,676,5,308,0,0,676,695,1,0,0,0,
  	677,678,3,178,89,0,678,679,3,98,49,0,679,695,1,0,0,0,680,681,5,307,0,
  	0,681,685,3,124,62,0,682,684,3,116,58,0,683,682,1,0,0,0,684,687,1,0,0,
  	0,685,683,1,0,0,0,685,686,1,0,0,0,686,688,1,0,0,0,687,685,1,0,0,0,688,
  	689,5,308,0,0,689,690,3,86,43,6,690,695,1,0,0,0,691,692,3,92,46,0,692,
  	693,3,86,43,4,693,695,1,0,0,0,694,670,1,0,0,0,694,672,1,0,0,0,694,673,
  	1,0,0,0,694,677,1,0,0,0,694,680,1,0,0,0,694,691,1,0,0,0,695,724,1,0,0,
  	0,696,697,10,3,0,0,697,698,3,94,47,0,698,699,3,86,43,4,699,723,1,0,0,
  	0,700,701,10,10,0,0,701,702,5,352,0,0,702,723,3,4,2,0,703,704,10,9,0,
  	0,704,705,5,309,0,0,705,706,3,86,43,0,706,707,5,310,0,0,707,723,1,0,0,
  	0,708,709,10,8,0,0,709,723,3,98,49,0,710,711,10,5,0,0,711,723,3,90,45,
  	0,712,713,10,2,0,0,713,714,5,334,0,0,714,715,3,88,44,0,715,716,5,335,
  	0,0,716,717,3,88,44,0,717,723,1,0,0,0,718,719,10,1,0,0,719,720,3,96,48,
  	0,720,721,3,88,44,0,721,723,1,0,0,0,722,696,1,0,0,0,722,700,1,0,0,0,722,
  	703,1,0,0,0,722,708,1,0,0,0,722,710,1,0,0,0,722,712,1,0,0,0,722,718,1,
  	0,0,0,723,726,1,0,0,0,724,722,1,0,0,0,724,725,1,0,0,0,725,87,1,0,0,0,
  	726,724,1,0,0,0,727,728,6,44,-1,0,728,729,3,86,43,0,729,735,1,0,0,0,730,
  	731,10,1,0,0,731,732,5,338,0,0,732,734,3,86,43,0,733,730,1,0,0,0,734,
  	737,1,0,0,0,735,733,1,0,0,0,735,736,1,0,0,0,736,89,1,0,0,0,737,735,1,
  	0,0,0,738,739,7,3,0,0,739,91,1,0,0,0,740,741,7,4,0,0,741,93,1,0,0,0,742,
  	743,7,5,0,0,743,95,1,0,0,0,744,745,7,6,0,0,745,97,1,0,0,0,746,748,5,307,
  	0,0,747,749,3,100,50,0,748,747,1,0,0,0,748,749,1,0,0,0,749,750,1,0,0,
  	0,750,751,5,308,0,0,751,99,1,0,0,0,752,757,3,86,43,0,753,754,5,338,0,
  	0,754,756,3,86,43,0,755,753,1,0,0,0,756,759,1,0,0,0,757,755,1,0,0,0,757,
  	758,1,0,0,0,758,101,1,0,0,0,759,757,1,0,0,0,760,762,3,68,34,0,761,760,
  	1,0,0,0,762,765,1,0,0,0,763,761,1,0,0,0,763,764,1,0,0,0,764,766,1,0,0,
  	0,765,763,1,0,0,0,766,767,3,124,62,0,767,768,3,104,52,0,768,103,1,0,0,
  	0,769,774,3,108,54,0,770,771,5,338,0,0,771,773,3,108,54,0,772,770,1,0,
  	0,0,773,776,1,0,0,0,774,772,1,0,0,0,774,775,1,0,0,0,775,105,1,0,0,0,776,
  	774,1,0,0,0,777,779,3,116,58,0,778,777,1,0,0,0,779,782,1,0,0,0,780,778,
  	1,0,0,0,780,781,1,0,0,0,781,784,1,0,0,0,782,780,1,0,0,0,783,785,3,54,
  	27,0,784,783,1,0,0,0,784,785,1,0,0,0,785,787,1,0,0,0,786,788,3,118,59,
  	0,787,786,1,0,0,0,787,788,1,0,0,0,788,790,1,0,0,0,789,791,3,184,92,0,
  	790,789,1,0,0,0,790,791,1,0,0,0,791,793,1,0,0,0,792,794,3,110,55,0,793,
  	792,1,0,0,0,793,794,1,0,0,0,794,107,1,0,0,0,795,796,5,371,0,0,796,797,
  	3,106,53,0,797,109,1,0,0,0,798,799,5,339,0,0,799,802,3,112,56,0,800,802,
  	3,240,120,0,801,798,1,0,0,0,801,800,1,0,0,0,802,111,1,0,0,0,803,804,5,
  	311,0,0,804,805,3,114,57,0,805,806,5,312,0,0,806,809,1,0,0,0,807,809,
  	3,86,43,0,808,803,1,0,0,0,808,807,1,0,0,0,809,113,1,0,0,0,810,815,3,112,
  	56,0,811,812,5,338,0,0,812,814,3,112,56,0,813,811,1,0,0,0,814,817,1,0,
  	0,0,815,813,1,0,0,0,815,816,1,0,0,0,816,819,1,0,0,0,817,815,1,0,0,0,818,
  	820,5,338,0,0,819,818,1,0,0,0,819,820,1,0,0,0,820,115,1,0,0,0,821,823,
  	5,309,0,0,822,824,3,86,43,0,823,822,1,0,0,0,823,824,1,0,0,0,824,825,1,
  	0,0,0,825,826,5,310,0,0,826,117,1,0,0,0,827,828,5,335,0,0,828,829,5,157,
  	0,0,829,830,5,307,0,0,830,833,5,371,0,0,831,832,5,352,0,0,832,834,5,371,
  	0,0,833,831,1,0,0,0,833,834,1,0,0,0,834,835,1,0,0,0,835,836,5,308,0,0,
  	836,119,1,0,0,0,837,839,3,122,61,0,838,837,1,0,0,0,839,842,1,0,0,0,840,
  	841,1,0,0,0,840,838,1,0,0,0,841,121,1,0,0,0,842,840,1,0,0,0,843,844,7,
  	7,0,0,844,123,1,0,0,0,845,850,3,120,60,0,846,851,3,126,63,0,847,851,3,
  	196,98,0,848,851,3,206,103,0,849,851,5,261,0,0,850,846,1,0,0,0,850,847,
  	1,0,0,0,850,848,1,0,0,0,850,849,1,0,0,0,851,125,1,0,0,0,852,873,3,134,
  	67,0,853,873,3,138,69,0,854,873,3,140,70,0,855,873,3,180,90,0,856,873,
  	3,182,91,0,857,873,3,144,72,0,858,873,3,146,73,0,859,873,3,148,74,0,860,
  	873,3,152,76,0,861,873,3,158,79,0,862,873,3,160,80,0,863,873,3,170,85,
  	0,864,873,3,164,82,0,865,873,3,168,84,0,866,873,3,172,86,0,867,873,3,
  	174,87,0,868,873,3,46,23,0,869,873,3,130,65,0,870,873,3,128,64,0,871,
  	873,3,132,66,0,872,852,1,0,0,0,872,853,1,0,0,0,872,854,1,0,0,0,872,855,
  	1,0,0,0,872,856,1,0,0,0,872,857,1,0,0,0,872,858,1,0,0,0,872,859,1,0,0,
  	0,872,860,1,0,0,0,872,861,1,0,0,0,872,862,1,0,0,0,872,863,1,0,0,0,872,
  	864,1,0,0,0,872,865,1,0,0,0,872,866,1,0,0,0,872,867,1,0,0,0,872,868,1,
  	0,0,0,872,869,1,0,0,0,872,870,1,0,0,0,872,871,1,0,0,0,873,127,1,0,0,0,
  	874,875,7,8,0,0,875,129,1,0,0,0,876,877,5,170,0,0,877,131,1,0,0,0,878,
  	879,7,9,0,0,879,133,1,0,0,0,880,881,3,136,68,0,881,882,5,314,0,0,882,
  	883,3,178,89,0,883,884,5,316,0,0,884,135,1,0,0,0,885,886,7,10,0,0,886,
  	137,1,0,0,0,887,888,7,11,0,0,888,139,1,0,0,0,889,890,3,142,71,0,890,891,
  	5,314,0,0,891,892,3,196,98,0,892,893,5,338,0,0,893,894,5,372,0,0,894,
  	895,5,316,0,0,895,141,1,0,0,0,896,897,7,12,0,0,897,143,1,0,0,0,898,899,
  	7,13,0,0,899,145,1,0,0,0,900,901,7,14,0,0,901,147,1,0,0,0,902,903,3,150,
  	75,0,903,904,5,314,0,0,904,905,3,124,62,0,905,906,5,316,0,0,906,149,1,
  	0,0,0,907,908,7,15,0,0,908,151,1,0,0,0,909,910,3,154,77,0,910,911,5,314,
  	0,0,911,912,3,124,62,0,912,913,5,316,0,0,913,153,1,0,0,0,914,915,7,16,
  	0,0,915,155,1,0,0,0,916,917,7,17,0,0,917,157,1,0,0,0,918,919,3,156,78,
  	0,919,159,1,0,0,0,920,921,3,156,78,0,921,922,5,314,0,0,922,923,3,176,
  	88,0,923,924,5,316,0,0,924,161,1,0,0,0,925,926,7,18,0,0,926,163,1,0,0,
  	0,927,928,3,162,81,0,928,929,5,314,0,0,929,932,3,176,88,0,930,931,5,338,
  	0,0,931,933,5,372,0,0,932,930,1,0,0,0,932,933,1,0,0,0,933,934,1,0,0,0,
  	934,935,5,316,0,0,935,165,1,0,0,0,936,937,7,19,0,0,937,167,1,0,0,0,938,
  	939,3,166,83,0,939,169,1,0,0,0,940,941,3,166,83,0,941,942,5,314,0,0,942,
  	943,3,176,88,0,943,944,5,316,0,0,944,171,1,0,0,0,945,946,7,20,0,0,946,
  	173,1,0,0,0,947,948,5,259,0,0,948,949,5,314,0,0,949,950,3,146,73,0,950,
  	951,5,338,0,0,951,952,5,372,0,0,952,953,5,316,0,0,953,175,1,0,0,0,954,
  	957,3,146,73,0,955,957,3,172,86,0,956,954,1,0,0,0,956,955,1,0,0,0,957,
  	177,1,0,0,0,958,962,3,146,73,0,959,962,3,172,86,0,960,962,3,180,90,0,
  	961,958,1,0,0,0,961,959,1,0,0,0,961,960,1,0,0,0,962,179,1,0,0,0,963,964,
  	7,21,0,0,964,181,1,0,0,0,965,966,5,149,0,0,966,967,5,314,0,0,967,968,
  	3,146,73,0,968,969,5,338,0,0,969,970,5,372,0,0,970,971,5,338,0,0,971,
  	972,5,372,0,0,972,973,5,316,0,0,973,183,1,0,0,0,974,975,5,335,0,0,975,
  	976,5,171,0,0,976,977,5,307,0,0,977,978,5,371,0,0,978,979,5,308,0,0,979,
  	185,1,0,0,0,980,981,5,371,0,0,981,982,5,339,0,0,982,983,3,86,43,0,983,
  	984,5,337,0,0,984,187,1,0,0,0,985,995,5,353,0,0,986,995,5,354,0,0,987,
  	995,5,373,0,0,988,995,5,372,0,0,989,991,5,374,0,0,990,989,1,0,0,0,991,
  	992,1,0,0,0,992,990,1,0,0,0,992,993,1,0,0,0,993,995,1,0,0,0,994,985,1,
  	0,0,0,994,986,1,0,0,0,994,987,1,0,0,0,994,988,1,0,0,0,994,990,1,0,0,0,
  	995,189,1,0,0,0,996,1000,3,124,62,0,997,998,3,196,98,0,998,999,5,336,
  	0,0,999,1001,1,0,0,0,1000,997,1,0,0,0,1000,1001,1,0,0,0,1001,1002,1,0,
  	0,0,1002,1004,5,371,0,0,1003,1005,3,208,104,0,1004,1003,1,0,0,0,1004,
  	1005,1,0,0,0,1005,1006,1,0,0,0,1006,1008,5,307,0,0,1007,1009,3,50,25,
  	0,1008,1007,1,0,0,0,1008,1009,1,0,0,0,1009,1010,1,0,0,0,1010,1012,5,308,
  	0,0,1011,1013,5,155,0,0,1012,1011,1,0,0,0,1012,1013,1,0,0,0,1013,1015,
  	1,0,0,0,1014,1016,3,54,27,0,1015,1014,1,0,0,0,1015,1016,1,0,0,0,1016,
  	191,1,0,0,0,1017,1018,3,190,95,0,1018,1019,3,70,35,0,1019,193,1,0,0,0,
  	1020,1021,3,190,95,0,1021,1022,5,337,0,0,1022,195,1,0,0,0,1023,1026,3,
  	4,2,0,1024,1026,3,38,19,0,1025,1023,1,0,0,0,1025,1024,1,0,0,0,1026,197,
  	1,0,0,0,1027,1028,5,355,0,0,1028,1030,5,371,0,0,1029,1031,3,212,106,0,
  	1030,1029,1,0,0,0,1030,1031,1,0,0,0,1031,1032,1,0,0,0,1032,1033,5,337,
  	0,0,1033,199,1,0,0,0,1034,1035,5,357,0,0,1035,1036,3,124,62,0,1036,1037,
  	5,371,0,0,1037,1038,5,337,0,0,1038,201,1,0,0,0,1039,1040,5,356,0,0,1040,
  	1041,5,371,0,0,1041,1042,5,339,0,0,1042,1043,3,124,62,0,1043,1044,5,337,
  	0,0,1044,203,1,0,0,0,1045,1048,3,202,101,0,1046,1048,3,200,100,0,1047,
  	1045,1,0,0,0,1047,1046,1,0,0,0,1048,205,1,0,0,0,1049,1050,5,359,0,0,1050,
  	1053,5,307,0,0,1051,1054,3,88,44,0,1052,1054,3,124,62,0,1053,1051,1,0,
  	0,0,1053,1052,1,0,0,0,1054,1055,1,0,0,0,1055,1058,5,308,0,0,1056,1057,
  	5,336,0,0,1057,1059,3,4,2,0,1058,1056,1,0,0,0,1058,1059,1,0,0,0,1059,
  	207,1,0,0,0,1060,1061,5,314,0,0,1061,1066,3,210,105,0,1062,1063,5,338,
  	0,0,1063,1065,3,210,105,0,1064,1062,1,0,0,0,1065,1068,1,0,0,0,1066,1064,
  	1,0,0,0,1066,1067,1,0,0,0,1067,1069,1,0,0,0,1068,1066,1,0,0,0,1069,1070,
  	5,316,0,0,1070,209,1,0,0,0,1071,1073,5,371,0,0,1072,1074,3,212,106,0,
  	1073,1072,1,0,0,0,1073,1074,1,0,0,0,1074,211,1,0,0,0,1075,1076,5,335,
  	0,0,1076,1077,3,196,98,0,1077,213,1,0,0,0,1078,1079,5,358,0,0,1079,215,
  	1,0,0,0,1080,1081,3,194,97,0,1081,217,1,0,0,0,1082,1084,3,68,34,0,1083,
  	1082,1,0,0,0,1084,1087,1,0,0,0,1085,1083,1,0,0,0,1085,1086,1,0,0,0,1086,
  	1088,1,0,0,0,1087,1085,1,0,0,0,1088,1089,3,216,108,0,1089,219,1,0,0,0,
  	1090,1091,3,192,96,0,1091,221,1,0,0,0,1092,1094,3,68,34,0,1093,1092,1,
  	0,0,0,1094,1097,1,0,0,0,1095,1093,1,0,0,0,1095,1096,1,0,0,0,1096,1098,
  	1,0,0,0,1097,1095,1,0,0,0,1098,1099,3,220,110,0,1099,223,1,0,0,0,1100,
  	1101,5,364,0,0,1101,1102,5,307,0,0,1102,1103,5,374,0,0,1103,1104,5,308,
  	0,0,1104,1117,5,337,0,0,1105,1106,5,365,0,0,1106,1109,5,307,0,0,1107,
  	1110,3,4,2,0,1108,1110,3,206,103,0,1109,1107,1,0,0,0,1109,1108,1,0,0,
  	0,1110,1111,1,0,0,0,1111,1112,5,338,0,0,1112,1113,7,22,0,0,1113,1114,
  	5,308,0,0,1114,1115,5,337,0,0,1115,1117,1,0,0,0,1116,1100,1,0,0,0,1116,
  	1105,1,0,0,0,1117,225,1,0,0,0,1118,1120,5,156,0,0,1119,1118,1,0,0,0,1119,
  	1120,1,0,0,0,1120,1121,1,0,0,0,1121,1122,5,363,0,0,1122,1125,5,371,0,
  	0,1123,1124,5,335,0,0,1124,1126,5,371,0,0,1125,1123,1,0,0,0,1125,1126,
  	1,0,0,0,1126,1127,1,0,0,0,1127,1131,5,311,0,0,1128,1130,3,230,115,0,1129,
  	1128,1,0,0,0,1130,1133,1,0,0,0,1131,1129,1,0,0,0,1131,1132,1,0,0,0,1132,
  	1134,1,0,0,0,1133,1131,1,0,0,0,1134,1135,5,312,0,0,1135,227,1,0,0,0,1136,
  	1138,3,68,34,0,1137,1136,1,0,0,0,1138,1141,1,0,0,0,1139,1137,1,0,0,0,
  	1139,1140,1,0,0,0,1140,1142,1,0,0,0,1141,1139,1,0,0,0,1142,1143,3,226,
  	113,0,1143,229,1,0,0,0,1144,1152,3,20,10,0,1145,1152,3,218,109,0,1146,
  	1152,3,222,111,0,1147,1152,3,48,24,0,1148,1152,3,28,14,0,1149,1152,3,
  	204,102,0,1150,1152,3,68,34,0,1151,1144,1,0,0,0,1151,1145,1,0,0,0,1151,
  	1146,1,0,0,0,1151,1147,1,0,0,0,1151,1148,1,0,0,0,1151,1149,1,0,0,0,1151,
  	1150,1,0,0,0,1152,231,1,0,0,0,1153,1154,5,362,0,0,1154,1155,5,371,0,0,
  	1155,1156,3,236,118,0,1156,233,1,0,0,0,1157,1159,3,68,34,0,1158,1157,
  	1,0,0,0,1159,1162,1,0,0,0,1160,1158,1,0,0,0,1160,1161,1,0,0,0,1161,1163,
  	1,0,0,0,1162,1160,1,0,0,0,1163,1164,3,232,116,0,1164,235,1,0,0,0,1165,
  	1169,5,311,0,0,1166,1168,3,238,119,0,1167,1166,1,0,0,0,1168,1171,1,0,
  	0,0,1169,1167,1,0,0,0,1169,1170,1,0,0,0,1170,1172,1,0,0,0,1171,1169,1,
  	0,0,0,1172,1173,5,312,0,0,1173,237,1,0,0,0,1174,1175,5,360,0,0,1175,1176,
  	5,339,0,0,1176,1177,3,188,94,0,1177,1178,5,337,0,0,1178,1185,1,0,0,0,
  	1179,1180,5,361,0,0,1180,1181,5,339,0,0,1181,1182,3,188,94,0,1182,1183,
  	5,337,0,0,1183,1185,1,0,0,0,1184,1174,1,0,0,0,1184,1179,1,0,0,0,1185,
  	239,1,0,0,0,1186,1190,5,311,0,0,1187,1189,3,242,121,0,1188,1187,1,0,0,
  	0,1189,1192,1,0,0,0,1190,1188,1,0,0,0,1190,1191,1,0,0,0,1191,1193,1,0,
  	0,0,1192,1190,1,0,0,0,1193,1194,5,312,0,0,1194,241,1,0,0,0,1195,1209,
  	3,244,122,0,1196,1209,3,246,123,0,1197,1209,3,248,124,0,1198,1209,3,250,
  	125,0,1199,1209,3,252,126,0,1200,1209,3,254,127,0,1201,1209,3,256,128,
  	0,1202,1209,3,258,129,0,1203,1209,3,260,130,0,1204,1209,3,262,131,0,1205,
  	1209,3,264,132,0,1206,1209,3,266,133,0,1207,1209,3,268,134,0,1208,1195,
  	1,0,0,0,1208,1196,1,0,0,0,1208,1197,1,0,0,0,1208,1198,1,0,0,0,1208,1199,
  	1,0,0,0,1208,1200,1,0,0,0,1208,1201,1,0,0,0,1208,1202,1,0,0,0,1208,1203,
  	1,0,0,0,1208,1204,1,0,0,0,1208,1205,1,0,0,0,1208,1206,1,0,0,0,1208,1207,
  	1,0,0,0,1209,243,1,0,0,0,1210,1211,5,279,0,0,1211,1212,5,339,0,0,1212,
  	1213,5,372,0,0,1213,1214,5,337,0,0,1214,245,1,0,0,0,1215,1216,5,276,0,
  	0,1216,1217,5,339,0,0,1217,1218,3,270,135,0,1218,1219,5,337,0,0,1219,
  	247,1,0,0,0,1220,1221,5,277,0,0,1221,1222,5,339,0,0,1222,1223,3,270,135,
  	0,1223,1224,5,337,0,0,1224,249,1,0,0,0,1225,1226,5,278,0,0,1226,1227,
  	5,339,0,0,1227,1228,3,270,135,0,1228,1229,5,337,0,0,1229,251,1,0,0,0,
  	1230,1231,5,284,0,0,1231,1232,5,339,0,0,1232,1233,3,272,136,0,1233,1234,
  	5,337,0,0,1234,253,1,0,0,0,1235,1236,5,283,0,0,1236,1237,5,339,0,0,1237,
  	1238,3,276,138,0,1238,1239,5,337,0,0,1239,255,1,0,0,0,1240,1241,5,272,
  	0,0,1241,1242,5,339,0,0,1242,1243,3,274,137,0,1243,1244,5,337,0,0,1244,
  	257,1,0,0,0,1245,1246,5,273,0,0,1246,1247,5,339,0,0,1247,1248,3,274,137,
  	0,1248,1249,5,337,0,0,1249,259,1,0,0,0,1250,1251,5,274,0,0,1251,1252,
  	5,339,0,0,1252,1253,3,274,137,0,1253,1254,5,337,0,0,1254,261,1,0,0,0,
  	1255,1256,5,281,0,0,1256,1257,5,339,0,0,1257,1258,5,373,0,0,1258,1259,
  	5,337,0,0,1259,263,1,0,0,0,1260,1261,5,280,0,0,1261,1262,5,339,0,0,1262,
  	1263,5,373,0,0,1263,1264,5,337,0,0,1264,265,1,0,0,0,1265,1266,5,282,0,
  	0,1266,1267,5,339,0,0,1267,1268,5,373,0,0,1268,1269,5,337,0,0,1269,267,
  	1,0,0,0,1270,1271,5,275,0,0,1271,1272,5,339,0,0,1272,1273,3,278,139,0,
  	1273,1274,5,337,0,0,1274,269,1,0,0,0,1275,1276,7,23,0,0,1276,271,1,0,
  	0,0,1277,1278,7,24,0,0,1278,273,1,0,0,0,1279,1280,7,25,0,0,1280,275,1,
  	0,0,0,1281,1282,7,26,0,0,1282,277,1,0,0,0,1283,1284,7,27,0,0,1284,279,
  	1,0,0,0,104,283,298,302,310,316,325,331,342,351,362,373,378,391,398,405,
  	409,414,420,431,439,455,458,463,468,482,493,497,501,505,507,519,527,533,
  	541,545,553,558,563,569,582,591,596,608,620,634,640,644,648,660,665,685,
  	694,722,724,735,748,757,763,774,780,784,787,790,793,801,808,815,819,823,
  	833,840,850,872,932,956,961,992,994,1000,1004,1008,1012,1015,1025,1030,
  	1047,1053,1058,1066,1073,1085,1095,1109,1116,1119,1125,1131,1139,1151,
  	1160,1169,1184,1190,1208
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  azslparserParserStaticData = std::move(staticData);
}

}

azslParser::azslParser(TokenStream *input) : azslParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

azslParser::azslParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  azslParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *azslparserParserStaticData->atn, azslparserParserStaticData->decisionToDFA, azslparserParserStaticData->sharedContextCache, options);
}

azslParser::~azslParser() {
  delete _interpreter;
}

const atn::ATN& azslParser::getATN() const {
  return *azslparserParserStaticData->atn;
}

std::string azslParser::getGrammarFileName() const {
  return "azslParser.g4";
}

const std::vector<std::string>& azslParser::getRuleNames() const {
  return azslparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& azslParser::getVocabulary() const {
  return azslparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView azslParser::getSerializedATN() const {
  return azslparserParserStaticData->serializedATN;
}


//----------------- CompilationUnitContext ------------------------------------------------------------------

azslParser::CompilationUnitContext::CompilationUnitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::CompilationUnitContext::EOF() {
  return getToken(azslParser::EOF, 0);
}

std::vector<azslParser::TopLevelDeclarationContext *> azslParser::CompilationUnitContext::topLevelDeclaration() {
  return getRuleContexts<azslParser::TopLevelDeclarationContext>();
}

azslParser::TopLevelDeclarationContext* azslParser::CompilationUnitContext::topLevelDeclaration(size_t i) {
  return getRuleContext<azslParser::TopLevelDeclarationContext>(i);
}


size_t azslParser::CompilationUnitContext::getRuleIndex() const {
  return azslParser::RuleCompilationUnit;
}

void azslParser::CompilationUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompilationUnit(this);
}

void azslParser::CompilationUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompilationUnit(this);
}

azslParser::CompilationUnitContext* azslParser::compilationUnit() {
  CompilationUnitContext *_localctx = _tracker.createInstance<CompilationUnitContext>(_ctx, getState());
  enterRule(_localctx, 0, azslParser::RuleCompilationUnit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(283);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26388951203841) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -97) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 153122387330662335) != 0) || ((((_la - 336) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 336)) & 35377905667) != 0)) {
      setState(280);
      antlrcpp::downCast<CompilationUnitContext *>(_localctx)->topLevelDeclarationContext = topLevelDeclaration();
      antlrcpp::downCast<CompilationUnitContext *>(_localctx)->Declarations.push_back(antlrcpp::downCast<CompilationUnitContext *>(_localctx)->topLevelDeclarationContext);
      setState(285);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(286);
    match(azslParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TopLevelDeclarationContext ------------------------------------------------------------------

azslParser::TopLevelDeclarationContext::TopLevelDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::TopLevelDeclarationContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}

azslParser::VariableDeclarationStatementContext* azslParser::TopLevelDeclarationContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::TopLevelDeclarationContext::attributedFunctionDefinition() {
  return getRuleContext<azslParser::AttributedFunctionDefinitionContext>(0);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::TopLevelDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::AttributeSpecifierSequenceContext* azslParser::TopLevelDeclarationContext::attributeSpecifierSequence() {
  return getRuleContext<azslParser::AttributeSpecifierSequenceContext>(0);
}

azslParser::CompilerExtensionStatementContext* azslParser::TopLevelDeclarationContext::compilerExtensionStatement() {
  return getRuleContext<azslParser::CompilerExtensionStatementContext>(0);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::TopLevelDeclarationContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::AttributedSrgDefinitionContext* azslParser::TopLevelDeclarationContext::attributedSrgDefinition() {
  return getRuleContext<azslParser::AttributedSrgDefinitionContext>(0);
}

azslParser::AttributedSrgSemanticContext* azslParser::TopLevelDeclarationContext::attributedSrgSemantic() {
  return getRuleContext<azslParser::AttributedSrgSemanticContext>(0);
}

tree::TerminalNode* azslParser::TopLevelDeclarationContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::TopLevelDeclarationContext::getRuleIndex() const {
  return azslParser::RuleTopLevelDeclaration;
}

void azslParser::TopLevelDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopLevelDeclaration(this);
}

void azslParser::TopLevelDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopLevelDeclaration(this);
}

azslParser::TopLevelDeclarationContext* azslParser::topLevelDeclaration() {
  TopLevelDeclarationContext *_localctx = _tracker.createInstance<TopLevelDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 2, azslParser::RuleTopLevelDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(298);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(288);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(289);
      variableDeclarationStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(290);
      attributedFunctionDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(291);
      attributedFunctionDeclaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(292);
      attributeSpecifierSequence();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(293);
      compilerExtensionStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(294);
      typeAliasingDefinitionStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(295);
      attributedSrgDefinition();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(296);
      attributedSrgSemantic();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(297);
      match(azslParser::Semi);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdExpressionContext ------------------------------------------------------------------

azslParser::IdExpressionContext::IdExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::UnqualifiedIdContext* azslParser::IdExpressionContext::unqualifiedId() {
  return getRuleContext<azslParser::UnqualifiedIdContext>(0);
}

azslParser::QualifiedIdContext* azslParser::IdExpressionContext::qualifiedId() {
  return getRuleContext<azslParser::QualifiedIdContext>(0);
}


size_t azslParser::IdExpressionContext::getRuleIndex() const {
  return azslParser::RuleIdExpression;
}

void azslParser::IdExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdExpression(this);
}

void azslParser::IdExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdExpression(this);
}

azslParser::IdExpressionContext* azslParser::idExpression() {
  IdExpressionContext *_localctx = _tracker.createInstance<IdExpressionContext>(_ctx, getState());
  enterRule(_localctx, 4, azslParser::RuleIdExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(302);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(300);
      unqualifiedId();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(301);
      qualifiedId();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnqualifiedIdContext ------------------------------------------------------------------

azslParser::UnqualifiedIdContext::UnqualifiedIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::UnqualifiedIdContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::UnqualifiedIdContext::getRuleIndex() const {
  return azslParser::RuleUnqualifiedId;
}

void azslParser::UnqualifiedIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnqualifiedId(this);
}

void azslParser::UnqualifiedIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnqualifiedId(this);
}

azslParser::UnqualifiedIdContext* azslParser::unqualifiedId() {
  UnqualifiedIdContext *_localctx = _tracker.createInstance<UnqualifiedIdContext>(_ctx, getState());
  enterRule(_localctx, 6, azslParser::RuleUnqualifiedId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(304);
    match(azslParser::Identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdContext ------------------------------------------------------------------

azslParser::QualifiedIdContext::QualifiedIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::NestedNameSpecifierContext* azslParser::QualifiedIdContext::nestedNameSpecifier() {
  return getRuleContext<azslParser::NestedNameSpecifierContext>(0);
}

azslParser::UnqualifiedIdContext* azslParser::QualifiedIdContext::unqualifiedId() {
  return getRuleContext<azslParser::UnqualifiedIdContext>(0);
}


size_t azslParser::QualifiedIdContext::getRuleIndex() const {
  return azslParser::RuleQualifiedId;
}

void azslParser::QualifiedIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedId(this);
}

void azslParser::QualifiedIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedId(this);
}

azslParser::QualifiedIdContext* azslParser::qualifiedId() {
  QualifiedIdContext *_localctx = _tracker.createInstance<QualifiedIdContext>(_ctx, getState());
  enterRule(_localctx, 8, azslParser::RuleQualifiedId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(306);
    nestedNameSpecifier();
    setState(307);
    unqualifiedId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NestedNameSpecifierContext ------------------------------------------------------------------

azslParser::NestedNameSpecifierContext::NestedNameSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> azslParser::NestedNameSpecifierContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::NestedNameSpecifierContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

std::vector<tree::TerminalNode *> azslParser::NestedNameSpecifierContext::ColonColon() {
  return getTokens(azslParser::ColonColon);
}

tree::TerminalNode* azslParser::NestedNameSpecifierContext::ColonColon(size_t i) {
  return getToken(azslParser::ColonColon, i);
}


size_t azslParser::NestedNameSpecifierContext::getRuleIndex() const {
  return azslParser::RuleNestedNameSpecifier;
}

void azslParser::NestedNameSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNestedNameSpecifier(this);
}

void azslParser::NestedNameSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNestedNameSpecifier(this);
}

azslParser::NestedNameSpecifierContext* azslParser::nestedNameSpecifier() {
  NestedNameSpecifierContext *_localctx = _tracker.createInstance<NestedNameSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 10, azslParser::RuleNestedNameSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(310);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::ColonColon) {
      setState(309);
      antlrcpp::downCast<NestedNameSpecifierContext *>(_localctx)->GlobalSROToken = match(azslParser::ColonColon);
    }
    setState(316);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(312);
        match(azslParser::Identifier);
        setState(313);
        match(azslParser::ColonColon); 
      }
      setState(318);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDefinitionStatementContext ------------------------------------------------------------------

azslParser::ClassDefinitionStatementContext::ClassDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::ClassDefinitionContext* azslParser::ClassDefinitionStatementContext::classDefinition() {
  return getRuleContext<azslParser::ClassDefinitionContext>(0);
}

tree::TerminalNode* azslParser::ClassDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::ClassDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleClassDefinitionStatement;
}

void azslParser::ClassDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassDefinitionStatement(this);
}

void azslParser::ClassDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassDefinitionStatement(this);
}

azslParser::ClassDefinitionStatementContext* azslParser::classDefinitionStatement() {
  ClassDefinitionStatementContext *_localctx = _tracker.createInstance<ClassDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 12, azslParser::RuleClassDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(319);
    classDefinition();
    setState(320);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDefinitionContext ------------------------------------------------------------------

azslParser::ClassDefinitionContext::ClassDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ClassDefinitionContext::Class() {
  return getToken(azslParser::Class, 0);
}

tree::TerminalNode* azslParser::ClassDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::ClassDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

tree::TerminalNode* azslParser::ClassDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

std::vector<azslParser::ClassMemberDeclarationContext *> azslParser::ClassDefinitionContext::classMemberDeclaration() {
  return getRuleContexts<azslParser::ClassMemberDeclarationContext>();
}

azslParser::ClassMemberDeclarationContext* azslParser::ClassDefinitionContext::classMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::ClassMemberDeclarationContext>(i);
}

azslParser::BaseListContext* azslParser::ClassDefinitionContext::baseList() {
  return getRuleContext<azslParser::BaseListContext>(0);
}


size_t azslParser::ClassDefinitionContext::getRuleIndex() const {
  return azslParser::RuleClassDefinition;
}

void azslParser::ClassDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassDefinition(this);
}

void azslParser::ClassDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassDefinition(this);
}

azslParser::ClassDefinitionContext* azslParser::classDefinition() {
  ClassDefinitionContext *_localctx = _tracker.createInstance<ClassDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 14, azslParser::RuleClassDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(322);
    match(azslParser::Class);
    setState(323);
    antlrcpp::downCast<ClassDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(325);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(324);
      antlrcpp::downCast<ClassDefinitionContext *>(_localctx)->BaseListOpt = baseList();
    }
    setState(327);
    match(azslParser::LeftBrace);
    setState(331);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -97) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 153122387330662335) != 0) || ((((_la - 336) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 336)) & 34371272705) != 0)) {
      setState(328);
      classMemberDeclaration();
      setState(333);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(334);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseListContext ------------------------------------------------------------------

azslParser::BaseListContext::BaseListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BaseListContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

std::vector<azslParser::IdExpressionContext *> azslParser::BaseListContext::idExpression() {
  return getRuleContexts<azslParser::IdExpressionContext>();
}

azslParser::IdExpressionContext* azslParser::BaseListContext::idExpression(size_t i) {
  return getRuleContext<azslParser::IdExpressionContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::BaseListContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::BaseListContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::BaseListContext::getRuleIndex() const {
  return azslParser::RuleBaseList;
}

void azslParser::BaseListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseList(this);
}

void azslParser::BaseListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseList(this);
}

azslParser::BaseListContext* azslParser::baseList() {
  BaseListContext *_localctx = _tracker.createInstance<BaseListContext>(_ctx, getState());
  enterRule(_localctx, 16, azslParser::RuleBaseList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(336);
    match(azslParser::Colon);
    setState(337);
    idExpression();
    setState(342);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(338);
      match(azslParser::Comma);
      setState(339);
      idExpression();
      setState(344);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassMemberDeclarationContext ------------------------------------------------------------------

azslParser::ClassMemberDeclarationContext::ClassMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationStatementContext* azslParser::ClassMemberDeclarationContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::ClassMemberDeclarationContext::attributedFunctionDefinition() {
  return getRuleContext<azslParser::AttributedFunctionDefinitionContext>(0);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::ClassMemberDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::ClassMemberDeclarationContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::ClassMemberDeclarationContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}

azslParser::AttributeSpecifierAnyContext* azslParser::ClassMemberDeclarationContext::attributeSpecifierAny() {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(0);
}


size_t azslParser::ClassMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleClassMemberDeclaration;
}

void azslParser::ClassMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassMemberDeclaration(this);
}

void azslParser::ClassMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassMemberDeclaration(this);
}

azslParser::ClassMemberDeclarationContext* azslParser::classMemberDeclaration() {
  ClassMemberDeclarationContext *_localctx = _tracker.createInstance<ClassMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 18, azslParser::RuleClassMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(351);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(345);
      variableDeclarationStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(346);
      attributedFunctionDefinition();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(347);
      attributedFunctionDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(348);
      typeAliasingDefinitionStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(349);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(350);
      attributeSpecifierAny();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructDefinitionStatementContext ------------------------------------------------------------------

azslParser::StructDefinitionStatementContext::StructDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StructDefinitionContext* azslParser::StructDefinitionStatementContext::structDefinition() {
  return getRuleContext<azslParser::StructDefinitionContext>(0);
}

tree::TerminalNode* azslParser::StructDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::StructDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleStructDefinitionStatement;
}

void azslParser::StructDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructDefinitionStatement(this);
}

void azslParser::StructDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructDefinitionStatement(this);
}

azslParser::StructDefinitionStatementContext* azslParser::structDefinitionStatement() {
  StructDefinitionStatementContext *_localctx = _tracker.createInstance<StructDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 20, azslParser::RuleStructDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(353);
    structDefinition();
    setState(354);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructDefinitionContext ------------------------------------------------------------------

azslParser::StructDefinitionContext::StructDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StructDefinitionContext::Struct() {
  return getToken(azslParser::Struct, 0);
}

tree::TerminalNode* azslParser::StructDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::StructDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

tree::TerminalNode* azslParser::StructDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

std::vector<azslParser::StructMemberDeclarationContext *> azslParser::StructDefinitionContext::structMemberDeclaration() {
  return getRuleContexts<azslParser::StructMemberDeclarationContext>();
}

azslParser::StructMemberDeclarationContext* azslParser::StructDefinitionContext::structMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::StructMemberDeclarationContext>(i);
}


size_t azslParser::StructDefinitionContext::getRuleIndex() const {
  return azslParser::RuleStructDefinition;
}

void azslParser::StructDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructDefinition(this);
}

void azslParser::StructDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructDefinition(this);
}

azslParser::StructDefinitionContext* azslParser::structDefinition() {
  StructDefinitionContext *_localctx = _tracker.createInstance<StructDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 22, azslParser::RuleStructDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(356);
    match(azslParser::Struct);
    setState(357);
    antlrcpp::downCast<StructDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(358);
    match(azslParser::LeftBrace);
    setState(362);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -97) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 153122387330662335) != 0) || ((((_la - 336) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 336)) & 34371272705) != 0)) {
      setState(359);
      structMemberDeclaration();
      setState(364);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(365);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructMemberDeclarationContext ------------------------------------------------------------------

azslParser::StructMemberDeclarationContext::StructMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationStatementContext* azslParser::StructMemberDeclarationContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::StructMemberDeclarationContext::attributedFunctionDefinition() {
  return getRuleContext<azslParser::AttributedFunctionDefinitionContext>(0);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::StructMemberDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::StructMemberDeclarationContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::StructMemberDeclarationContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::AttributeSpecifierAnyContext* azslParser::StructMemberDeclarationContext::attributeSpecifierAny() {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(0);
}


size_t azslParser::StructMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleStructMemberDeclaration;
}

void azslParser::StructMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructMemberDeclaration(this);
}

void azslParser::StructMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructMemberDeclaration(this);
}

azslParser::StructMemberDeclarationContext* azslParser::structMemberDeclaration() {
  StructMemberDeclarationContext *_localctx = _tracker.createInstance<StructMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 24, azslParser::RuleStructMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(373);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(367);
      variableDeclarationStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(368);
      attributedFunctionDefinition();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(369);
      attributedFunctionDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(370);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(371);
      typeAliasingDefinitionStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(372);
      attributeSpecifierAny();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnyStructuredTypeDefinitionStatementContext ------------------------------------------------------------------

azslParser::AnyStructuredTypeDefinitionStatementContext::AnyStructuredTypeDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::AnyStructuredTypeDefinitionContext* azslParser::AnyStructuredTypeDefinitionStatementContext::anyStructuredTypeDefinition() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionContext>(0);
}

tree::TerminalNode* azslParser::AnyStructuredTypeDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AnyStructuredTypeDefinitionStatementContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AnyStructuredTypeDefinitionStatementContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AnyStructuredTypeDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleAnyStructuredTypeDefinitionStatement;
}

void azslParser::AnyStructuredTypeDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnyStructuredTypeDefinitionStatement(this);
}

void azslParser::AnyStructuredTypeDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnyStructuredTypeDefinitionStatement(this);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::anyStructuredTypeDefinitionStatement() {
  AnyStructuredTypeDefinitionStatementContext *_localctx = _tracker.createInstance<AnyStructuredTypeDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 26, azslParser::RuleAnyStructuredTypeDefinitionStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(378);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(375);
      attributeSpecifierAny();
      setState(380);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(381);
    anyStructuredTypeDefinition();
    setState(382);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDefinitionStatementContext ------------------------------------------------------------------

azslParser::EnumDefinitionStatementContext::EnumDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::EnumDefinitionContext* azslParser::EnumDefinitionStatementContext::enumDefinition() {
  return getRuleContext<azslParser::EnumDefinitionContext>(0);
}

tree::TerminalNode* azslParser::EnumDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::EnumDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleEnumDefinitionStatement;
}

void azslParser::EnumDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumDefinitionStatement(this);
}

void azslParser::EnumDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumDefinitionStatement(this);
}

azslParser::EnumDefinitionStatementContext* azslParser::enumDefinitionStatement() {
  EnumDefinitionStatementContext *_localctx = _tracker.createInstance<EnumDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 28, azslParser::RuleEnumDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(384);
    enumDefinition();
    setState(385);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDefinitionContext ------------------------------------------------------------------

azslParser::EnumDefinitionContext::EnumDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::EnumKeyContext* azslParser::EnumDefinitionContext::enumKey() {
  return getRuleContext<azslParser::EnumKeyContext>(0);
}

tree::TerminalNode* azslParser::EnumDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::EnumDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

tree::TerminalNode* azslParser::EnumDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

azslParser::EnumeratorListDefinitionContext* azslParser::EnumDefinitionContext::enumeratorListDefinition() {
  return getRuleContext<azslParser::EnumeratorListDefinitionContext>(0);
}


size_t azslParser::EnumDefinitionContext::getRuleIndex() const {
  return azslParser::RuleEnumDefinition;
}

void azslParser::EnumDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumDefinition(this);
}

void azslParser::EnumDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumDefinition(this);
}

azslParser::EnumDefinitionContext* azslParser::enumDefinition() {
  EnumDefinitionContext *_localctx = _tracker.createInstance<EnumDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 30, azslParser::RuleEnumDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(387);
    enumKey();
    setState(388);
    antlrcpp::downCast<EnumDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(389);
    match(azslParser::LeftBrace);
    setState(391);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Identifier) {
      setState(390);
      antlrcpp::downCast<EnumDefinitionContext *>(_localctx)->List = enumeratorListDefinition();
    }
    setState(393);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumKeyContext ------------------------------------------------------------------

azslParser::EnumKeyContext::EnumKeyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::EnumKeyContext::getRuleIndex() const {
  return azslParser::RuleEnumKey;
}

void azslParser::EnumKeyContext::copyFrom(EnumKeyContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- UnscopedEnumContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::UnscopedEnumContext::Enum() {
  return getToken(azslParser::Enum, 0);
}

azslParser::UnscopedEnumContext::UnscopedEnumContext(EnumKeyContext *ctx) { copyFrom(ctx); }

void azslParser::UnscopedEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnscopedEnum(this);
}
void azslParser::UnscopedEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnscopedEnum(this);
}
//----------------- ScopedEnumContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ScopedEnumContext::Enum() {
  return getToken(azslParser::Enum, 0);
}

tree::TerminalNode* azslParser::ScopedEnumContext::Class() {
  return getToken(azslParser::Class, 0);
}

tree::TerminalNode* azslParser::ScopedEnumContext::Struct() {
  return getToken(azslParser::Struct, 0);
}

azslParser::ScopedEnumContext::ScopedEnumContext(EnumKeyContext *ctx) { copyFrom(ctx); }

void azslParser::ScopedEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScopedEnum(this);
}
void azslParser::ScopedEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScopedEnum(this);
}
azslParser::EnumKeyContext* azslParser::enumKey() {
  EnumKeyContext *_localctx = _tracker.createInstance<EnumKeyContext>(_ctx, getState());
  enterRule(_localctx, 32, azslParser::RuleEnumKey);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(398);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<azslParser::UnscopedEnumContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(395);
      match(azslParser::Enum);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<azslParser::ScopedEnumContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(396);
      match(azslParser::Enum);
      setState(397);
      _la = _input->LA(1);
      if (!(_la == azslParser::Class || _la == azslParser::Struct)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumeratorListDefinitionContext ------------------------------------------------------------------

azslParser::EnumeratorListDefinitionContext::EnumeratorListDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::EnumeratorDeclaratorContext *> azslParser::EnumeratorListDefinitionContext::enumeratorDeclarator() {
  return getRuleContexts<azslParser::EnumeratorDeclaratorContext>();
}

azslParser::EnumeratorDeclaratorContext* azslParser::EnumeratorListDefinitionContext::enumeratorDeclarator(size_t i) {
  return getRuleContext<azslParser::EnumeratorDeclaratorContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::EnumeratorListDefinitionContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::EnumeratorListDefinitionContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::EnumeratorListDefinitionContext::getRuleIndex() const {
  return azslParser::RuleEnumeratorListDefinition;
}

void azslParser::EnumeratorListDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumeratorListDefinition(this);
}

void azslParser::EnumeratorListDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumeratorListDefinition(this);
}

azslParser::EnumeratorListDefinitionContext* azslParser::enumeratorListDefinition() {
  EnumeratorListDefinitionContext *_localctx = _tracker.createInstance<EnumeratorListDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 34, azslParser::RuleEnumeratorListDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(400);
    antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->enumeratorDeclaratorContext = enumeratorDeclarator();
    antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->Enumerators.push_back(antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->enumeratorDeclaratorContext);
    setState(405);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(401);
        match(azslParser::Comma);
        setState(402);
        antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->enumeratorDeclaratorContext = enumeratorDeclarator();
        antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->Enumerators.push_back(antlrcpp::downCast<EnumeratorListDefinitionContext *>(_localctx)->enumeratorDeclaratorContext); 
      }
      setState(407);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
    }
    setState(409);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Comma) {
      setState(408);
      match(azslParser::Comma);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumeratorDeclaratorContext ------------------------------------------------------------------

azslParser::EnumeratorDeclaratorContext::EnumeratorDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::EnumeratorDeclaratorContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

tree::TerminalNode* azslParser::EnumeratorDeclaratorContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::ExpressionContext* azslParser::EnumeratorDeclaratorContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}


size_t azslParser::EnumeratorDeclaratorContext::getRuleIndex() const {
  return azslParser::RuleEnumeratorDeclarator;
}

void azslParser::EnumeratorDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumeratorDeclarator(this);
}

void azslParser::EnumeratorDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumeratorDeclarator(this);
}

azslParser::EnumeratorDeclaratorContext* azslParser::enumeratorDeclarator() {
  EnumeratorDeclaratorContext *_localctx = _tracker.createInstance<EnumeratorDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 36, azslParser::RuleEnumeratorDeclarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(411);
    antlrcpp::downCast<EnumeratorDeclaratorContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(414);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Assign) {
      setState(412);
      match(azslParser::Assign);
      setState(413);
      antlrcpp::downCast<EnumeratorDeclaratorContext *>(_localctx)->Value = expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnyStructuredTypeDefinitionContext ------------------------------------------------------------------

azslParser::AnyStructuredTypeDefinitionContext::AnyStructuredTypeDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::ClassDefinitionContext* azslParser::AnyStructuredTypeDefinitionContext::classDefinition() {
  return getRuleContext<azslParser::ClassDefinitionContext>(0);
}

azslParser::InterfaceDefinitionContext* azslParser::AnyStructuredTypeDefinitionContext::interfaceDefinition() {
  return getRuleContext<azslParser::InterfaceDefinitionContext>(0);
}

azslParser::StructDefinitionContext* azslParser::AnyStructuredTypeDefinitionContext::structDefinition() {
  return getRuleContext<azslParser::StructDefinitionContext>(0);
}

azslParser::EnumDefinitionContext* azslParser::AnyStructuredTypeDefinitionContext::enumDefinition() {
  return getRuleContext<azslParser::EnumDefinitionContext>(0);
}


size_t azslParser::AnyStructuredTypeDefinitionContext::getRuleIndex() const {
  return azslParser::RuleAnyStructuredTypeDefinition;
}

void azslParser::AnyStructuredTypeDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnyStructuredTypeDefinition(this);
}

void azslParser::AnyStructuredTypeDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnyStructuredTypeDefinition(this);
}

azslParser::AnyStructuredTypeDefinitionContext* azslParser::anyStructuredTypeDefinition() {
  AnyStructuredTypeDefinitionContext *_localctx = _tracker.createInstance<AnyStructuredTypeDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 38, azslParser::RuleAnyStructuredTypeDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(420);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Class: {
        enterOuterAlt(_localctx, 1);
        setState(416);
        classDefinition();
        break;
      }

      case azslParser::Interface: {
        enterOuterAlt(_localctx, 2);
        setState(417);
        interfaceDefinition();
        break;
      }

      case azslParser::Struct: {
        enterOuterAlt(_localctx, 3);
        setState(418);
        structDefinition();
        break;
      }

      case azslParser::Enum: {
        enterOuterAlt(_localctx, 4);
        setState(419);
        enumDefinition();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceDefinitionStatementContext ------------------------------------------------------------------

azslParser::InterfaceDefinitionStatementContext::InterfaceDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::InterfaceDefinitionContext* azslParser::InterfaceDefinitionStatementContext::interfaceDefinition() {
  return getRuleContext<azslParser::InterfaceDefinitionContext>(0);
}

tree::TerminalNode* azslParser::InterfaceDefinitionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::InterfaceDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleInterfaceDefinitionStatement;
}

void azslParser::InterfaceDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceDefinitionStatement(this);
}

void azslParser::InterfaceDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceDefinitionStatement(this);
}

azslParser::InterfaceDefinitionStatementContext* azslParser::interfaceDefinitionStatement() {
  InterfaceDefinitionStatementContext *_localctx = _tracker.createInstance<InterfaceDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 40, azslParser::RuleInterfaceDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(422);
    interfaceDefinition();
    setState(423);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceDefinitionContext ------------------------------------------------------------------

azslParser::InterfaceDefinitionContext::InterfaceDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::InterfaceDefinitionContext::Interface() {
  return getToken(azslParser::Interface, 0);
}

tree::TerminalNode* azslParser::InterfaceDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::InterfaceDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

tree::TerminalNode* azslParser::InterfaceDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

std::vector<azslParser::InterfaceMemberDeclarationContext *> azslParser::InterfaceDefinitionContext::interfaceMemberDeclaration() {
  return getRuleContexts<azslParser::InterfaceMemberDeclarationContext>();
}

azslParser::InterfaceMemberDeclarationContext* azslParser::InterfaceDefinitionContext::interfaceMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::InterfaceMemberDeclarationContext>(i);
}


size_t azslParser::InterfaceDefinitionContext::getRuleIndex() const {
  return azslParser::RuleInterfaceDefinition;
}

void azslParser::InterfaceDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceDefinition(this);
}

void azslParser::InterfaceDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceDefinition(this);
}

azslParser::InterfaceDefinitionContext* azslParser::interfaceDefinition() {
  InterfaceDefinitionContext *_localctx = _tracker.createInstance<InterfaceDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 42, azslParser::RuleInterfaceDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(425);
    match(azslParser::Interface);
    setState(426);
    antlrcpp::downCast<InterfaceDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(427);
    match(azslParser::LeftBrace);
    setState(431);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -97) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 153122387330662335) != 0) || ((((_la - 336) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 336)) & 34368651265) != 0)) {
      setState(428);
      interfaceMemberDeclaration();
      setState(433);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(434);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceMemberDeclarationContext ------------------------------------------------------------------

azslParser::InterfaceMemberDeclarationContext::InterfaceMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::AttributedFunctionDeclarationContext* azslParser::InterfaceMemberDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::AssociatedTypeDeclarationContext* azslParser::InterfaceMemberDeclarationContext::associatedTypeDeclaration() {
  return getRuleContext<azslParser::AssociatedTypeDeclarationContext>(0);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::InterfaceMemberDeclarationContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}


size_t azslParser::InterfaceMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleInterfaceMemberDeclaration;
}

void azslParser::InterfaceMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceMemberDeclaration(this);
}

void azslParser::InterfaceMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceMemberDeclaration(this);
}

azslParser::InterfaceMemberDeclarationContext* azslParser::interfaceMemberDeclaration() {
  InterfaceMemberDeclarationContext *_localctx = _tracker.createInstance<InterfaceMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 44, azslParser::RuleInterfaceMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(439);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(436);
      attributedFunctionDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(437);
      associatedTypeDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(438);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantBufferTemplatedContext ------------------------------------------------------------------

azslParser::ConstantBufferTemplatedContext::ConstantBufferTemplatedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ConstantBufferTemplatedContext::Less() {
  return getToken(azslParser::Less, 0);
}

tree::TerminalNode* azslParser::ConstantBufferTemplatedContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

azslParser::TypeContext* azslParser::ConstantBufferTemplatedContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::ConstantBufferTemplatedContext::ConstantBuffer() {
  return getToken(azslParser::ConstantBuffer, 0);
}

tree::TerminalNode* azslParser::ConstantBufferTemplatedContext::ConstantBufferCamel() {
  return getToken(azslParser::ConstantBufferCamel, 0);
}


size_t azslParser::ConstantBufferTemplatedContext::getRuleIndex() const {
  return azslParser::RuleConstantBufferTemplated;
}

void azslParser::ConstantBufferTemplatedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantBufferTemplated(this);
}

void azslParser::ConstantBufferTemplatedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantBufferTemplated(this);
}

azslParser::ConstantBufferTemplatedContext* azslParser::constantBufferTemplated() {
  ConstantBufferTemplatedContext *_localctx = _tracker.createInstance<ConstantBufferTemplatedContext>(_ctx, getState());
  enterRule(_localctx, 46, azslParser::RuleConstantBufferTemplated);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(441);
    antlrcpp::downCast<ConstantBufferTemplatedContext *>(_localctx)->CBCoreType = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == azslParser::ConstantBuffer

    || _la == azslParser::ConstantBufferCamel)) {
      antlrcpp::downCast<ConstantBufferTemplatedContext *>(_localctx)->CBCoreType = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(442);
    match(azslParser::Less);
    setState(443);
    antlrcpp::downCast<ConstantBufferTemplatedContext *>(_localctx)->GenericTypeName = type();
    setState(444);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationStatementContext ------------------------------------------------------------------

azslParser::VariableDeclarationStatementContext::VariableDeclarationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationContext* azslParser::VariableDeclarationStatementContext::variableDeclaration() {
  return getRuleContext<azslParser::VariableDeclarationContext>(0);
}

tree::TerminalNode* azslParser::VariableDeclarationStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::VariableDeclarationStatementContext::getRuleIndex() const {
  return azslParser::RuleVariableDeclarationStatement;
}

void azslParser::VariableDeclarationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarationStatement(this);
}

void azslParser::VariableDeclarationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarationStatement(this);
}

azslParser::VariableDeclarationStatementContext* azslParser::variableDeclarationStatement() {
  VariableDeclarationStatementContext *_localctx = _tracker.createInstance<VariableDeclarationStatementContext>(_ctx, getState());
  enterRule(_localctx, 48, azslParser::RuleVariableDeclarationStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(446);
    variableDeclaration();
    setState(447);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionParamsContext ------------------------------------------------------------------

azslParser::FunctionParamsContext::FunctionParamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::FunctionParamsContext::Void() {
  return getToken(azslParser::Void, 0);
}

std::vector<azslParser::FunctionParamContext *> azslParser::FunctionParamsContext::functionParam() {
  return getRuleContexts<azslParser::FunctionParamContext>();
}

azslParser::FunctionParamContext* azslParser::FunctionParamsContext::functionParam(size_t i) {
  return getRuleContext<azslParser::FunctionParamContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::FunctionParamsContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::FunctionParamsContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::FunctionParamsContext::getRuleIndex() const {
  return azslParser::RuleFunctionParams;
}

void azslParser::FunctionParamsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionParams(this);
}

void azslParser::FunctionParamsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionParams(this);
}

azslParser::FunctionParamsContext* azslParser::functionParams() {
  FunctionParamsContext *_localctx = _tracker.createInstance<FunctionParamsContext>(_ctx, getState());
  enterRule(_localctx, 50, azslParser::RuleFunctionParams);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(458);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(449);
      match(azslParser::Void);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(450);
      functionParam();
      setState(455);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::Comma) {
        setState(451);
        match(azslParser::Comma);
        setState(452);
        functionParam();
        setState(457);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionParamContext ------------------------------------------------------------------

azslParser::FunctionParamContext::FunctionParamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TypeContext* azslParser::FunctionParamContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

azslParser::UnnamedVariableDeclaratorContext* azslParser::FunctionParamContext::unnamedVariableDeclarator() {
  return getRuleContext<azslParser::UnnamedVariableDeclaratorContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::FunctionParamContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::FunctionParamContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}

tree::TerminalNode* azslParser::FunctionParamContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::FunctionParamContext::getRuleIndex() const {
  return azslParser::RuleFunctionParam;
}

void azslParser::FunctionParamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionParam(this);
}

void azslParser::FunctionParamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionParam(this);
}

azslParser::FunctionParamContext* azslParser::functionParam() {
  FunctionParamContext *_localctx = _tracker.createInstance<FunctionParamContext>(_ctx, getState());
  enterRule(_localctx, 52, azslParser::RuleFunctionParam);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(463);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(460);
      attributeSpecifierAny();
      setState(465);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(466);
    type();
    setState(468);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Identifier) {
      setState(467);
      antlrcpp::downCast<FunctionParamContext *>(_localctx)->Name = match(azslParser::Identifier);
    }
    setState(470);
    unnamedVariableDeclarator();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HlslSemanticContext ------------------------------------------------------------------

azslParser::HlslSemanticContext::HlslSemanticContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::HlslSemanticContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::HlslSemanticNameContext* azslParser::HlslSemanticContext::hlslSemanticName() {
  return getRuleContext<azslParser::HlslSemanticNameContext>(0);
}


size_t azslParser::HlslSemanticContext::getRuleIndex() const {
  return azslParser::RuleHlslSemantic;
}

void azslParser::HlslSemanticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHlslSemantic(this);
}

void azslParser::HlslSemanticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHlslSemantic(this);
}

azslParser::HlslSemanticContext* azslParser::hlslSemantic() {
  HlslSemanticContext *_localctx = _tracker.createInstance<HlslSemanticContext>(_ctx, getState());
  enterRule(_localctx, 54, azslParser::RuleHlslSemantic);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(472);
    match(azslParser::Colon);
    setState(473);
    antlrcpp::downCast<HlslSemanticContext *>(_localctx)->Name = hlslSemanticName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HlslSemanticNameContext ------------------------------------------------------------------

azslParser::HlslSemanticNameContext::HlslSemanticNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::HlslSemanticNameContext::HLSLSemanticStream() {
  return getToken(azslParser::HLSLSemanticStream, 0);
}

tree::TerminalNode* azslParser::HlslSemanticNameContext::HLSLSemanticSystem() {
  return getToken(azslParser::HLSLSemanticSystem, 0);
}

tree::TerminalNode* azslParser::HlslSemanticNameContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::HlslSemanticNameContext::getRuleIndex() const {
  return azslParser::RuleHlslSemanticName;
}

void azslParser::HlslSemanticNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHlslSemanticName(this);
}

void azslParser::HlslSemanticNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHlslSemanticName(this);
}

azslParser::HlslSemanticNameContext* azslParser::hlslSemanticName() {
  HlslSemanticNameContext *_localctx = _tracker.createInstance<HlslSemanticNameContext>(_ctx, getState());
  enterRule(_localctx, 56, azslParser::RuleHlslSemanticName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(475);
    _la = _input->LA(1);
    if (!(((((_la - 369) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 369)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeArgumentsContext ------------------------------------------------------------------

azslParser::AttributeArgumentsContext::AttributeArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::LiteralContext *> azslParser::AttributeArgumentsContext::literal() {
  return getRuleContexts<azslParser::LiteralContext>();
}

azslParser::LiteralContext* azslParser::AttributeArgumentsContext::literal(size_t i) {
  return getRuleContext<azslParser::LiteralContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::AttributeArgumentsContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::AttributeArgumentsContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::AttributeArgumentsContext::getRuleIndex() const {
  return azslParser::RuleAttributeArguments;
}

void azslParser::AttributeArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeArguments(this);
}

void azslParser::AttributeArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeArguments(this);
}

azslParser::AttributeArgumentsContext* azslParser::attributeArguments() {
  AttributeArgumentsContext *_localctx = _tracker.createInstance<AttributeArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 58, azslParser::RuleAttributeArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(477);
    literal();
    setState(482);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(478);
      match(azslParser::Comma);
      setState(479);
      literal();
      setState(484);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeArgumentListContext ------------------------------------------------------------------

azslParser::AttributeArgumentListContext::AttributeArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AttributeArgumentListContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

azslParser::AttributeArgumentsContext* azslParser::AttributeArgumentListContext::attributeArguments() {
  return getRuleContext<azslParser::AttributeArgumentsContext>(0);
}

tree::TerminalNode* azslParser::AttributeArgumentListContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}


size_t azslParser::AttributeArgumentListContext::getRuleIndex() const {
  return azslParser::RuleAttributeArgumentList;
}

void azslParser::AttributeArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeArgumentList(this);
}

void azslParser::AttributeArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeArgumentList(this);
}

azslParser::AttributeArgumentListContext* azslParser::attributeArgumentList() {
  AttributeArgumentListContext *_localctx = _tracker.createInstance<AttributeArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 60, azslParser::RuleAttributeArgumentList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(485);
    match(azslParser::LeftParen);
    setState(486);
    attributeArguments();
    setState(487);
    match(azslParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeContext ------------------------------------------------------------------

azslParser::AttributeContext::AttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::AttributeContext::getRuleIndex() const {
  return azslParser::RuleAttribute;
}

void azslParser::AttributeContext::copyFrom(AttributeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- GlobalAttributeContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::GlobalAttributeContext::Global() {
  return getToken(azslParser::Global, 0);
}

std::vector<tree::TerminalNode *> azslParser::GlobalAttributeContext::ColonColon() {
  return getTokens(azslParser::ColonColon);
}

tree::TerminalNode* azslParser::GlobalAttributeContext::ColonColon(size_t i) {
  return getToken(azslParser::ColonColon, i);
}

std::vector<tree::TerminalNode *> azslParser::GlobalAttributeContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::GlobalAttributeContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

azslParser::AttributeArgumentListContext* azslParser::GlobalAttributeContext::attributeArgumentList() {
  return getRuleContext<azslParser::AttributeArgumentListContext>(0);
}

azslParser::GlobalAttributeContext::GlobalAttributeContext(AttributeContext *ctx) { copyFrom(ctx); }

void azslParser::GlobalAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobalAttribute(this);
}
void azslParser::GlobalAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobalAttribute(this);
}
//----------------- AttachedAttributeContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> azslParser::AttachedAttributeContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::AttachedAttributeContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

tree::TerminalNode* azslParser::AttachedAttributeContext::ColonColon() {
  return getToken(azslParser::ColonColon, 0);
}

azslParser::AttributeArgumentListContext* azslParser::AttachedAttributeContext::attributeArgumentList() {
  return getRuleContext<azslParser::AttributeArgumentListContext>(0);
}

azslParser::AttachedAttributeContext::AttachedAttributeContext(AttributeContext *ctx) { copyFrom(ctx); }

void azslParser::AttachedAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttachedAttribute(this);
}
void azslParser::AttachedAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttachedAttribute(this);
}
azslParser::AttributeContext* azslParser::attribute() {
  AttributeContext *_localctx = _tracker.createInstance<AttributeContext>(_ctx, getState());
  enterRule(_localctx, 62, azslParser::RuleAttribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(507);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Global: {
        _localctx = _tracker.createInstance<azslParser::GlobalAttributeContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(489);
        match(azslParser::Global);
        setState(490);
        match(azslParser::ColonColon);
        setState(493);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
        case 1: {
          setState(491);
          antlrcpp::downCast<GlobalAttributeContext *>(_localctx)->Namespace = match(azslParser::Identifier);
          setState(492);
          match(azslParser::ColonColon);
          break;
        }

        default:
          break;
        }
        setState(495);
        antlrcpp::downCast<GlobalAttributeContext *>(_localctx)->Name = match(azslParser::Identifier);
        setState(497);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == azslParser::LeftParen) {
          setState(496);
          attributeArgumentList();
        }
        break;
      }

      case azslParser::Identifier: {
        _localctx = _tracker.createInstance<azslParser::AttachedAttributeContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(501);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
        case 1: {
          setState(499);
          antlrcpp::downCast<AttachedAttributeContext *>(_localctx)->Namespace = match(azslParser::Identifier);
          setState(500);
          match(azslParser::ColonColon);
          break;
        }

        default:
          break;
        }
        setState(503);
        antlrcpp::downCast<AttachedAttributeContext *>(_localctx)->Name = match(azslParser::Identifier);
        setState(505);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == azslParser::LeftParen) {
          setState(504);
          attributeArgumentList();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeSpecifierContext ------------------------------------------------------------------

azslParser::AttributeSpecifierContext::AttributeSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AttributeSpecifierContext::LeftBracket() {
  return getToken(azslParser::LeftBracket, 0);
}

azslParser::AttributeContext* azslParser::AttributeSpecifierContext::attribute() {
  return getRuleContext<azslParser::AttributeContext>(0);
}

tree::TerminalNode* azslParser::AttributeSpecifierContext::RightBracket() {
  return getToken(azslParser::RightBracket, 0);
}


size_t azslParser::AttributeSpecifierContext::getRuleIndex() const {
  return azslParser::RuleAttributeSpecifier;
}

void azslParser::AttributeSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeSpecifier(this);
}

void azslParser::AttributeSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeSpecifier(this);
}

azslParser::AttributeSpecifierContext* azslParser::attributeSpecifier() {
  AttributeSpecifierContext *_localctx = _tracker.createInstance<AttributeSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 64, azslParser::RuleAttributeSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(509);
    match(azslParser::LeftBracket);
    setState(510);
    attribute();
    setState(511);
    match(azslParser::RightBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeSpecifierSequenceContext ------------------------------------------------------------------

azslParser::AttributeSpecifierSequenceContext::AttributeSpecifierSequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AttributeSpecifierSequenceContext::LeftDoubleBracket() {
  return getToken(azslParser::LeftDoubleBracket, 0);
}

std::vector<tree::TerminalNode *> azslParser::AttributeSpecifierSequenceContext::RightBracket() {
  return getTokens(azslParser::RightBracket);
}

tree::TerminalNode* azslParser::AttributeSpecifierSequenceContext::RightBracket(size_t i) {
  return getToken(azslParser::RightBracket, i);
}

std::vector<azslParser::AttributeContext *> azslParser::AttributeSpecifierSequenceContext::attribute() {
  return getRuleContexts<azslParser::AttributeContext>();
}

azslParser::AttributeContext* azslParser::AttributeSpecifierSequenceContext::attribute(size_t i) {
  return getRuleContext<azslParser::AttributeContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::AttributeSpecifierSequenceContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::AttributeSpecifierSequenceContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::AttributeSpecifierSequenceContext::getRuleIndex() const {
  return azslParser::RuleAttributeSpecifierSequence;
}

void azslParser::AttributeSpecifierSequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeSpecifierSequence(this);
}

void azslParser::AttributeSpecifierSequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeSpecifierSequence(this);
}

azslParser::AttributeSpecifierSequenceContext* azslParser::attributeSpecifierSequence() {
  AttributeSpecifierSequenceContext *_localctx = _tracker.createInstance<AttributeSpecifierSequenceContext>(_ctx, getState());
  enterRule(_localctx, 66, azslParser::RuleAttributeSpecifierSequence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(513);
    match(azslParser::LeftDoubleBracket);
    setState(514);
    antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->attributeContext = attribute();
    antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->Attributes.push_back(antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->attributeContext);
    setState(519);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(515);
      match(azslParser::Comma);
      setState(516);
      antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->attributeContext = attribute();
      antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->Attributes.push_back(antlrcpp::downCast<AttributeSpecifierSequenceContext *>(_localctx)->attributeContext);
      setState(521);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(522);
    match(azslParser::RightBracket);
    setState(523);
    match(azslParser::RightBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeSpecifierAnyContext ------------------------------------------------------------------

azslParser::AttributeSpecifierAnyContext::AttributeSpecifierAnyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::AttributeSpecifierContext* azslParser::AttributeSpecifierAnyContext::attributeSpecifier() {
  return getRuleContext<azslParser::AttributeSpecifierContext>(0);
}

azslParser::AttributeSpecifierSequenceContext* azslParser::AttributeSpecifierAnyContext::attributeSpecifierSequence() {
  return getRuleContext<azslParser::AttributeSpecifierSequenceContext>(0);
}


size_t azslParser::AttributeSpecifierAnyContext::getRuleIndex() const {
  return azslParser::RuleAttributeSpecifierAny;
}

void azslParser::AttributeSpecifierAnyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeSpecifierAny(this);
}

void azslParser::AttributeSpecifierAnyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeSpecifierAny(this);
}

azslParser::AttributeSpecifierAnyContext* azslParser::attributeSpecifierAny() {
  AttributeSpecifierAnyContext *_localctx = _tracker.createInstance<AttributeSpecifierAnyContext>(_ctx, getState());
  enterRule(_localctx, 68, azslParser::RuleAttributeSpecifierAny);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(527);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::LeftBracket: {
        enterOuterAlt(_localctx, 1);
        setState(525);
        attributeSpecifier();
        break;
      }

      case azslParser::LeftDoubleBracket: {
        enterOuterAlt(_localctx, 2);
        setState(526);
        attributeSpecifierSequence();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

azslParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BlockContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::BlockContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<azslParser::StatementContext *> azslParser::BlockContext::statement() {
  return getRuleContexts<azslParser::StatementContext>();
}

azslParser::StatementContext* azslParser::BlockContext::statement(size_t i) {
  return getRuleContext<azslParser::StatementContext>(i);
}


size_t azslParser::BlockContext::getRuleIndex() const {
  return azslParser::RuleBlock;
}

void azslParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void azslParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}

azslParser::BlockContext* azslParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 70, azslParser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(529);
    match(azslParser::LeftBrace);
    setState(533);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917528889799475198) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -134217735) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -8797033594881) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -65) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 191402984163311615) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & 33830555447668751) != 0)) {
      setState(530);
      antlrcpp::downCast<BlockContext *>(_localctx)->statementContext = statement();
      antlrcpp::downCast<BlockContext *>(_localctx)->Stmts.push_back(antlrcpp::downCast<BlockContext *>(_localctx)->statementContext);
      setState(535);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(536);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

azslParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationStatementContext* azslParser::StatementContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::EmbeddedStatementContext* azslParser::StatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

azslParser::AnyStructuredTypeDefinitionStatementContext* azslParser::StatementContext::anyStructuredTypeDefinitionStatement() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionStatementContext>(0);
}


size_t azslParser::StatementContext::getRuleIndex() const {
  return azslParser::RuleStatement;
}

void azslParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void azslParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

azslParser::StatementContext* azslParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 72, azslParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(541);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(538);
      variableDeclarationStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(539);
      embeddedStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(540);
      anyStructuredTypeDefinitionStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForInitializerContext ------------------------------------------------------------------

azslParser::ForInitializerContext::ForInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::VariableDeclarationContext* azslParser::ForInitializerContext::variableDeclaration() {
  return getRuleContext<azslParser::VariableDeclarationContext>(0);
}

azslParser::ExpressionExtContext* azslParser::ForInitializerContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}


size_t azslParser::ForInitializerContext::getRuleIndex() const {
  return azslParser::RuleForInitializer;
}

void azslParser::ForInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForInitializer(this);
}

void azslParser::ForInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForInitializer(this);
}

azslParser::ForInitializerContext* azslParser::forInitializer() {
  ForInitializerContext *_localctx = _tracker.createInstance<ForInitializerContext>(_ctx, getState());
  enterRule(_localctx, 74, azslParser::RuleForInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(545);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(543);
      variableDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(544);
      expressionExt(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchLabelContext ------------------------------------------------------------------

azslParser::SwitchLabelContext::SwitchLabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::SwitchLabelContext::getRuleIndex() const {
  return azslParser::RuleSwitchLabel;
}

void azslParser::SwitchLabelContext::copyFrom(SwitchLabelContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DefaultSwitchLabelContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::DefaultSwitchLabelContext::Default() {
  return getToken(azslParser::Default, 0);
}

tree::TerminalNode* azslParser::DefaultSwitchLabelContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::DefaultSwitchLabelContext::DefaultSwitchLabelContext(SwitchLabelContext *ctx) { copyFrom(ctx); }

void azslParser::DefaultSwitchLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultSwitchLabel(this);
}
void azslParser::DefaultSwitchLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultSwitchLabel(this);
}
//----------------- CaseSwitchLabelContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::CaseSwitchLabelContext::Case() {
  return getToken(azslParser::Case, 0);
}

tree::TerminalNode* azslParser::CaseSwitchLabelContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::ExpressionContext* azslParser::CaseSwitchLabelContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::CaseSwitchLabelContext::CaseSwitchLabelContext(SwitchLabelContext *ctx) { copyFrom(ctx); }

void azslParser::CaseSwitchLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseSwitchLabel(this);
}
void azslParser::CaseSwitchLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseSwitchLabel(this);
}
azslParser::SwitchLabelContext* azslParser::switchLabel() {
  SwitchLabelContext *_localctx = _tracker.createInstance<SwitchLabelContext>(_ctx, getState());
  enterRule(_localctx, 76, azslParser::RuleSwitchLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(553);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Case: {
        _localctx = _tracker.createInstance<azslParser::CaseSwitchLabelContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(547);
        match(azslParser::Case);
        setState(548);
        antlrcpp::downCast<CaseSwitchLabelContext *>(_localctx)->Expr = expression(0);
        setState(549);
        match(azslParser::Colon);
        break;
      }

      case azslParser::Default: {
        _localctx = _tracker.createInstance<azslParser::DefaultSwitchLabelContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(551);
        match(azslParser::Default);
        setState(552);
        match(azslParser::Colon);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchSectionContext ------------------------------------------------------------------

azslParser::SwitchSectionContext::SwitchSectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::SwitchLabelContext *> azslParser::SwitchSectionContext::switchLabel() {
  return getRuleContexts<azslParser::SwitchLabelContext>();
}

azslParser::SwitchLabelContext* azslParser::SwitchSectionContext::switchLabel(size_t i) {
  return getRuleContext<azslParser::SwitchLabelContext>(i);
}

std::vector<azslParser::StatementContext *> azslParser::SwitchSectionContext::statement() {
  return getRuleContexts<azslParser::StatementContext>();
}

azslParser::StatementContext* azslParser::SwitchSectionContext::statement(size_t i) {
  return getRuleContext<azslParser::StatementContext>(i);
}


size_t azslParser::SwitchSectionContext::getRuleIndex() const {
  return azslParser::RuleSwitchSection;
}

void azslParser::SwitchSectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchSection(this);
}

void azslParser::SwitchSectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchSection(this);
}

azslParser::SwitchSectionContext* azslParser::switchSection() {
  SwitchSectionContext *_localctx = _tracker.createInstance<SwitchSectionContext>(_ctx, getState());
  enterRule(_localctx, 78, azslParser::RuleSwitchSection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(556); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(555);
      switchLabel();
      setState(558); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == azslParser::Case

    || _la == azslParser::Default);
    setState(561); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(560);
      statement();
      setState(563); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917528889799475198) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -134217735) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -8797033594881) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -65) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 191402984163311615) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & 33830555447668751) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchBlockContext ------------------------------------------------------------------

azslParser::SwitchBlockContext::SwitchBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SwitchBlockContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::SwitchBlockContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<azslParser::SwitchSectionContext *> azslParser::SwitchBlockContext::switchSection() {
  return getRuleContexts<azslParser::SwitchSectionContext>();
}

azslParser::SwitchSectionContext* azslParser::SwitchBlockContext::switchSection(size_t i) {
  return getRuleContext<azslParser::SwitchSectionContext>(i);
}


size_t azslParser::SwitchBlockContext::getRuleIndex() const {
  return azslParser::RuleSwitchBlock;
}

void azslParser::SwitchBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchBlock(this);
}

void azslParser::SwitchBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchBlock(this);
}

azslParser::SwitchBlockContext* azslParser::switchBlock() {
  SwitchBlockContext *_localctx = _tracker.createInstance<SwitchBlockContext>(_ctx, getState());
  enterRule(_localctx, 80, azslParser::RuleSwitchBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(565);
    match(azslParser::LeftBrace);
    setState(569);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Case

    || _la == azslParser::Default) {
      setState(566);
      switchSection();
      setState(571);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(572);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmbeddedStatementContext ------------------------------------------------------------------

azslParser::EmbeddedStatementContext::EmbeddedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::EmbeddedStatementContext::getRuleIndex() const {
  return azslParser::RuleEmbeddedStatement;
}

void azslParser::EmbeddedStatementContext::copyFrom(EmbeddedStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DoStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::DoStatementContext::Do() {
  return getToken(azslParser::Do, 0);
}

azslParser::EmbeddedStatementContext* azslParser::DoStatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

tree::TerminalNode* azslParser::DoStatementContext::While() {
  return getToken(azslParser::While, 0);
}

tree::TerminalNode* azslParser::DoStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::DoStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::DoStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::ExpressionExtContext* azslParser::DoStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::DoStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::DoStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::DoStatementContext::DoStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}
void azslParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}
//----------------- EmptyStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::EmptyStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::EmptyStatementContext::EmptyStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::EmptyStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStatement(this);
}
void azslParser::EmptyStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStatement(this);
}
//----------------- BlockStatementContext ------------------------------------------------------------------

azslParser::BlockContext* azslParser::BlockStatementContext::block() {
  return getRuleContext<azslParser::BlockContext>(0);
}

azslParser::BlockStatementContext::BlockStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::BlockStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlockStatement(this);
}
void azslParser::BlockStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlockStatement(this);
}
//----------------- WhileStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::WhileStatementContext::While() {
  return getToken(azslParser::While, 0);
}

tree::TerminalNode* azslParser::WhileStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::WhileStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::EmbeddedStatementContext* azslParser::WhileStatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

azslParser::ExpressionExtContext* azslParser::WhileStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::WhileStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::WhileStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::WhileStatementContext::WhileStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}
void azslParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}
//----------------- ExtenstionStatementContext ------------------------------------------------------------------

azslParser::CompilerExtensionStatementContext* azslParser::ExtenstionStatementContext::compilerExtensionStatement() {
  return getRuleContext<azslParser::CompilerExtensionStatementContext>(0);
}

azslParser::ExtenstionStatementContext::ExtenstionStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ExtenstionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtenstionStatement(this);
}
void azslParser::ExtenstionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtenstionStatement(this);
}
//----------------- BreakStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::BreakStatementContext::Break() {
  return getToken(azslParser::Break, 0);
}

tree::TerminalNode* azslParser::BreakStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::BreakStatementContext::BreakStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::BreakStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreakStatement(this);
}
void azslParser::BreakStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreakStatement(this);
}
//----------------- IfStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::IfStatementContext::If() {
  return getToken(azslParser::If, 0);
}

tree::TerminalNode* azslParser::IfStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::IfStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::ExpressionExtContext* azslParser::IfStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::EmbeddedStatementContext* azslParser::IfStatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::IfStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::IfStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::ElseClauseContext* azslParser::IfStatementContext::elseClause() {
  return getRuleContext<azslParser::ElseClauseContext>(0);
}

azslParser::IfStatementContext::IfStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}
void azslParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}
//----------------- SwitchStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::SwitchStatementContext::Switch() {
  return getToken(azslParser::Switch, 0);
}

tree::TerminalNode* azslParser::SwitchStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::SwitchStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::SwitchBlockContext* azslParser::SwitchStatementContext::switchBlock() {
  return getRuleContext<azslParser::SwitchBlockContext>(0);
}

azslParser::ExpressionExtContext* azslParser::SwitchStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::SwitchStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::SwitchStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::SwitchStatementContext::SwitchStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::SwitchStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitchStatement(this);
}
void azslParser::SwitchStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitchStatement(this);
}
//----------------- ExpressionStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ExpressionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::ExpressionExtContext* azslParser::ExpressionStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::ExpressionStatementContext::ExpressionStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}
void azslParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}
//----------------- ReturnStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ReturnStatementContext::Return() {
  return getToken(azslParser::Return, 0);
}

tree::TerminalNode* azslParser::ReturnStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::ExpressionExtContext* azslParser::ReturnStatementContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::ReturnStatementContext::ReturnStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}
void azslParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}
//----------------- DiscardStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::DiscardStatementContext::Discard() {
  return getToken(azslParser::Discard, 0);
}

tree::TerminalNode* azslParser::DiscardStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::DiscardStatementContext::DiscardStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::DiscardStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiscardStatement(this);
}
void azslParser::DiscardStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiscardStatement(this);
}
//----------------- ForStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ForStatementContext::For() {
  return getToken(azslParser::For, 0);
}

tree::TerminalNode* azslParser::ForStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

std::vector<tree::TerminalNode *> azslParser::ForStatementContext::Semi() {
  return getTokens(azslParser::Semi);
}

tree::TerminalNode* azslParser::ForStatementContext::Semi(size_t i) {
  return getToken(azslParser::Semi, i);
}

tree::TerminalNode* azslParser::ForStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::EmbeddedStatementContext* azslParser::ForStatementContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}

std::vector<azslParser::AttributeSpecifierContext *> azslParser::ForStatementContext::attributeSpecifier() {
  return getRuleContexts<azslParser::AttributeSpecifierContext>();
}

azslParser::AttributeSpecifierContext* azslParser::ForStatementContext::attributeSpecifier(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierContext>(i);
}

azslParser::ForInitializerContext* azslParser::ForStatementContext::forInitializer() {
  return getRuleContext<azslParser::ForInitializerContext>(0);
}

std::vector<azslParser::ExpressionExtContext *> azslParser::ForStatementContext::expressionExt() {
  return getRuleContexts<azslParser::ExpressionExtContext>();
}

azslParser::ExpressionExtContext* azslParser::ForStatementContext::expressionExt(size_t i) {
  return getRuleContext<azslParser::ExpressionExtContext>(i);
}

azslParser::ForStatementContext::ForStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ForStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForStatement(this);
}
void azslParser::ForStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForStatement(this);
}
//----------------- TypeAliasingDefinitionStatementLabelContext ------------------------------------------------------------------

azslParser::TypeAliasingDefinitionStatementContext* azslParser::TypeAliasingDefinitionStatementLabelContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::TypeAliasingDefinitionStatementLabelContext::TypeAliasingDefinitionStatementLabelContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::TypeAliasingDefinitionStatementLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAliasingDefinitionStatementLabel(this);
}
void azslParser::TypeAliasingDefinitionStatementLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAliasingDefinitionStatementLabel(this);
}
//----------------- ContinueStatementContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ContinueStatementContext::Continue() {
  return getToken(azslParser::Continue, 0);
}

tree::TerminalNode* azslParser::ContinueStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::ContinueStatementContext::ContinueStatementContext(EmbeddedStatementContext *ctx) { copyFrom(ctx); }

void azslParser::ContinueStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinueStatement(this);
}
void azslParser::ContinueStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinueStatement(this);
}
azslParser::EmbeddedStatementContext* azslParser::embeddedStatement() {
  EmbeddedStatementContext *_localctx = _tracker.createInstance<EmbeddedStatementContext>(_ctx, getState());
  enterRule(_localctx, 82, azslParser::RuleEmbeddedStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(665);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<azslParser::EmptyStatementContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(574);
      match(azslParser::Semi);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<azslParser::BlockStatementContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(575);
      block();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<azslParser::ExpressionStatementContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(576);
      antlrcpp::downCast<ExpressionStatementContext *>(_localctx)->Expr = expressionExt(0);
      setState(577);
      match(azslParser::Semi);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<azslParser::IfStatementContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(582);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(579);
        attributeSpecifier();
        setState(584);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(585);
      match(azslParser::If);
      setState(586);
      match(azslParser::LeftParen);
      setState(587);
      antlrcpp::downCast<IfStatementContext *>(_localctx)->Condition = expressionExt(0);
      setState(588);
      match(azslParser::RightParen);
      setState(589);
      antlrcpp::downCast<IfStatementContext *>(_localctx)->Stmt = embeddedStatement();
      setState(591);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
      case 1: {
        setState(590);
        elseClause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<azslParser::SwitchStatementContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(596);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(593);
        attributeSpecifier();
        setState(598);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(599);
      match(azslParser::Switch);
      setState(600);
      match(azslParser::LeftParen);
      setState(601);
      antlrcpp::downCast<SwitchStatementContext *>(_localctx)->Expr = expressionExt(0);
      setState(602);
      match(azslParser::RightParen);
      setState(603);
      switchBlock();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<azslParser::WhileStatementContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(608);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(605);
        attributeSpecifier();
        setState(610);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(611);
      match(azslParser::While);
      setState(612);
      match(azslParser::LeftParen);
      setState(613);
      antlrcpp::downCast<WhileStatementContext *>(_localctx)->Condition = expressionExt(0);
      setState(614);
      match(azslParser::RightParen);
      setState(615);
      embeddedStatement();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<azslParser::DoStatementContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(620);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(617);
        attributeSpecifier();
        setState(622);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(623);
      match(azslParser::Do);
      setState(624);
      embeddedStatement();
      setState(625);
      match(azslParser::While);
      setState(626);
      match(azslParser::LeftParen);
      setState(627);
      antlrcpp::downCast<DoStatementContext *>(_localctx)->Condition = expressionExt(0);
      setState(628);
      match(azslParser::RightParen);
      setState(629);
      match(azslParser::Semi);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<azslParser::ForStatementContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(634);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(631);
        attributeSpecifier();
        setState(636);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(637);
      match(azslParser::For);
      setState(638);
      match(azslParser::LeftParen);
      setState(640);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & -97) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 256)) & 155374187144347583) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 320)) & 33777572730974223) != 0)) {
        setState(639);
        forInitializer();
      }
      setState(642);
      match(azslParser::Semi);
      setState(644);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & 281474926379007) != 0) || ((((_la - 307) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 307)) & 211106870190081) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 371)) & 15) != 0)) {
        setState(643);
        antlrcpp::downCast<ForStatementContext *>(_localctx)->Condition = expressionExt(0);
      }
      setState(646);
      match(azslParser::Semi);
      setState(648);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & 281474926379007) != 0) || ((((_la - 307) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 307)) & 211106870190081) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 371)) & 15) != 0)) {
        setState(647);
        antlrcpp::downCast<ForStatementContext *>(_localctx)->iterator = expressionExt(0);
      }
      setState(650);
      match(azslParser::RightParen);
      setState(651);
      embeddedStatement();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<azslParser::BreakStatementContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(652);
      match(azslParser::Break);
      setState(653);
      match(azslParser::Semi);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<azslParser::ContinueStatementContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(654);
      match(azslParser::Continue);
      setState(655);
      match(azslParser::Semi);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<azslParser::DiscardStatementContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(656);
      match(azslParser::Discard);
      setState(657);
      match(azslParser::Semi);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<azslParser::ReturnStatementContext>(_localctx);
      enterOuterAlt(_localctx, 12);
      setState(658);
      match(azslParser::Return);
      setState(660);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & 281474926379007) != 0) || ((((_la - 307) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 307)) & 211106870190081) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 371)) & 15) != 0)) {
        setState(659);
        antlrcpp::downCast<ReturnStatementContext *>(_localctx)->Expr = expressionExt(0);
      }
      setState(662);
      match(azslParser::Semi);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<azslParser::ExtenstionStatementContext>(_localctx);
      enterOuterAlt(_localctx, 13);
      setState(663);
      compilerExtensionStatement();
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<azslParser::TypeAliasingDefinitionStatementLabelContext>(_localctx);
      enterOuterAlt(_localctx, 14);
      setState(664);
      typeAliasingDefinitionStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseClauseContext ------------------------------------------------------------------

azslParser::ElseClauseContext::ElseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ElseClauseContext::Else() {
  return getToken(azslParser::Else, 0);
}

azslParser::EmbeddedStatementContext* azslParser::ElseClauseContext::embeddedStatement() {
  return getRuleContext<azslParser::EmbeddedStatementContext>(0);
}


size_t azslParser::ElseClauseContext::getRuleIndex() const {
  return azslParser::RuleElseClause;
}

void azslParser::ElseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseClause(this);
}

void azslParser::ElseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseClause(this);
}

azslParser::ElseClauseContext* azslParser::elseClause() {
  ElseClauseContext *_localctx = _tracker.createInstance<ElseClauseContext>(_ctx, getState());
  enterRule(_localctx, 84, azslParser::RuleElseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(667);
    match(azslParser::Else);
    setState(668);
    antlrcpp::downCast<ElseClauseContext *>(_localctx)->Stmt = embeddedStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::ExpressionContext::getRuleIndex() const {
  return azslParser::RuleExpression;
}

void azslParser::ExpressionContext::copyFrom(ExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ParenthesizedExpressionContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::ParenthesizedExpressionContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::ExpressionExtContext* azslParser::ParenthesizedExpressionContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}
void azslParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}
//----------------- MemberAccessExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext* azslParser::MemberAccessExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

tree::TerminalNode* azslParser::MemberAccessExpressionContext::Dot() {
  return getToken(azslParser::Dot, 0);
}

azslParser::IdExpressionContext* azslParser::MemberAccessExpressionContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}

azslParser::MemberAccessExpressionContext::MemberAccessExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::MemberAccessExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberAccessExpression(this);
}
void azslParser::MemberAccessExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberAccessExpression(this);
}
//----------------- PrefixUnaryExpressionContext ------------------------------------------------------------------

azslParser::PrefixUnaryOperatorContext* azslParser::PrefixUnaryExpressionContext::prefixUnaryOperator() {
  return getRuleContext<azslParser::PrefixUnaryOperatorContext>(0);
}

azslParser::ExpressionContext* azslParser::PrefixUnaryExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::PrefixUnaryExpressionContext::PrefixUnaryExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::PrefixUnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefixUnaryExpression(this);
}
void azslParser::PrefixUnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefixUnaryExpression(this);
}
//----------------- LiteralExpressionContext ------------------------------------------------------------------

azslParser::LiteralContext* azslParser::LiteralExpressionContext::literal() {
  return getRuleContext<azslParser::LiteralContext>(0);
}

azslParser::LiteralExpressionContext::LiteralExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::LiteralExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralExpression(this);
}
void azslParser::LiteralExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralExpression(this);
}
//----------------- ConditionalExpressionContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ConditionalExpressionContext::Question() {
  return getToken(azslParser::Question, 0);
}

tree::TerminalNode* azslParser::ConditionalExpressionContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::ExpressionContext* azslParser::ConditionalExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

std::vector<azslParser::ExpressionExtContext *> azslParser::ConditionalExpressionContext::expressionExt() {
  return getRuleContexts<azslParser::ExpressionExtContext>();
}

azslParser::ExpressionExtContext* azslParser::ConditionalExpressionContext::expressionExt(size_t i) {
  return getRuleContext<azslParser::ExpressionExtContext>(i);
}

azslParser::ConditionalExpressionContext::ConditionalExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::ConditionalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionalExpression(this);
}
void azslParser::ConditionalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionalExpression(this);
}
//----------------- PostfixUnaryExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext* azslParser::PostfixUnaryExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::PostfixUnaryOperatorContext* azslParser::PostfixUnaryExpressionContext::postfixUnaryOperator() {
  return getRuleContext<azslParser::PostfixUnaryOperatorContext>(0);
}

azslParser::PostfixUnaryExpressionContext::PostfixUnaryExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::PostfixUnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfixUnaryExpression(this);
}
void azslParser::PostfixUnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfixUnaryExpression(this);
}
//----------------- NumericConstructorExpressionContext ------------------------------------------------------------------

azslParser::ScalarOrVectorOrMatrixTypeContext* azslParser::NumericConstructorExpressionContext::scalarOrVectorOrMatrixType() {
  return getRuleContext<azslParser::ScalarOrVectorOrMatrixTypeContext>(0);
}

azslParser::ArgumentListContext* azslParser::NumericConstructorExpressionContext::argumentList() {
  return getRuleContext<azslParser::ArgumentListContext>(0);
}

azslParser::NumericConstructorExpressionContext::NumericConstructorExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::NumericConstructorExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericConstructorExpression(this);
}
void azslParser::NumericConstructorExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericConstructorExpression(this);
}
//----------------- FunctionCallExpressionContext ------------------------------------------------------------------

azslParser::ArgumentListContext* azslParser::FunctionCallExpressionContext::argumentList() {
  return getRuleContext<azslParser::ArgumentListContext>(0);
}

azslParser::ExpressionContext* azslParser::FunctionCallExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::FunctionCallExpressionContext::FunctionCallExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::FunctionCallExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCallExpression(this);
}
void azslParser::FunctionCallExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCallExpression(this);
}
//----------------- IdentifierExpressionContext ------------------------------------------------------------------

azslParser::IdExpressionContext* azslParser::IdentifierExpressionContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}

azslParser::IdentifierExpressionContext::IdentifierExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::IdentifierExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierExpression(this);
}
void azslParser::IdentifierExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierExpression(this);
}
//----------------- BinaryExpressionContext ------------------------------------------------------------------

std::vector<azslParser::ExpressionContext *> azslParser::BinaryExpressionContext::expression() {
  return getRuleContexts<azslParser::ExpressionContext>();
}

azslParser::ExpressionContext* azslParser::BinaryExpressionContext::expression(size_t i) {
  return getRuleContext<azslParser::ExpressionContext>(i);
}

azslParser::BinaryOperatorContext* azslParser::BinaryExpressionContext::binaryOperator() {
  return getRuleContext<azslParser::BinaryOperatorContext>(0);
}

azslParser::BinaryExpressionContext::BinaryExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::BinaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryExpression(this);
}
void azslParser::BinaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryExpression(this);
}
//----------------- AssignmentExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext* azslParser::AssignmentExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::AssignmentOperatorContext* azslParser::AssignmentExpressionContext::assignmentOperator() {
  return getRuleContext<azslParser::AssignmentOperatorContext>(0);
}

azslParser::ExpressionExtContext* azslParser::AssignmentExpressionContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

azslParser::AssignmentExpressionContext::AssignmentExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}
void azslParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}
//----------------- CastExpressionContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::CastExpressionContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

azslParser::TypeContext* azslParser::CastExpressionContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::CastExpressionContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::ExpressionContext* azslParser::CastExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

std::vector<azslParser::ArrayRankSpecifierContext *> azslParser::CastExpressionContext::arrayRankSpecifier() {
  return getRuleContexts<azslParser::ArrayRankSpecifierContext>();
}

azslParser::ArrayRankSpecifierContext* azslParser::CastExpressionContext::arrayRankSpecifier(size_t i) {
  return getRuleContext<azslParser::ArrayRankSpecifierContext>(i);
}

azslParser::CastExpressionContext::CastExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::CastExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastExpression(this);
}
void azslParser::CastExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastExpression(this);
}
//----------------- ArrayAccessExpressionContext ------------------------------------------------------------------

tree::TerminalNode* azslParser::ArrayAccessExpressionContext::LeftBracket() {
  return getToken(azslParser::LeftBracket, 0);
}

tree::TerminalNode* azslParser::ArrayAccessExpressionContext::RightBracket() {
  return getToken(azslParser::RightBracket, 0);
}

std::vector<azslParser::ExpressionContext *> azslParser::ArrayAccessExpressionContext::expression() {
  return getRuleContexts<azslParser::ExpressionContext>();
}

azslParser::ExpressionContext* azslParser::ArrayAccessExpressionContext::expression(size_t i) {
  return getRuleContext<azslParser::ExpressionContext>(i);
}

azslParser::ArrayAccessExpressionContext::ArrayAccessExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void azslParser::ArrayAccessExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayAccessExpression(this);
}
void azslParser::ArrayAccessExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayAccessExpression(this);
}

azslParser::ExpressionContext* azslParser::expression() {
   return expression(0);
}

azslParser::ExpressionContext* azslParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  azslParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  azslParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 86;
  enterRecursionRule(_localctx, 86, azslParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(694);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LiteralExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(671);
      literal();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<IdentifierExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(672);
      idExpression();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(673);
      match(azslParser::LeftParen);
      setState(674);
      antlrcpp::downCast<ParenthesizedExpressionContext *>(_localctx)->Expr = expressionExt(0);
      setState(675);
      match(azslParser::RightParen);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NumericConstructorExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(677);
      scalarOrVectorOrMatrixType();
      setState(678);
      argumentList();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<CastExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(680);
      match(azslParser::LeftParen);
      setState(681);
      type();
      setState(685);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == azslParser::LeftBracket) {
        setState(682);
        antlrcpp::downCast<CastExpressionContext *>(_localctx)->arrayRankSpecifierContext = arrayRankSpecifier();
        antlrcpp::downCast<CastExpressionContext *>(_localctx)->ArrayRankSpecifiers.push_back(antlrcpp::downCast<CastExpressionContext *>(_localctx)->arrayRankSpecifierContext);
        setState(687);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(688);
      match(azslParser::RightParen);
      setState(689);
      antlrcpp::downCast<CastExpressionContext *>(_localctx)->Expr = expression(6);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<PrefixUnaryExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(691);
      antlrcpp::downCast<PrefixUnaryExpressionContext *>(_localctx)->Operator = prefixUnaryOperator();
      setState(692);
      antlrcpp::downCast<PrefixUnaryExpressionContext *>(_localctx)->Expr = expression(4);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(724);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(722);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<BinaryExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(696);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(697);
          antlrcpp::downCast<BinaryExpressionContext *>(_localctx)->Operator = binaryOperator();
          setState(698);
          antlrcpp::downCast<BinaryExpressionContext *>(_localctx)->Right = expression(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<MemberAccessExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->LHSExpr = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(700);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(701);
          antlrcpp::downCast<MemberAccessExpressionContext *>(_localctx)->DotToken = match(azslParser::Dot);
          setState(702);
          antlrcpp::downCast<MemberAccessExpressionContext *>(_localctx)->Member = idExpression();
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ArrayAccessExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Expr = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(703);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(704);
          match(azslParser::LeftBracket);
          setState(705);
          antlrcpp::downCast<ArrayAccessExpressionContext *>(_localctx)->Index = expression(0);
          setState(706);
          match(azslParser::RightBracket);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<FunctionCallExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Expr = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(708);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(709);
          argumentList();
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<PostfixUnaryExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Expr = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(710);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(711);
          antlrcpp::downCast<PostfixUnaryExpressionContext *>(_localctx)->Operator = postfixUnaryOperator();
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<ConditionalExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Condition = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(712);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(713);
          match(azslParser::Question);
          setState(714);
          antlrcpp::downCast<ConditionalExpressionContext *>(_localctx)->TrueExpr = expressionExt(0);
          setState(715);
          match(azslParser::Colon);
          setState(716);
          antlrcpp::downCast<ConditionalExpressionContext *>(_localctx)->FalseExpr = expressionExt(0);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<AssignmentExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->Left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(718);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(719);
          antlrcpp::downCast<AssignmentExpressionContext *>(_localctx)->Operator = assignmentOperator();
          setState(720);
          antlrcpp::downCast<AssignmentExpressionContext *>(_localctx)->Right = expressionExt(0);
          break;
        }

        default:
          break;
        } 
      }
      setState(726);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ExpressionExtContext ------------------------------------------------------------------

azslParser::ExpressionExtContext::ExpressionExtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t azslParser::ExpressionExtContext::getRuleIndex() const {
  return azslParser::RuleExpressionExt;
}

void azslParser::ExpressionExtContext::copyFrom(ExpressionExtContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- OtherExpressionContext ------------------------------------------------------------------

azslParser::ExpressionContext* azslParser::OtherExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::OtherExpressionContext::OtherExpressionContext(ExpressionExtContext *ctx) { copyFrom(ctx); }

void azslParser::OtherExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOtherExpression(this);
}
void azslParser::OtherExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOtherExpression(this);
}
//----------------- CommaExpressionContext ------------------------------------------------------------------

azslParser::ExpressionExtContext* azslParser::CommaExpressionContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

tree::TerminalNode* azslParser::CommaExpressionContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

azslParser::ExpressionContext* azslParser::CommaExpressionContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}

azslParser::CommaExpressionContext::CommaExpressionContext(ExpressionExtContext *ctx) { copyFrom(ctx); }

void azslParser::CommaExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommaExpression(this);
}
void azslParser::CommaExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommaExpression(this);
}

azslParser::ExpressionExtContext* azslParser::expressionExt() {
   return expressionExt(0);
}

azslParser::ExpressionExtContext* azslParser::expressionExt(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  azslParser::ExpressionExtContext *_localctx = _tracker.createInstance<ExpressionExtContext>(_ctx, parentState);
  azslParser::ExpressionExtContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 88;
  enterRecursionRule(_localctx, 88, azslParser::RuleExpressionExt, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<OtherExpressionContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(728);
    antlrcpp::downCast<OtherExpressionContext *>(_localctx)->Expr = expression(0);
    _ctx->stop = _input->LT(-1);
    setState(735);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<CommaExpressionContext>(_tracker.createInstance<ExpressionExtContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->Left = previousContext;
        pushNewRecursionContext(newContext, startState, RuleExpressionExt);
        setState(730);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(731);
        antlrcpp::downCast<CommaExpressionContext *>(_localctx)->Operator = match(azslParser::Comma);
        setState(732);
        antlrcpp::downCast<CommaExpressionContext *>(_localctx)->Right = expression(0); 
      }
      setState(737);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PostfixUnaryOperatorContext ------------------------------------------------------------------

azslParser::PostfixUnaryOperatorContext::PostfixUnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::PostfixUnaryOperatorContext::PlusPlus() {
  return getToken(azslParser::PlusPlus, 0);
}

tree::TerminalNode* azslParser::PostfixUnaryOperatorContext::MinusMinus() {
  return getToken(azslParser::MinusMinus, 0);
}


size_t azslParser::PostfixUnaryOperatorContext::getRuleIndex() const {
  return azslParser::RulePostfixUnaryOperator;
}

void azslParser::PostfixUnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfixUnaryOperator(this);
}

void azslParser::PostfixUnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfixUnaryOperator(this);
}

azslParser::PostfixUnaryOperatorContext* azslParser::postfixUnaryOperator() {
  PostfixUnaryOperatorContext *_localctx = _tracker.createInstance<PostfixUnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 90, azslParser::RulePostfixUnaryOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(738);
    _la = _input->LA(1);
    if (!(_la == azslParser::PlusPlus

    || _la == azslParser::MinusMinus)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrefixUnaryOperatorContext ------------------------------------------------------------------

azslParser::PrefixUnaryOperatorContext::PrefixUnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::Plus() {
  return getToken(azslParser::Plus, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::Minus() {
  return getToken(azslParser::Minus, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::Not() {
  return getToken(azslParser::Not, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::Tilde() {
  return getToken(azslParser::Tilde, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::PlusPlus() {
  return getToken(azslParser::PlusPlus, 0);
}

tree::TerminalNode* azslParser::PrefixUnaryOperatorContext::MinusMinus() {
  return getToken(azslParser::MinusMinus, 0);
}


size_t azslParser::PrefixUnaryOperatorContext::getRuleIndex() const {
  return azslParser::RulePrefixUnaryOperator;
}

void azslParser::PrefixUnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefixUnaryOperator(this);
}

void azslParser::PrefixUnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefixUnaryOperator(this);
}

azslParser::PrefixUnaryOperatorContext* azslParser::prefixUnaryOperator() {
  PrefixUnaryOperatorContext *_localctx = _tracker.createInstance<PrefixUnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 92, azslParser::RulePrefixUnaryOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(740);
    _la = _input->LA(1);
    if (!(((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & 12303) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryOperatorContext ------------------------------------------------------------------

azslParser::BinaryOperatorContext::BinaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Star() {
  return getToken(azslParser::Star, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Div() {
  return getToken(azslParser::Div, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Mod() {
  return getToken(azslParser::Mod, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Plus() {
  return getToken(azslParser::Plus, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Minus() {
  return getToken(azslParser::Minus, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::LeftShift() {
  return getToken(azslParser::LeftShift, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::RightShift() {
  return getToken(azslParser::RightShift, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Less() {
  return getToken(azslParser::Less, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::LessEqual() {
  return getToken(azslParser::LessEqual, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::GreaterEqual() {
  return getToken(azslParser::GreaterEqual, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Equal() {
  return getToken(azslParser::Equal, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::NotEqual() {
  return getToken(azslParser::NotEqual, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::And() {
  return getToken(azslParser::And, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Caret() {
  return getToken(azslParser::Caret, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::Or() {
  return getToken(azslParser::Or, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::AndAnd() {
  return getToken(azslParser::AndAnd, 0);
}

tree::TerminalNode* azslParser::BinaryOperatorContext::OrOr() {
  return getToken(azslParser::OrOr, 0);
}


size_t azslParser::BinaryOperatorContext::getRuleIndex() const {
  return azslParser::RuleBinaryOperator;
}

void azslParser::BinaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryOperator(this);
}

void azslParser::BinaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryOperator(this);
}

azslParser::BinaryOperatorContext* azslParser::binaryOperator() {
  BinaryOperatorContext *_localctx = _tracker.createInstance<BinaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 94, azslParser::RuleBinaryOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(742);
    _la = _input->LA(1);
    if (!(((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & 206158691711) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

azslParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::StarAssign() {
  return getToken(azslParser::StarAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::DivAssign() {
  return getToken(azslParser::DivAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::ModAssign() {
  return getToken(azslParser::ModAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::PlusAssign() {
  return getToken(azslParser::PlusAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::MinusAssign() {
  return getToken(azslParser::MinusAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::LeftShiftAssign() {
  return getToken(azslParser::LeftShiftAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::RightShiftAssign() {
  return getToken(azslParser::RightShiftAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::AndAssign() {
  return getToken(azslParser::AndAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::XorAssign() {
  return getToken(azslParser::XorAssign, 0);
}

tree::TerminalNode* azslParser::AssignmentOperatorContext::OrAssign() {
  return getToken(azslParser::OrAssign, 0);
}


size_t azslParser::AssignmentOperatorContext::getRuleIndex() const {
  return azslParser::RuleAssignmentOperator;
}

void azslParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void azslParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

azslParser::AssignmentOperatorContext* azslParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 96, azslParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(744);
    _la = _input->LA(1);
    if (!(((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & 2047) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentListContext ------------------------------------------------------------------

azslParser::ArgumentListContext::ArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ArgumentListContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::ArgumentListContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::ArgumentsContext* azslParser::ArgumentListContext::arguments() {
  return getRuleContext<azslParser::ArgumentsContext>(0);
}


size_t azslParser::ArgumentListContext::getRuleIndex() const {
  return azslParser::RuleArgumentList;
}

void azslParser::ArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgumentList(this);
}

void azslParser::ArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgumentList(this);
}

azslParser::ArgumentListContext* azslParser::argumentList() {
  ArgumentListContext *_localctx = _tracker.createInstance<ArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 98, azslParser::RuleArgumentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(746);
    match(azslParser::LeftParen);
    setState(748);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & 281474926379007) != 0) || ((((_la - 307) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 307)) & 211106870190081) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 371)) & 15) != 0)) {
      setState(747);
      arguments();
    }
    setState(750);
    match(azslParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

azslParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::ExpressionContext *> azslParser::ArgumentsContext::expression() {
  return getRuleContexts<azslParser::ExpressionContext>();
}

azslParser::ExpressionContext* azslParser::ArgumentsContext::expression(size_t i) {
  return getRuleContext<azslParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::ArgumentsContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::ArgumentsContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::ArgumentsContext::getRuleIndex() const {
  return azslParser::RuleArguments;
}

void azslParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void azslParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}

azslParser::ArgumentsContext* azslParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 100, azslParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(752);
    expression(0);
    setState(757);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(753);
      match(azslParser::Comma);
      setState(754);
      expression(0);
      setState(759);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

azslParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TypeContext* azslParser::VariableDeclarationContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

azslParser::VariableDeclaratorsContext* azslParser::VariableDeclarationContext::variableDeclarators() {
  return getRuleContext<azslParser::VariableDeclaratorsContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::VariableDeclarationContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::VariableDeclarationContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::VariableDeclarationContext::getRuleIndex() const {
  return azslParser::RuleVariableDeclaration;
}

void azslParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void azslParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}

azslParser::VariableDeclarationContext* azslParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 102, azslParser::RuleVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(763);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(760);
      attributeSpecifierAny();
      setState(765);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(766);
    type();
    setState(767);
    variableDeclarators();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclaratorsContext ------------------------------------------------------------------

azslParser::VariableDeclaratorsContext::VariableDeclaratorsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::NamedVariableDeclaratorContext *> azslParser::VariableDeclaratorsContext::namedVariableDeclarator() {
  return getRuleContexts<azslParser::NamedVariableDeclaratorContext>();
}

azslParser::NamedVariableDeclaratorContext* azslParser::VariableDeclaratorsContext::namedVariableDeclarator(size_t i) {
  return getRuleContext<azslParser::NamedVariableDeclaratorContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::VariableDeclaratorsContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::VariableDeclaratorsContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::VariableDeclaratorsContext::getRuleIndex() const {
  return azslParser::RuleVariableDeclarators;
}

void azslParser::VariableDeclaratorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarators(this);
}

void azslParser::VariableDeclaratorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarators(this);
}

azslParser::VariableDeclaratorsContext* azslParser::variableDeclarators() {
  VariableDeclaratorsContext *_localctx = _tracker.createInstance<VariableDeclaratorsContext>(_ctx, getState());
  enterRule(_localctx, 104, azslParser::RuleVariableDeclarators);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(769);
    antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->namedVariableDeclaratorContext = namedVariableDeclarator();
    antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->VarDecls.push_back(antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->namedVariableDeclaratorContext);
    setState(774);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(770);
      match(azslParser::Comma);
      setState(771);
      antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->namedVariableDeclaratorContext = namedVariableDeclarator();
      antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->VarDecls.push_back(antlrcpp::downCast<VariableDeclaratorsContext *>(_localctx)->namedVariableDeclaratorContext);
      setState(776);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnnamedVariableDeclaratorContext ------------------------------------------------------------------

azslParser::UnnamedVariableDeclaratorContext::UnnamedVariableDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::PackOffsetNodeContext* azslParser::UnnamedVariableDeclaratorContext::packOffsetNode() {
  return getRuleContext<azslParser::PackOffsetNodeContext>(0);
}

azslParser::VariableInitializerContext* azslParser::UnnamedVariableDeclaratorContext::variableInitializer() {
  return getRuleContext<azslParser::VariableInitializerContext>(0);
}

std::vector<azslParser::ArrayRankSpecifierContext *> azslParser::UnnamedVariableDeclaratorContext::arrayRankSpecifier() {
  return getRuleContexts<azslParser::ArrayRankSpecifierContext>();
}

azslParser::ArrayRankSpecifierContext* azslParser::UnnamedVariableDeclaratorContext::arrayRankSpecifier(size_t i) {
  return getRuleContext<azslParser::ArrayRankSpecifierContext>(i);
}

azslParser::HlslSemanticContext* azslParser::UnnamedVariableDeclaratorContext::hlslSemantic() {
  return getRuleContext<azslParser::HlslSemanticContext>(0);
}

azslParser::RegisterAllocationContext* azslParser::UnnamedVariableDeclaratorContext::registerAllocation() {
  return getRuleContext<azslParser::RegisterAllocationContext>(0);
}


size_t azslParser::UnnamedVariableDeclaratorContext::getRuleIndex() const {
  return azslParser::RuleUnnamedVariableDeclarator;
}

void azslParser::UnnamedVariableDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnnamedVariableDeclarator(this);
}

void azslParser::UnnamedVariableDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnnamedVariableDeclarator(this);
}

azslParser::UnnamedVariableDeclaratorContext* azslParser::unnamedVariableDeclarator() {
  UnnamedVariableDeclaratorContext *_localctx = _tracker.createInstance<UnnamedVariableDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 106, azslParser::RuleUnnamedVariableDeclarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(780);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket) {
      setState(777);
      antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->arrayRankSpecifierContext = arrayRankSpecifier();
      antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->ArrayRankSpecifiers.push_back(antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->arrayRankSpecifierContext);
      setState(782);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(784);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
    case 1: {
      setState(783);
      antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->SemanticOpt = hlslSemantic();
      break;
    }

    default:
      break;
    }
    setState(787);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
    case 1: {
      setState(786);
      packOffsetNode();
      break;
    }

    default:
      break;
    }
    setState(790);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(789);
      antlrcpp::downCast<UnnamedVariableDeclaratorContext *>(_localctx)->RegisterAllocation = registerAllocation();
    }
    setState(793);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::LeftBrace

    || _la == azslParser::Assign) {
      setState(792);
      variableInitializer();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedVariableDeclaratorContext ------------------------------------------------------------------

azslParser::NamedVariableDeclaratorContext::NamedVariableDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::UnnamedVariableDeclaratorContext* azslParser::NamedVariableDeclaratorContext::unnamedVariableDeclarator() {
  return getRuleContext<azslParser::UnnamedVariableDeclaratorContext>(0);
}

tree::TerminalNode* azslParser::NamedVariableDeclaratorContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::NamedVariableDeclaratorContext::getRuleIndex() const {
  return azslParser::RuleNamedVariableDeclarator;
}

void azslParser::NamedVariableDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedVariableDeclarator(this);
}

void azslParser::NamedVariableDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedVariableDeclarator(this);
}

azslParser::NamedVariableDeclaratorContext* azslParser::namedVariableDeclarator() {
  NamedVariableDeclaratorContext *_localctx = _tracker.createInstance<NamedVariableDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 108, azslParser::RuleNamedVariableDeclarator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    antlrcpp::downCast<NamedVariableDeclaratorContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(796);
    unnamedVariableDeclarator();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableInitializerContext ------------------------------------------------------------------

azslParser::VariableInitializerContext::VariableInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::VariableInitializerContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::StandardVariableInitializerContext* azslParser::VariableInitializerContext::standardVariableInitializer() {
  return getRuleContext<azslParser::StandardVariableInitializerContext>(0);
}

azslParser::SamplerBodyDeclarationContext* azslParser::VariableInitializerContext::samplerBodyDeclaration() {
  return getRuleContext<azslParser::SamplerBodyDeclarationContext>(0);
}


size_t azslParser::VariableInitializerContext::getRuleIndex() const {
  return azslParser::RuleVariableInitializer;
}

void azslParser::VariableInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableInitializer(this);
}

void azslParser::VariableInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableInitializer(this);
}

azslParser::VariableInitializerContext* azslParser::variableInitializer() {
  VariableInitializerContext *_localctx = _tracker.createInstance<VariableInitializerContext>(_ctx, getState());
  enterRule(_localctx, 110, azslParser::RuleVariableInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(801);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Assign: {
        enterOuterAlt(_localctx, 1);
        setState(798);
        match(azslParser::Assign);
        setState(799);
        standardVariableInitializer();
        break;
      }

      case azslParser::LeftBrace: {
        enterOuterAlt(_localctx, 2);
        setState(800);
        samplerBodyDeclaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StandardVariableInitializerContext ------------------------------------------------------------------

azslParser::StandardVariableInitializerContext::StandardVariableInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StandardVariableInitializerContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

azslParser::ArrayElementInitializersContext* azslParser::StandardVariableInitializerContext::arrayElementInitializers() {
  return getRuleContext<azslParser::ArrayElementInitializersContext>(0);
}

tree::TerminalNode* azslParser::StandardVariableInitializerContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

azslParser::ExpressionContext* azslParser::StandardVariableInitializerContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}


size_t azslParser::StandardVariableInitializerContext::getRuleIndex() const {
  return azslParser::RuleStandardVariableInitializer;
}

void azslParser::StandardVariableInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandardVariableInitializer(this);
}

void azslParser::StandardVariableInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandardVariableInitializer(this);
}

azslParser::StandardVariableInitializerContext* azslParser::standardVariableInitializer() {
  StandardVariableInitializerContext *_localctx = _tracker.createInstance<StandardVariableInitializerContext>(_ctx, getState());
  enterRule(_localctx, 112, azslParser::RuleStandardVariableInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(808);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::LeftBrace: {
        enterOuterAlt(_localctx, 1);
        setState(803);
        match(azslParser::LeftBrace);
        setState(804);
        arrayElementInitializers();
        setState(805);
        match(azslParser::RightBrace);
        break;
      }

      case azslParser::Bool:
      case azslParser::Bool1:
      case azslParser::Bool2:
      case azslParser::Bool3:
      case azslParser::Bool4:
      case azslParser::Bool1x1:
      case azslParser::Bool1x2:
      case azslParser::Bool1x3:
      case azslParser::Bool1x4:
      case azslParser::Bool2x1:
      case azslParser::Bool2x2:
      case azslParser::Bool2x3:
      case azslParser::Bool2x4:
      case azslParser::Bool3x1:
      case azslParser::Bool3x2:
      case azslParser::Bool3x3:
      case azslParser::Bool3x4:
      case azslParser::Bool4x1:
      case azslParser::Bool4x2:
      case azslParser::Bool4x3:
      case azslParser::Bool4x4:
      case azslParser::Double:
      case azslParser::Double1:
      case azslParser::Double2:
      case azslParser::Double3:
      case azslParser::Double4:
      case azslParser::Double1x1:
      case azslParser::Double1x2:
      case azslParser::Double1x3:
      case azslParser::Double1x4:
      case azslParser::Double2x1:
      case azslParser::Double2x2:
      case azslParser::Double2x3:
      case azslParser::Double2x4:
      case azslParser::Double3x1:
      case azslParser::Double3x2:
      case azslParser::Double3x3:
      case azslParser::Double3x4:
      case azslParser::Double4x1:
      case azslParser::Double4x2:
      case azslParser::Double4x3:
      case azslParser::Double4x4:
      case azslParser::Float:
      case azslParser::Float1:
      case azslParser::Float2:
      case azslParser::Float3:
      case azslParser::Float4:
      case azslParser::Float1x1:
      case azslParser::Float1x2:
      case azslParser::Float1x3:
      case azslParser::Float1x4:
      case azslParser::Float2x1:
      case azslParser::Float2x2:
      case azslParser::Float2x3:
      case azslParser::Float2x4:
      case azslParser::Float3x1:
      case azslParser::Float3x2:
      case azslParser::Float3x3:
      case azslParser::Float3x4:
      case azslParser::Float4x1:
      case azslParser::Float4x2:
      case azslParser::Float4x3:
      case azslParser::Float4x4:
      case azslParser::Half:
      case azslParser::Half1:
      case azslParser::Half2:
      case azslParser::Half3:
      case azslParser::Half4:
      case azslParser::Half1x1:
      case azslParser::Half1x2:
      case azslParser::Half1x3:
      case azslParser::Half1x4:
      case azslParser::Half2x1:
      case azslParser::Half2x2:
      case azslParser::Half2x3:
      case azslParser::Half2x4:
      case azslParser::Half3x1:
      case azslParser::Half3x2:
      case azslParser::Half3x3:
      case azslParser::Half3x4:
      case azslParser::Half4x1:
      case azslParser::Half4x2:
      case azslParser::Half4x3:
      case azslParser::Half4x4:
      case azslParser::Int:
      case azslParser::Int16_t:
      case azslParser::Int32_t:
      case azslParser::Int64_t:
      case azslParser::Int1:
      case azslParser::Int2:
      case azslParser::Int3:
      case azslParser::Int4:
      case azslParser::Int1x1:
      case azslParser::Int1x2:
      case azslParser::Int1x3:
      case azslParser::Int1x4:
      case azslParser::Int2x1:
      case azslParser::Int2x2:
      case azslParser::Int2x3:
      case azslParser::Int2x4:
      case azslParser::Int3x1:
      case azslParser::Int3x2:
      case azslParser::Int3x3:
      case azslParser::Int3x4:
      case azslParser::Int4x1:
      case azslParser::Int4x2:
      case azslParser::Int4x3:
      case azslParser::Int4x4:
      case azslParser::Matrix:
      case azslParser::Uint:
      case azslParser::Uint1:
      case azslParser::Uint2:
      case azslParser::Uint3:
      case azslParser::Uint4:
      case azslParser::Uint1x1:
      case azslParser::Uint1x2:
      case azslParser::Uint1x3:
      case azslParser::Uint1x4:
      case azslParser::Uint2x1:
      case azslParser::Uint2x2:
      case azslParser::Uint2x3:
      case azslParser::Uint2x4:
      case azslParser::Uint3x1:
      case azslParser::Uint3x2:
      case azslParser::Uint3x3:
      case azslParser::Uint3x4:
      case azslParser::Uint4x1:
      case azslParser::Uint4x2:
      case azslParser::Uint4x3:
      case azslParser::Uint4x4:
      case azslParser::Uint16_t:
      case azslParser::Uint32_t:
      case azslParser::Uint64_t:
      case azslParser::Dword:
      case azslParser::Dword1:
      case azslParser::Dword2:
      case azslParser::Dword3:
      case azslParser::Dword4:
      case azslParser::Dword1x1:
      case azslParser::Dword1x2:
      case azslParser::Dword1x3:
      case azslParser::Dword1x4:
      case azslParser::Dword2x1:
      case azslParser::Dword2x2:
      case azslParser::Dword2x3:
      case azslParser::Dword2x4:
      case azslParser::Dword3x1:
      case azslParser::Dword3x2:
      case azslParser::Dword3x3:
      case azslParser::Dword3x4:
      case azslParser::Dword4x1:
      case azslParser::Dword4x2:
      case azslParser::Dword4x3:
      case azslParser::Dword4x4:
      case azslParser::Vector:
      case azslParser::LeftParen:
      case azslParser::Plus:
      case azslParser::PlusPlus:
      case azslParser::Minus:
      case azslParser::MinusMinus:
      case azslParser::Not:
      case azslParser::Tilde:
      case azslParser::ColonColon:
      case azslParser::True:
      case azslParser::False:
      case azslParser::Identifier:
      case azslParser::IntegerLiteral:
      case azslParser::FloatLiteral:
      case azslParser::StringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(807);
        antlrcpp::downCast<StandardVariableInitializerContext *>(_localctx)->Expr = expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayElementInitializersContext ------------------------------------------------------------------

azslParser::ArrayElementInitializersContext::ArrayElementInitializersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::StandardVariableInitializerContext *> azslParser::ArrayElementInitializersContext::standardVariableInitializer() {
  return getRuleContexts<azslParser::StandardVariableInitializerContext>();
}

azslParser::StandardVariableInitializerContext* azslParser::ArrayElementInitializersContext::standardVariableInitializer(size_t i) {
  return getRuleContext<azslParser::StandardVariableInitializerContext>(i);
}

std::vector<tree::TerminalNode *> azslParser::ArrayElementInitializersContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::ArrayElementInitializersContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::ArrayElementInitializersContext::getRuleIndex() const {
  return azslParser::RuleArrayElementInitializers;
}

void azslParser::ArrayElementInitializersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayElementInitializers(this);
}

void azslParser::ArrayElementInitializersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayElementInitializers(this);
}

azslParser::ArrayElementInitializersContext* azslParser::arrayElementInitializers() {
  ArrayElementInitializersContext *_localctx = _tracker.createInstance<ArrayElementInitializersContext>(_ctx, getState());
  enterRule(_localctx, 114, azslParser::RuleArrayElementInitializers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(810);
    standardVariableInitializer();
    setState(815);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(811);
        match(azslParser::Comma);
        setState(812);
        standardVariableInitializer(); 
      }
      setState(817);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx);
    }
    setState(819);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Comma) {
      setState(818);
      match(azslParser::Comma);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayRankSpecifierContext ------------------------------------------------------------------

azslParser::ArrayRankSpecifierContext::ArrayRankSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ArrayRankSpecifierContext::LeftBracket() {
  return getToken(azslParser::LeftBracket, 0);
}

tree::TerminalNode* azslParser::ArrayRankSpecifierContext::RightBracket() {
  return getToken(azslParser::RightBracket, 0);
}

azslParser::ExpressionContext* azslParser::ArrayRankSpecifierContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}


size_t azslParser::ArrayRankSpecifierContext::getRuleIndex() const {
  return azslParser::RuleArrayRankSpecifier;
}

void azslParser::ArrayRankSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayRankSpecifier(this);
}

void azslParser::ArrayRankSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayRankSpecifier(this);
}

azslParser::ArrayRankSpecifierContext* azslParser::arrayRankSpecifier() {
  ArrayRankSpecifierContext *_localctx = _tracker.createInstance<ArrayRankSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 116, azslParser::RuleArrayRankSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(821);
    match(azslParser::LeftBracket);
    setState(823);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2305841909710454780) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & -4433230914650113) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & 266239) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & 281474926379007) != 0) || ((((_la - 307) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 307)) & 211106870190081) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 371)) & 15) != 0)) {
      setState(822);
      antlrcpp::downCast<ArrayRankSpecifierContext *>(_localctx)->Dimension = expression(0);
    }
    setState(825);
    match(azslParser::RightBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PackOffsetNodeContext ------------------------------------------------------------------

azslParser::PackOffsetNodeContext::PackOffsetNodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::Packoffset() {
  return getToken(azslParser::Packoffset, 0);
}

std::vector<tree::TerminalNode *> azslParser::PackOffsetNodeContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

tree::TerminalNode* azslParser::PackOffsetNodeContext::Dot() {
  return getToken(azslParser::Dot, 0);
}


size_t azslParser::PackOffsetNodeContext::getRuleIndex() const {
  return azslParser::RulePackOffsetNode;
}

void azslParser::PackOffsetNodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackOffsetNode(this);
}

void azslParser::PackOffsetNodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackOffsetNode(this);
}

azslParser::PackOffsetNodeContext* azslParser::packOffsetNode() {
  PackOffsetNodeContext *_localctx = _tracker.createInstance<PackOffsetNodeContext>(_ctx, getState());
  enterRule(_localctx, 118, azslParser::RulePackOffsetNode);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(827);
    match(azslParser::Colon);
    setState(828);
    antlrcpp::downCast<PackOffsetNodeContext *>(_localctx)->PackoffsetKeyword = match(azslParser::Packoffset);
    setState(829);
    match(azslParser::LeftParen);
    setState(830);
    antlrcpp::downCast<PackOffsetNodeContext *>(_localctx)->PackOffsetRegister = match(azslParser::Identifier);
    setState(833);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Dot) {
      setState(831);
      match(azslParser::Dot);
      setState(832);
      antlrcpp::downCast<PackOffsetNodeContext *>(_localctx)->PackOffsetComponent = match(azslParser::Identifier);
    }
    setState(835);
    match(azslParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageFlagsContext ------------------------------------------------------------------

azslParser::StorageFlagsContext::StorageFlagsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<azslParser::StorageFlagContext *> azslParser::StorageFlagsContext::storageFlag() {
  return getRuleContexts<azslParser::StorageFlagContext>();
}

azslParser::StorageFlagContext* azslParser::StorageFlagsContext::storageFlag(size_t i) {
  return getRuleContext<azslParser::StorageFlagContext>(i);
}


size_t azslParser::StorageFlagsContext::getRuleIndex() const {
  return azslParser::RuleStorageFlags;
}

void azslParser::StorageFlagsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageFlags(this);
}

void azslParser::StorageFlagsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageFlags(this);
}

azslParser::StorageFlagsContext* azslParser::storageFlags() {
  StorageFlagsContext *_localctx = _tracker.createInstance<StorageFlagsContext>(_ctx, getState());
  enterRule(_localctx, 120, azslParser::RuleStorageFlags);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(840);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(837);
        storageFlag(); 
      }
      setState(842);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageFlagContext ------------------------------------------------------------------

azslParser::StorageFlagContext::StorageFlagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StorageFlagContext::Const() {
  return getToken(azslParser::Const, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Unsigned() {
  return getToken(azslParser::Unsigned, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::RowMajor() {
  return getToken(azslParser::RowMajor, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::ColumnMajor() {
  return getToken(azslParser::ColumnMajor, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Extern() {
  return getToken(azslParser::Extern, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Inline() {
  return getToken(azslParser::Inline, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Rootconstant() {
  return getToken(azslParser::Rootconstant, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Option() {
  return getToken(azslParser::Option, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Precise() {
  return getToken(azslParser::Precise, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Shared() {
  return getToken(azslParser::Shared, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Groupshared() {
  return getToken(azslParser::Groupshared, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Static() {
  return getToken(azslParser::Static, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Uniform() {
  return getToken(azslParser::Uniform, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Volatile() {
  return getToken(azslParser::Volatile, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Globallycoherent() {
  return getToken(azslParser::Globallycoherent, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::SNorm() {
  return getToken(azslParser::SNorm, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::UNorm() {
  return getToken(azslParser::UNorm, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Linear() {
  return getToken(azslParser::Linear, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Centroid() {
  return getToken(azslParser::Centroid, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Nointerpolation() {
  return getToken(azslParser::Nointerpolation, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Noperspective() {
  return getToken(azslParser::Noperspective, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Sample() {
  return getToken(azslParser::Sample, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::In() {
  return getToken(azslParser::In, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Out() {
  return getToken(azslParser::Out, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Inout() {
  return getToken(azslParser::Inout, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Point() {
  return getToken(azslParser::Point, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Line_() {
  return getToken(azslParser::Line_, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Triangle() {
  return getToken(azslParser::Triangle, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::LineAdj() {
  return getToken(azslParser::LineAdj, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::TriangleAdj() {
  return getToken(azslParser::TriangleAdj, 0);
}

tree::TerminalNode* azslParser::StorageFlagContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::StorageFlagContext::getRuleIndex() const {
  return azslParser::RuleStorageFlag;
}

void azslParser::StorageFlagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageFlag(this);
}

void azslParser::StorageFlagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageFlag(this);
}

azslParser::StorageFlagContext* azslParser::storageFlag() {
  StorageFlagContext *_localctx = _tracker.createInstance<StorageFlagContext>(_ctx, getState());
  enterRule(_localctx, 122, azslParser::RuleStorageFlag);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(843);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 26306674688) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 16888498703302657) != 0) || ((((_la - 144) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 144)) & 123420717171655) != 0) || ((((_la - 208) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 208)) & 4503600432676875) != 0) || _la == azslParser::Identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

azslParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StorageFlagsContext* azslParser::TypeContext::storageFlags() {
  return getRuleContext<azslParser::StorageFlagsContext>(0);
}

azslParser::PredefinedTypeContext* azslParser::TypeContext::predefinedType() {
  return getRuleContext<azslParser::PredefinedTypeContext>(0);
}

azslParser::UserDefinedTypeContext* azslParser::TypeContext::userDefinedType() {
  return getRuleContext<azslParser::UserDefinedTypeContext>(0);
}

azslParser::TypeofExpressionContext* azslParser::TypeContext::typeofExpression() {
  return getRuleContext<azslParser::TypeofExpressionContext>(0);
}

tree::TerminalNode* azslParser::TypeContext::Void() {
  return getToken(azslParser::Void, 0);
}


size_t azslParser::TypeContext::getRuleIndex() const {
  return azslParser::RuleType;
}

void azslParser::TypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType(this);
}

void azslParser::TypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType(this);
}

azslParser::TypeContext* azslParser::type() {
  TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
  enterRule(_localctx, 124, azslParser::RuleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(845);
    storageFlags();
    setState(850);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::AppendStructuredBuffer:
      case azslParser::Bool:
      case azslParser::Bool1:
      case azslParser::Bool2:
      case azslParser::Bool3:
      case azslParser::Bool4:
      case azslParser::Bool1x1:
      case azslParser::Bool1x2:
      case azslParser::Bool1x3:
      case azslParser::Bool1x4:
      case azslParser::Bool2x1:
      case azslParser::Bool2x2:
      case azslParser::Bool2x3:
      case azslParser::Bool2x4:
      case azslParser::Bool3x1:
      case azslParser::Bool3x2:
      case azslParser::Bool3x3:
      case azslParser::Bool3x4:
      case azslParser::Bool4x1:
      case azslParser::Bool4x2:
      case azslParser::Bool4x3:
      case azslParser::Bool4x4:
      case azslParser::Buffer:
      case azslParser::BuiltInTriangleIntersectionAttributes:
      case azslParser::ByteAddressBuffer:
      case azslParser::ConstantBuffer:
      case azslParser::ConstantBufferCamel:
      case azslParser::ConsumeStructuredBuffer:
      case azslParser::Double:
      case azslParser::Double1:
      case azslParser::Double2:
      case azslParser::Double3:
      case azslParser::Double4:
      case azslParser::Double1x1:
      case azslParser::Double1x2:
      case azslParser::Double1x3:
      case azslParser::Double1x4:
      case azslParser::Double2x1:
      case azslParser::Double2x2:
      case azslParser::Double2x3:
      case azslParser::Double2x4:
      case azslParser::Double3x1:
      case azslParser::Double3x2:
      case azslParser::Double3x3:
      case azslParser::Double3x4:
      case azslParser::Double4x1:
      case azslParser::Double4x2:
      case azslParser::Double4x3:
      case azslParser::Double4x4:
      case azslParser::Float:
      case azslParser::Float1:
      case azslParser::Float2:
      case azslParser::Float3:
      case azslParser::Float4:
      case azslParser::Float1x1:
      case azslParser::Float1x2:
      case azslParser::Float1x3:
      case azslParser::Float1x4:
      case azslParser::Float2x1:
      case azslParser::Float2x2:
      case azslParser::Float2x3:
      case azslParser::Float2x4:
      case azslParser::Float3x1:
      case azslParser::Float3x2:
      case azslParser::Float3x3:
      case azslParser::Float3x4:
      case azslParser::Float4x1:
      case azslParser::Float4x2:
      case azslParser::Float4x3:
      case azslParser::Float4x4:
      case azslParser::Half:
      case azslParser::Half1:
      case azslParser::Half2:
      case azslParser::Half3:
      case azslParser::Half4:
      case azslParser::Half1x1:
      case azslParser::Half1x2:
      case azslParser::Half1x3:
      case azslParser::Half1x4:
      case azslParser::Half2x1:
      case azslParser::Half2x2:
      case azslParser::Half2x3:
      case azslParser::Half2x4:
      case azslParser::Half3x1:
      case azslParser::Half3x2:
      case azslParser::Half3x3:
      case azslParser::Half3x4:
      case azslParser::Half4x1:
      case azslParser::Half4x2:
      case azslParser::Half4x3:
      case azslParser::Half4x4:
      case azslParser::InputPatch:
      case azslParser::Int:
      case azslParser::Int16_t:
      case azslParser::Int32_t:
      case azslParser::Int64_t:
      case azslParser::Int1:
      case azslParser::Int2:
      case azslParser::Int3:
      case azslParser::Int4:
      case azslParser::Int1x1:
      case azslParser::Int1x2:
      case azslParser::Int1x3:
      case azslParser::Int1x4:
      case azslParser::Int2x1:
      case azslParser::Int2x2:
      case azslParser::Int2x3:
      case azslParser::Int2x4:
      case azslParser::Int3x1:
      case azslParser::Int3x2:
      case azslParser::Int3x3:
      case azslParser::Int3x4:
      case azslParser::Int4x1:
      case azslParser::Int4x2:
      case azslParser::Int4x3:
      case azslParser::Int4x4:
      case azslParser::LineStream:
      case azslParser::Matrix:
      case azslParser::OutputPatch:
      case azslParser::PointStream:
      case azslParser::RasterizerOrderedBuffer:
      case azslParser::RasterizerOrderedByteAddressBuffer:
      case azslParser::RasterizerOrderedStructuredBuffer:
      case azslParser::RasterizerOrderedTexture1D:
      case azslParser::RasterizerOrderedTexture1DArray:
      case azslParser::RasterizerOrderedTexture2D:
      case azslParser::RasterizerOrderedTexture2DArray:
      case azslParser::RasterizerOrderedTexture3D:
      case azslParser::RayDesc:
      case azslParser::RaytracingAccelerationStructure:
      case azslParser::RWBuffer:
      case azslParser::RWByteAddressBuffer:
      case azslParser::RWStructuredBuffer:
      case azslParser::RWTexture1D:
      case azslParser::RWTexture1DArray:
      case azslParser::RWTexture2D:
      case azslParser::RWTexture2DArray:
      case azslParser::RWTexture3D:
      case azslParser::Sampler:
      case azslParser::SamplerCapitalS:
      case azslParser::SamplerComparisonState:
      case azslParser::SamplerStateCamel:
      case azslParser::SamplerState:
      case azslParser::StructuredBuffer:
      case azslParser::SubpassInput:
      case azslParser::SubpassInputMS:
      case azslParser::SubpassInputDS:
      case azslParser::SubpassInputDSMS:
      case azslParser::Texture1D:
      case azslParser::Texture1DArray:
      case azslParser::Texture2D:
      case azslParser::Texture2DArray:
      case azslParser::Texture2DMS:
      case azslParser::Texture2DMSArray:
      case azslParser::Texture3D:
      case azslParser::TextureCube:
      case azslParser::TextureCubeArray:
      case azslParser::TriangleStream:
      case azslParser::Uint:
      case azslParser::Uint1:
      case azslParser::Uint2:
      case azslParser::Uint3:
      case azslParser::Uint4:
      case azslParser::Uint1x1:
      case azslParser::Uint1x2:
      case azslParser::Uint1x3:
      case azslParser::Uint1x4:
      case azslParser::Uint2x1:
      case azslParser::Uint2x2:
      case azslParser::Uint2x3:
      case azslParser::Uint2x4:
      case azslParser::Uint3x1:
      case azslParser::Uint3x2:
      case azslParser::Uint3x3:
      case azslParser::Uint3x4:
      case azslParser::Uint4x1:
      case azslParser::Uint4x2:
      case azslParser::Uint4x3:
      case azslParser::Uint4x4:
      case azslParser::Uint16_t:
      case azslParser::Uint32_t:
      case azslParser::Uint64_t:
      case azslParser::Dword:
      case azslParser::Dword1:
      case azslParser::Dword2:
      case azslParser::Dword3:
      case azslParser::Dword4:
      case azslParser::Dword1x1:
      case azslParser::Dword1x2:
      case azslParser::Dword1x3:
      case azslParser::Dword1x4:
      case azslParser::Dword2x1:
      case azslParser::Dword2x2:
      case azslParser::Dword2x3:
      case azslParser::Dword2x4:
      case azslParser::Dword3x1:
      case azslParser::Dword3x2:
      case azslParser::Dword3x3:
      case azslParser::Dword3x4:
      case azslParser::Dword4x1:
      case azslParser::Dword4x2:
      case azslParser::Dword4x3:
      case azslParser::Dword4x4:
      case azslParser::Vector:
      case azslParser::StateObjectConfig:
      case azslParser::LocalRootSignature:
      case azslParser::GlobalRootSignature:
      case azslParser::SubobjectToExportsAssociation:
      case azslParser::RaytracingShaderConfig:
      case azslParser::RaytracingPipelineConfig:
      case azslParser::RaytracingPipelineConfig1:
      case azslParser::TriangleHitGroup:
      case azslParser::ProceduralPrimitiveHitGroup: {
        setState(846);
        predefinedType();
        break;
      }

      case azslParser::Class:
      case azslParser::Enum:
      case azslParser::Interface:
      case azslParser::Struct:
      case azslParser::ColonColon:
      case azslParser::Identifier: {
        setState(847);
        userDefinedType();
        break;
      }

      case azslParser::KW_Typeof: {
        setState(848);
        typeofExpression();
        break;
      }

      case azslParser::Void: {
        setState(849);
        match(azslParser::Void);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredefinedTypeContext ------------------------------------------------------------------

azslParser::PredefinedTypeContext::PredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::BufferPredefinedTypeContext* azslParser::PredefinedTypeContext::bufferPredefinedType() {
  return getRuleContext<azslParser::BufferPredefinedTypeContext>(0);
}

azslParser::ByteAddressBufferTypesContext* azslParser::PredefinedTypeContext::byteAddressBufferTypes() {
  return getRuleContext<azslParser::ByteAddressBufferTypesContext>(0);
}

azslParser::PatchPredefinedTypeContext* azslParser::PredefinedTypeContext::patchPredefinedType() {
  return getRuleContext<azslParser::PatchPredefinedTypeContext>(0);
}

azslParser::MatrixTypeContext* azslParser::PredefinedTypeContext::matrixType() {
  return getRuleContext<azslParser::MatrixTypeContext>(0);
}

azslParser::GenericMatrixPredefinedTypeContext* azslParser::PredefinedTypeContext::genericMatrixPredefinedType() {
  return getRuleContext<azslParser::GenericMatrixPredefinedTypeContext>(0);
}

azslParser::SamplerStatePredefinedTypeContext* azslParser::PredefinedTypeContext::samplerStatePredefinedType() {
  return getRuleContext<azslParser::SamplerStatePredefinedTypeContext>(0);
}

azslParser::ScalarTypeContext* azslParser::PredefinedTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

azslParser::StreamOutputPredefinedTypeContext* azslParser::PredefinedTypeContext::streamOutputPredefinedType() {
  return getRuleContext<azslParser::StreamOutputPredefinedTypeContext>(0);
}

azslParser::StructuredBufferPredefinedTypeContext* azslParser::PredefinedTypeContext::structuredBufferPredefinedType() {
  return getRuleContext<azslParser::StructuredBufferPredefinedTypeContext>(0);
}

azslParser::TexturePredefinedTypeContext* azslParser::PredefinedTypeContext::texturePredefinedType() {
  return getRuleContext<azslParser::TexturePredefinedTypeContext>(0);
}

azslParser::GenericTexturePredefinedTypeContext* azslParser::PredefinedTypeContext::genericTexturePredefinedType() {
  return getRuleContext<azslParser::GenericTexturePredefinedTypeContext>(0);
}

azslParser::GenericSubpassInputPredefinedTypeContext* azslParser::PredefinedTypeContext::genericSubpassInputPredefinedType() {
  return getRuleContext<azslParser::GenericSubpassInputPredefinedTypeContext>(0);
}

azslParser::MsTexturePredefinedTypeContext* azslParser::PredefinedTypeContext::msTexturePredefinedType() {
  return getRuleContext<azslParser::MsTexturePredefinedTypeContext>(0);
}

azslParser::SubpassInputPredefinedTypeContext* azslParser::PredefinedTypeContext::subpassInputPredefinedType() {
  return getRuleContext<azslParser::SubpassInputPredefinedTypeContext>(0);
}

azslParser::VectorTypeContext* azslParser::PredefinedTypeContext::vectorType() {
  return getRuleContext<azslParser::VectorTypeContext>(0);
}

azslParser::GenericVectorTypeContext* azslParser::PredefinedTypeContext::genericVectorType() {
  return getRuleContext<azslParser::GenericVectorTypeContext>(0);
}

azslParser::ConstantBufferTemplatedContext* azslParser::PredefinedTypeContext::constantBufferTemplated() {
  return getRuleContext<azslParser::ConstantBufferTemplatedContext>(0);
}

azslParser::OtherViewResourceTypeContext* azslParser::PredefinedTypeContext::otherViewResourceType() {
  return getRuleContext<azslParser::OtherViewResourceTypeContext>(0);
}

azslParser::SubobjectTypeContext* azslParser::PredefinedTypeContext::subobjectType() {
  return getRuleContext<azslParser::SubobjectTypeContext>(0);
}

azslParser::RtxBuiltInTypesContext* azslParser::PredefinedTypeContext::rtxBuiltInTypes() {
  return getRuleContext<azslParser::RtxBuiltInTypesContext>(0);
}


size_t azslParser::PredefinedTypeContext::getRuleIndex() const {
  return azslParser::RulePredefinedType;
}

void azslParser::PredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredefinedType(this);
}

void azslParser::PredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredefinedType(this);
}

azslParser::PredefinedTypeContext* azslParser::predefinedType() {
  PredefinedTypeContext *_localctx = _tracker.createInstance<PredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 126, azslParser::RulePredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(872);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(852);
      bufferPredefinedType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(853);
      byteAddressBufferTypes();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(854);
      patchPredefinedType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(855);
      matrixType();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(856);
      genericMatrixPredefinedType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(857);
      samplerStatePredefinedType();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(858);
      scalarType();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(859);
      streamOutputPredefinedType();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(860);
      structuredBufferPredefinedType();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(861);
      texturePredefinedType();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(862);
      genericTexturePredefinedType();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(863);
      genericSubpassInputPredefinedType();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(864);
      msTexturePredefinedType();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(865);
      subpassInputPredefinedType();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(866);
      vectorType();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(867);
      genericVectorType();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(868);
      constantBufferTemplated();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(869);
      otherViewResourceType();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(870);
      subobjectType();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(871);
      rtxBuiltInTypes();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubobjectTypeContext ------------------------------------------------------------------

azslParser::SubobjectTypeContext::SubobjectTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SubobjectTypeContext::StateObjectConfig() {
  return getToken(azslParser::StateObjectConfig, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::LocalRootSignature() {
  return getToken(azslParser::LocalRootSignature, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::GlobalRootSignature() {
  return getToken(azslParser::GlobalRootSignature, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::SubobjectToExportsAssociation() {
  return getToken(azslParser::SubobjectToExportsAssociation, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::RaytracingShaderConfig() {
  return getToken(azslParser::RaytracingShaderConfig, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::RaytracingPipelineConfig() {
  return getToken(azslParser::RaytracingPipelineConfig, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::RaytracingPipelineConfig1() {
  return getToken(azslParser::RaytracingPipelineConfig1, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::TriangleHitGroup() {
  return getToken(azslParser::TriangleHitGroup, 0);
}

tree::TerminalNode* azslParser::SubobjectTypeContext::ProceduralPrimitiveHitGroup() {
  return getToken(azslParser::ProceduralPrimitiveHitGroup, 0);
}


size_t azslParser::SubobjectTypeContext::getRuleIndex() const {
  return azslParser::RuleSubobjectType;
}

void azslParser::SubobjectTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubobjectType(this);
}

void azslParser::SubobjectTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubobjectType(this);
}

azslParser::SubobjectTypeContext* azslParser::subobjectType() {
  SubobjectTypeContext *_localctx = _tracker.createInstance<SubobjectTypeContext>(_ctx, getState());
  enterRule(_localctx, 128, azslParser::RuleSubobjectType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(874);
    _la = _input->LA(1);
    if (!(((((_la - 263) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 263)) & 511) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OtherViewResourceTypeContext ------------------------------------------------------------------

azslParser::OtherViewResourceTypeContext::OtherViewResourceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::OtherViewResourceTypeContext::RaytracingAccelerationStructure() {
  return getToken(azslParser::RaytracingAccelerationStructure, 0);
}


size_t azslParser::OtherViewResourceTypeContext::getRuleIndex() const {
  return azslParser::RuleOtherViewResourceType;
}

void azslParser::OtherViewResourceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOtherViewResourceType(this);
}

void azslParser::OtherViewResourceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOtherViewResourceType(this);
}

azslParser::OtherViewResourceTypeContext* azslParser::otherViewResourceType() {
  OtherViewResourceTypeContext *_localctx = _tracker.createInstance<OtherViewResourceTypeContext>(_ctx, getState());
  enterRule(_localctx, 130, azslParser::RuleOtherViewResourceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(876);
    match(azslParser::RaytracingAccelerationStructure);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RtxBuiltInTypesContext ------------------------------------------------------------------

azslParser::RtxBuiltInTypesContext::RtxBuiltInTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::RtxBuiltInTypesContext::BuiltInTriangleIntersectionAttributes() {
  return getToken(azslParser::BuiltInTriangleIntersectionAttributes, 0);
}

tree::TerminalNode* azslParser::RtxBuiltInTypesContext::RayDesc() {
  return getToken(azslParser::RayDesc, 0);
}


size_t azslParser::RtxBuiltInTypesContext::getRuleIndex() const {
  return azslParser::RuleRtxBuiltInTypes;
}

void azslParser::RtxBuiltInTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRtxBuiltInTypes(this);
}

void azslParser::RtxBuiltInTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRtxBuiltInTypes(this);
}

azslParser::RtxBuiltInTypesContext* azslParser::rtxBuiltInTypes() {
  RtxBuiltInTypesContext *_localctx = _tracker.createInstance<RtxBuiltInTypesContext>(_ctx, getState());
  enterRule(_localctx, 132, azslParser::RuleRtxBuiltInTypes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(878);
    _la = _input->LA(1);
    if (!(_la == azslParser::BuiltInTriangleIntersectionAttributes || _la == azslParser::RayDesc)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BufferPredefinedTypeContext ------------------------------------------------------------------

azslParser::BufferPredefinedTypeContext::BufferPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::BufferTypeContext* azslParser::BufferPredefinedTypeContext::bufferType() {
  return getRuleContext<azslParser::BufferTypeContext>(0);
}

tree::TerminalNode* azslParser::BufferPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarOrVectorOrMatrixTypeContext* azslParser::BufferPredefinedTypeContext::scalarOrVectorOrMatrixType() {
  return getRuleContext<azslParser::ScalarOrVectorOrMatrixTypeContext>(0);
}

tree::TerminalNode* azslParser::BufferPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}


size_t azslParser::BufferPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleBufferPredefinedType;
}

void azslParser::BufferPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBufferPredefinedType(this);
}

void azslParser::BufferPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBufferPredefinedType(this);
}

azslParser::BufferPredefinedTypeContext* azslParser::bufferPredefinedType() {
  BufferPredefinedTypeContext *_localctx = _tracker.createInstance<BufferPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 134, azslParser::RuleBufferPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(880);
    bufferType();
    setState(881);
    match(azslParser::Less);
    setState(882);
    scalarOrVectorOrMatrixType();
    setState(883);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BufferTypeContext ------------------------------------------------------------------

azslParser::BufferTypeContext::BufferTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BufferTypeContext::Buffer() {
  return getToken(azslParser::Buffer, 0);
}

tree::TerminalNode* azslParser::BufferTypeContext::RWBuffer() {
  return getToken(azslParser::RWBuffer, 0);
}

tree::TerminalNode* azslParser::BufferTypeContext::RasterizerOrderedBuffer() {
  return getToken(azslParser::RasterizerOrderedBuffer, 0);
}


size_t azslParser::BufferTypeContext::getRuleIndex() const {
  return azslParser::RuleBufferType;
}

void azslParser::BufferTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBufferType(this);
}

void azslParser::BufferTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBufferType(this);
}

azslParser::BufferTypeContext* azslParser::bufferType() {
  BufferTypeContext *_localctx = _tracker.createInstance<BufferTypeContext>(_ctx, getState());
  enterRule(_localctx, 136, azslParser::RuleBufferType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(885);
    _la = _input->LA(1);
    if (!(_la == azslParser::Buffer || _la == azslParser::RasterizerOrderedBuffer

    || _la == azslParser::RWBuffer)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ByteAddressBufferTypesContext ------------------------------------------------------------------

azslParser::ByteAddressBufferTypesContext::ByteAddressBufferTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ByteAddressBufferTypesContext::ByteAddressBuffer() {
  return getToken(azslParser::ByteAddressBuffer, 0);
}

tree::TerminalNode* azslParser::ByteAddressBufferTypesContext::RWByteAddressBuffer() {
  return getToken(azslParser::RWByteAddressBuffer, 0);
}

tree::TerminalNode* azslParser::ByteAddressBufferTypesContext::RasterizerOrderedByteAddressBuffer() {
  return getToken(azslParser::RasterizerOrderedByteAddressBuffer, 0);
}


size_t azslParser::ByteAddressBufferTypesContext::getRuleIndex() const {
  return azslParser::RuleByteAddressBufferTypes;
}

void azslParser::ByteAddressBufferTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterByteAddressBufferTypes(this);
}

void azslParser::ByteAddressBufferTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitByteAddressBufferTypes(this);
}

azslParser::ByteAddressBufferTypesContext* azslParser::byteAddressBufferTypes() {
  ByteAddressBufferTypesContext *_localctx = _tracker.createInstance<ByteAddressBufferTypesContext>(_ctx, getState());
  enterRule(_localctx, 138, azslParser::RuleByteAddressBufferTypes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(887);
    _la = _input->LA(1);
    if (!(_la == azslParser::ByteAddressBuffer || _la == azslParser::RasterizerOrderedByteAddressBuffer

    || _la == azslParser::RWByteAddressBuffer)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatchPredefinedTypeContext ------------------------------------------------------------------

azslParser::PatchPredefinedTypeContext::PatchPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::PatchTypeContext* azslParser::PatchPredefinedTypeContext::patchType() {
  return getRuleContext<azslParser::PatchTypeContext>(0);
}

tree::TerminalNode* azslParser::PatchPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

tree::TerminalNode* azslParser::PatchPredefinedTypeContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

tree::TerminalNode* azslParser::PatchPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

azslParser::UserDefinedTypeContext* azslParser::PatchPredefinedTypeContext::userDefinedType() {
  return getRuleContext<azslParser::UserDefinedTypeContext>(0);
}

tree::TerminalNode* azslParser::PatchPredefinedTypeContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}


size_t azslParser::PatchPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RulePatchPredefinedType;
}

void azslParser::PatchPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatchPredefinedType(this);
}

void azslParser::PatchPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatchPredefinedType(this);
}

azslParser::PatchPredefinedTypeContext* azslParser::patchPredefinedType() {
  PatchPredefinedTypeContext *_localctx = _tracker.createInstance<PatchPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 140, azslParser::RulePatchPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(889);
    patchType();
    setState(890);
    match(azslParser::Less);
    setState(891);
    antlrcpp::downCast<PatchPredefinedTypeContext *>(_localctx)->Name = userDefinedType();
    setState(892);
    match(azslParser::Comma);
    setState(893);
    antlrcpp::downCast<PatchPredefinedTypeContext *>(_localctx)->ControlPoints = match(azslParser::IntegerLiteral);
    setState(894);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatchTypeContext ------------------------------------------------------------------

azslParser::PatchTypeContext::PatchTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::PatchTypeContext::InputPatch() {
  return getToken(azslParser::InputPatch, 0);
}

tree::TerminalNode* azslParser::PatchTypeContext::OutputPatch() {
  return getToken(azslParser::OutputPatch, 0);
}


size_t azslParser::PatchTypeContext::getRuleIndex() const {
  return azslParser::RulePatchType;
}

void azslParser::PatchTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatchType(this);
}

void azslParser::PatchTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatchType(this);
}

azslParser::PatchTypeContext* azslParser::patchType() {
  PatchTypeContext *_localctx = _tracker.createInstance<PatchTypeContext>(_ctx, getState());
  enterRule(_localctx, 142, azslParser::RulePatchType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(896);
    _la = _input->LA(1);
    if (!(_la == azslParser::InputPatch

    || _la == azslParser::OutputPatch)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SamplerStatePredefinedTypeContext ------------------------------------------------------------------

azslParser::SamplerStatePredefinedTypeContext::SamplerStatePredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::Sampler() {
  return getToken(azslParser::Sampler, 0);
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::SamplerCapitalS() {
  return getToken(azslParser::SamplerCapitalS, 0);
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::SamplerState() {
  return getToken(azslParser::SamplerState, 0);
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::SamplerStateCamel() {
  return getToken(azslParser::SamplerStateCamel, 0);
}

tree::TerminalNode* azslParser::SamplerStatePredefinedTypeContext::SamplerComparisonState() {
  return getToken(azslParser::SamplerComparisonState, 0);
}


size_t azslParser::SamplerStatePredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleSamplerStatePredefinedType;
}

void azslParser::SamplerStatePredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSamplerStatePredefinedType(this);
}

void azslParser::SamplerStatePredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSamplerStatePredefinedType(this);
}

azslParser::SamplerStatePredefinedTypeContext* azslParser::samplerStatePredefinedType() {
  SamplerStatePredefinedTypeContext *_localctx = _tracker.createInstance<SamplerStatePredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 144, azslParser::RuleSamplerStatePredefinedType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(898);
    _la = _input->LA(1);
    if (!(((((_la - 183) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 183)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScalarTypeContext ------------------------------------------------------------------

azslParser::ScalarTypeContext::ScalarTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ScalarTypeContext::Bool() {
  return getToken(azslParser::Bool, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Int() {
  return getToken(azslParser::Int, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Int16_t() {
  return getToken(azslParser::Int16_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Int32_t() {
  return getToken(azslParser::Int32_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Int64_t() {
  return getToken(azslParser::Int64_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Uint() {
  return getToken(azslParser::Uint, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Uint16_t() {
  return getToken(azslParser::Uint16_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Uint32_t() {
  return getToken(azslParser::Uint32_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Uint64_t() {
  return getToken(azslParser::Uint64_t, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Dword() {
  return getToken(azslParser::Dword, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Half() {
  return getToken(azslParser::Half, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Float() {
  return getToken(azslParser::Float, 0);
}

tree::TerminalNode* azslParser::ScalarTypeContext::Double() {
  return getToken(azslParser::Double, 0);
}


size_t azslParser::ScalarTypeContext::getRuleIndex() const {
  return azslParser::RuleScalarType;
}

void azslParser::ScalarTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalarType(this);
}

void azslParser::ScalarTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalarType(this);
}

azslParser::ScalarTypeContext* azslParser::scalarType() {
  ScalarTypeContext *_localctx = _tracker.createInstance<ScalarTypeContext>(_ctx, getState());
  enterRule(_localctx, 146, azslParser::RuleScalarType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(900);
    _la = _input->LA(1);
    if (!(_la == azslParser::Bool

    || _la == azslParser::Double || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & 67553994444111873) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & 81788929) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamOutputPredefinedTypeContext ------------------------------------------------------------------

azslParser::StreamOutputPredefinedTypeContext::StreamOutputPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StreamOutputObjectTypeContext* azslParser::StreamOutputPredefinedTypeContext::streamOutputObjectType() {
  return getRuleContext<azslParser::StreamOutputObjectTypeContext>(0);
}

tree::TerminalNode* azslParser::StreamOutputPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::TypeContext* azslParser::StreamOutputPredefinedTypeContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::StreamOutputPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}


size_t azslParser::StreamOutputPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleStreamOutputPredefinedType;
}

void azslParser::StreamOutputPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamOutputPredefinedType(this);
}

void azslParser::StreamOutputPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamOutputPredefinedType(this);
}

azslParser::StreamOutputPredefinedTypeContext* azslParser::streamOutputPredefinedType() {
  StreamOutputPredefinedTypeContext *_localctx = _tracker.createInstance<StreamOutputPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 148, azslParser::RuleStreamOutputPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(902);
    streamOutputObjectType();
    setState(903);
    match(azslParser::Less);
    setState(904);
    type();
    setState(905);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamOutputObjectTypeContext ------------------------------------------------------------------

azslParser::StreamOutputObjectTypeContext::StreamOutputObjectTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StreamOutputObjectTypeContext::PointStream() {
  return getToken(azslParser::PointStream, 0);
}

tree::TerminalNode* azslParser::StreamOutputObjectTypeContext::LineStream() {
  return getToken(azslParser::LineStream, 0);
}

tree::TerminalNode* azslParser::StreamOutputObjectTypeContext::TriangleStream() {
  return getToken(azslParser::TriangleStream, 0);
}


size_t azslParser::StreamOutputObjectTypeContext::getRuleIndex() const {
  return azslParser::RuleStreamOutputObjectType;
}

void azslParser::StreamOutputObjectTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamOutputObjectType(this);
}

void azslParser::StreamOutputObjectTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamOutputObjectType(this);
}

azslParser::StreamOutputObjectTypeContext* azslParser::streamOutputObjectType() {
  StreamOutputObjectTypeContext *_localctx = _tracker.createInstance<StreamOutputObjectTypeContext>(_ctx, getState());
  enterRule(_localctx, 150, azslParser::RuleStreamOutputObjectType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(907);
    _la = _input->LA(1);
    if (!(((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & -9223372036854771711) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructuredBufferPredefinedTypeContext ------------------------------------------------------------------

azslParser::StructuredBufferPredefinedTypeContext::StructuredBufferPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StructuredBufferNameContext* azslParser::StructuredBufferPredefinedTypeContext::structuredBufferName() {
  return getRuleContext<azslParser::StructuredBufferNameContext>(0);
}

tree::TerminalNode* azslParser::StructuredBufferPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::TypeContext* azslParser::StructuredBufferPredefinedTypeContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::StructuredBufferPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}


size_t azslParser::StructuredBufferPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleStructuredBufferPredefinedType;
}

void azslParser::StructuredBufferPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructuredBufferPredefinedType(this);
}

void azslParser::StructuredBufferPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructuredBufferPredefinedType(this);
}

azslParser::StructuredBufferPredefinedTypeContext* azslParser::structuredBufferPredefinedType() {
  StructuredBufferPredefinedTypeContext *_localctx = _tracker.createInstance<StructuredBufferPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 152, azslParser::RuleStructuredBufferPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(909);
    structuredBufferName();
    setState(910);
    match(azslParser::Less);
    setState(911);
    type();
    setState(912);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructuredBufferNameContext ------------------------------------------------------------------

azslParser::StructuredBufferNameContext::StructuredBufferNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::AppendStructuredBuffer() {
  return getToken(azslParser::AppendStructuredBuffer, 0);
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::ConsumeStructuredBuffer() {
  return getToken(azslParser::ConsumeStructuredBuffer, 0);
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::RWStructuredBuffer() {
  return getToken(azslParser::RWStructuredBuffer, 0);
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::StructuredBuffer() {
  return getToken(azslParser::StructuredBuffer, 0);
}

tree::TerminalNode* azslParser::StructuredBufferNameContext::RasterizerOrderedStructuredBuffer() {
  return getToken(azslParser::RasterizerOrderedStructuredBuffer, 0);
}


size_t azslParser::StructuredBufferNameContext::getRuleIndex() const {
  return azslParser::RuleStructuredBufferName;
}

void azslParser::StructuredBufferNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructuredBufferName(this);
}

void azslParser::StructuredBufferNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructuredBufferName(this);
}

azslParser::StructuredBufferNameContext* azslParser::structuredBufferName() {
  StructuredBufferNameContext *_localctx = _tracker.createInstance<StructuredBufferNameContext>(_ctx, getState());
  enterRule(_localctx, 154, azslParser::RuleStructuredBufferName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(914);
    _la = _input->LA(1);
    if (!(_la == azslParser::AppendStructuredBuffer

    || _la == azslParser::ConsumeStructuredBuffer || ((((_la - 163) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 163)) & 536879105) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextureTypeContext ------------------------------------------------------------------

azslParser::TextureTypeContext::TextureTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture1D() {
  return getToken(azslParser::Texture1D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture1DArray() {
  return getToken(azslParser::Texture1DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture1D() {
  return getToken(azslParser::RasterizerOrderedTexture1D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture1DArray() {
  return getToken(azslParser::RasterizerOrderedTexture1DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture2D() {
  return getToken(azslParser::Texture2D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture2DArray() {
  return getToken(azslParser::Texture2DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture2D() {
  return getToken(azslParser::RasterizerOrderedTexture2D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture2DArray() {
  return getToken(azslParser::RasterizerOrderedTexture2DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::Texture3D() {
  return getToken(azslParser::Texture3D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RasterizerOrderedTexture3D() {
  return getToken(azslParser::RasterizerOrderedTexture3D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::TextureCube() {
  return getToken(azslParser::TextureCube, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::TextureCubeArray() {
  return getToken(azslParser::TextureCubeArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture1D() {
  return getToken(azslParser::RWTexture1D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture1DArray() {
  return getToken(azslParser::RWTexture1DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture2D() {
  return getToken(azslParser::RWTexture2D, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture2DArray() {
  return getToken(azslParser::RWTexture2DArray, 0);
}

tree::TerminalNode* azslParser::TextureTypeContext::RWTexture3D() {
  return getToken(azslParser::RWTexture3D, 0);
}


size_t azslParser::TextureTypeContext::getRuleIndex() const {
  return azslParser::RuleTextureType;
}

void azslParser::TextureTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextureType(this);
}

void azslParser::TextureTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextureType(this);
}

azslParser::TextureTypeContext* azslParser::textureType() {
  TextureTypeContext *_localctx = _tracker.createInstance<TextureTypeContext>(_ctx, getState());
  enterRule(_localctx, 156, azslParser::RuleTextureType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(916);
    _la = _input->LA(1);
    if (!(((((_la - 164) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 164)) & 15908559118367) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TexturePredefinedTypeContext ------------------------------------------------------------------

azslParser::TexturePredefinedTypeContext::TexturePredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TextureTypeContext* azslParser::TexturePredefinedTypeContext::textureType() {
  return getRuleContext<azslParser::TextureTypeContext>(0);
}


size_t azslParser::TexturePredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleTexturePredefinedType;
}

void azslParser::TexturePredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTexturePredefinedType(this);
}

void azslParser::TexturePredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTexturePredefinedType(this);
}

azslParser::TexturePredefinedTypeContext* azslParser::texturePredefinedType() {
  TexturePredefinedTypeContext *_localctx = _tracker.createInstance<TexturePredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 158, azslParser::RuleTexturePredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(918);
    textureType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericTexturePredefinedTypeContext ------------------------------------------------------------------

azslParser::GenericTexturePredefinedTypeContext::GenericTexturePredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TextureTypeContext* azslParser::GenericTexturePredefinedTypeContext::textureType() {
  return getRuleContext<azslParser::TextureTypeContext>(0);
}

tree::TerminalNode* azslParser::GenericTexturePredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarOrVectorTypeContext* azslParser::GenericTexturePredefinedTypeContext::scalarOrVectorType() {
  return getRuleContext<azslParser::ScalarOrVectorTypeContext>(0);
}

tree::TerminalNode* azslParser::GenericTexturePredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}


size_t azslParser::GenericTexturePredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleGenericTexturePredefinedType;
}

void azslParser::GenericTexturePredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericTexturePredefinedType(this);
}

void azslParser::GenericTexturePredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericTexturePredefinedType(this);
}

azslParser::GenericTexturePredefinedTypeContext* azslParser::genericTexturePredefinedType() {
  GenericTexturePredefinedTypeContext *_localctx = _tracker.createInstance<GenericTexturePredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 160, azslParser::RuleGenericTexturePredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(920);
    textureType();
    setState(921);
    match(azslParser::Less);
    setState(922);
    scalarOrVectorType();
    setState(923);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextureTypeMSContext ------------------------------------------------------------------

azslParser::TextureTypeMSContext::TextureTypeMSContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TextureTypeMSContext::Texture2DMS() {
  return getToken(azslParser::Texture2DMS, 0);
}

tree::TerminalNode* azslParser::TextureTypeMSContext::Texture2DMSArray() {
  return getToken(azslParser::Texture2DMSArray, 0);
}


size_t azslParser::TextureTypeMSContext::getRuleIndex() const {
  return azslParser::RuleTextureTypeMS;
}

void azslParser::TextureTypeMSContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextureTypeMS(this);
}

void azslParser::TextureTypeMSContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextureTypeMS(this);
}

azslParser::TextureTypeMSContext* azslParser::textureTypeMS() {
  TextureTypeMSContext *_localctx = _tracker.createInstance<TextureTypeMSContext>(_ctx, getState());
  enterRule(_localctx, 162, azslParser::RuleTextureTypeMS);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(925);
    _la = _input->LA(1);
    if (!(_la == azslParser::Texture2DMS

    || _la == azslParser::Texture2DMSArray)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MsTexturePredefinedTypeContext ------------------------------------------------------------------

azslParser::MsTexturePredefinedTypeContext::MsTexturePredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TextureTypeMSContext* azslParser::MsTexturePredefinedTypeContext::textureTypeMS() {
  return getRuleContext<azslParser::TextureTypeMSContext>(0);
}

tree::TerminalNode* azslParser::MsTexturePredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarOrVectorTypeContext* azslParser::MsTexturePredefinedTypeContext::scalarOrVectorType() {
  return getRuleContext<azslParser::ScalarOrVectorTypeContext>(0);
}

tree::TerminalNode* azslParser::MsTexturePredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

tree::TerminalNode* azslParser::MsTexturePredefinedTypeContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

tree::TerminalNode* azslParser::MsTexturePredefinedTypeContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}


size_t azslParser::MsTexturePredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleMsTexturePredefinedType;
}

void azslParser::MsTexturePredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMsTexturePredefinedType(this);
}

void azslParser::MsTexturePredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMsTexturePredefinedType(this);
}

azslParser::MsTexturePredefinedTypeContext* azslParser::msTexturePredefinedType() {
  MsTexturePredefinedTypeContext *_localctx = _tracker.createInstance<MsTexturePredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 164, azslParser::RuleMsTexturePredefinedType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(927);
    textureTypeMS();
    setState(928);
    match(azslParser::Less);
    setState(929);
    scalarOrVectorType();
    setState(932);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Comma) {
      setState(930);
      match(azslParser::Comma);
      setState(931);
      antlrcpp::downCast<MsTexturePredefinedTypeContext *>(_localctx)->Samples = match(azslParser::IntegerLiteral);
    }
    setState(934);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubpassInputTypeContext ------------------------------------------------------------------

azslParser::SubpassInputTypeContext::SubpassInputTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SubpassInputTypeContext::SubpassInput() {
  return getToken(azslParser::SubpassInput, 0);
}

tree::TerminalNode* azslParser::SubpassInputTypeContext::SubpassInputDS() {
  return getToken(azslParser::SubpassInputDS, 0);
}

tree::TerminalNode* azslParser::SubpassInputTypeContext::SubpassInputMS() {
  return getToken(azslParser::SubpassInputMS, 0);
}

tree::TerminalNode* azslParser::SubpassInputTypeContext::SubpassInputDSMS() {
  return getToken(azslParser::SubpassInputDSMS, 0);
}


size_t azslParser::SubpassInputTypeContext::getRuleIndex() const {
  return azslParser::RuleSubpassInputType;
}

void azslParser::SubpassInputTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubpassInputType(this);
}

void azslParser::SubpassInputTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubpassInputType(this);
}

azslParser::SubpassInputTypeContext* azslParser::subpassInputType() {
  SubpassInputTypeContext *_localctx = _tracker.createInstance<SubpassInputTypeContext>(_ctx, getState());
  enterRule(_localctx, 166, azslParser::RuleSubpassInputType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(936);
    _la = _input->LA(1);
    if (!(((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubpassInputPredefinedTypeContext ------------------------------------------------------------------

azslParser::SubpassInputPredefinedTypeContext::SubpassInputPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::SubpassInputTypeContext* azslParser::SubpassInputPredefinedTypeContext::subpassInputType() {
  return getRuleContext<azslParser::SubpassInputTypeContext>(0);
}


size_t azslParser::SubpassInputPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleSubpassInputPredefinedType;
}

void azslParser::SubpassInputPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubpassInputPredefinedType(this);
}

void azslParser::SubpassInputPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubpassInputPredefinedType(this);
}

azslParser::SubpassInputPredefinedTypeContext* azslParser::subpassInputPredefinedType() {
  SubpassInputPredefinedTypeContext *_localctx = _tracker.createInstance<SubpassInputPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 168, azslParser::RuleSubpassInputPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(938);
    subpassInputType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericSubpassInputPredefinedTypeContext ------------------------------------------------------------------

azslParser::GenericSubpassInputPredefinedTypeContext::GenericSubpassInputPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::SubpassInputTypeContext* azslParser::GenericSubpassInputPredefinedTypeContext::subpassInputType() {
  return getRuleContext<azslParser::SubpassInputTypeContext>(0);
}

tree::TerminalNode* azslParser::GenericSubpassInputPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarOrVectorTypeContext* azslParser::GenericSubpassInputPredefinedTypeContext::scalarOrVectorType() {
  return getRuleContext<azslParser::ScalarOrVectorTypeContext>(0);
}

tree::TerminalNode* azslParser::GenericSubpassInputPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}


size_t azslParser::GenericSubpassInputPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleGenericSubpassInputPredefinedType;
}

void azslParser::GenericSubpassInputPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericSubpassInputPredefinedType(this);
}

void azslParser::GenericSubpassInputPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericSubpassInputPredefinedType(this);
}

azslParser::GenericSubpassInputPredefinedTypeContext* azslParser::genericSubpassInputPredefinedType() {
  GenericSubpassInputPredefinedTypeContext *_localctx = _tracker.createInstance<GenericSubpassInputPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 170, azslParser::RuleGenericSubpassInputPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(940);
    subpassInputType();
    setState(941);
    match(azslParser::Less);
    setState(942);
    scalarOrVectorType();
    setState(943);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VectorTypeContext ------------------------------------------------------------------

azslParser::VectorTypeContext::VectorTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::VectorTypeContext::Vector() {
  return getToken(azslParser::Vector, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Bool1() {
  return getToken(azslParser::Bool1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Bool2() {
  return getToken(azslParser::Bool2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Bool3() {
  return getToken(azslParser::Bool3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Bool4() {
  return getToken(azslParser::Bool4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Int1() {
  return getToken(azslParser::Int1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Int2() {
  return getToken(azslParser::Int2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Int3() {
  return getToken(azslParser::Int3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Int4() {
  return getToken(azslParser::Int4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Uint1() {
  return getToken(azslParser::Uint1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Uint2() {
  return getToken(azslParser::Uint2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Uint3() {
  return getToken(azslParser::Uint3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Uint4() {
  return getToken(azslParser::Uint4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Dword1() {
  return getToken(azslParser::Dword1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Dword2() {
  return getToken(azslParser::Dword2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Dword3() {
  return getToken(azslParser::Dword3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Dword4() {
  return getToken(azslParser::Dword4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Half1() {
  return getToken(azslParser::Half1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Half2() {
  return getToken(azslParser::Half2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Half3() {
  return getToken(azslParser::Half3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Half4() {
  return getToken(azslParser::Half4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Float1() {
  return getToken(azslParser::Float1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Float2() {
  return getToken(azslParser::Float2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Float3() {
  return getToken(azslParser::Float3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Float4() {
  return getToken(azslParser::Float4, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Double1() {
  return getToken(azslParser::Double1, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Double2() {
  return getToken(azslParser::Double2, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Double3() {
  return getToken(azslParser::Double3, 0);
}

tree::TerminalNode* azslParser::VectorTypeContext::Double4() {
  return getToken(azslParser::Double4, 0);
}


size_t azslParser::VectorTypeContext::getRuleIndex() const {
  return azslParser::RuleVectorType;
}

void azslParser::VectorTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVectorType(this);
}

void azslParser::VectorTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVectorType(this);
}

azslParser::VectorTypeContext* azslParser::vectorType() {
  VectorTypeContext *_localctx = _tracker.createInstance<VectorTypeContext>(_ctx, getState());
  enterRule(_localctx, 172, azslParser::RuleVectorType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(945);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 32985348833400) != 0) || ((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & 540431955787776015) != 0) || ((((_la - 213) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 213)) & 70369750810639) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericVectorTypeContext ------------------------------------------------------------------

azslParser::GenericVectorTypeContext::GenericVectorTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::Vector() {
  return getToken(azslParser::Vector, 0);
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarTypeContext* azslParser::GenericVectorTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

tree::TerminalNode* azslParser::GenericVectorTypeContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}


size_t azslParser::GenericVectorTypeContext::getRuleIndex() const {
  return azslParser::RuleGenericVectorType;
}

void azslParser::GenericVectorTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericVectorType(this);
}

void azslParser::GenericVectorTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericVectorType(this);
}

azslParser::GenericVectorTypeContext* azslParser::genericVectorType() {
  GenericVectorTypeContext *_localctx = _tracker.createInstance<GenericVectorTypeContext>(_ctx, getState());
  enterRule(_localctx, 174, azslParser::RuleGenericVectorType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(947);
    match(azslParser::Vector);
    setState(948);
    match(azslParser::Less);
    setState(949);
    scalarType();
    setState(950);
    match(azslParser::Comma);
    setState(951);
    antlrcpp::downCast<GenericVectorTypeContext *>(_localctx)->Size_ = match(azslParser::IntegerLiteral);
    setState(952);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScalarOrVectorTypeContext ------------------------------------------------------------------

azslParser::ScalarOrVectorTypeContext::ScalarOrVectorTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::ScalarTypeContext* azslParser::ScalarOrVectorTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

azslParser::VectorTypeContext* azslParser::ScalarOrVectorTypeContext::vectorType() {
  return getRuleContext<azslParser::VectorTypeContext>(0);
}


size_t azslParser::ScalarOrVectorTypeContext::getRuleIndex() const {
  return azslParser::RuleScalarOrVectorType;
}

void azslParser::ScalarOrVectorTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalarOrVectorType(this);
}

void azslParser::ScalarOrVectorTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalarOrVectorType(this);
}

azslParser::ScalarOrVectorTypeContext* azslParser::scalarOrVectorType() {
  ScalarOrVectorTypeContext *_localctx = _tracker.createInstance<ScalarOrVectorTypeContext>(_ctx, getState());
  enterRule(_localctx, 176, azslParser::RuleScalarOrVectorType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(956);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Bool:
      case azslParser::Double:
      case azslParser::Float:
      case azslParser::Half:
      case azslParser::Int:
      case azslParser::Int16_t:
      case azslParser::Int32_t:
      case azslParser::Int64_t:
      case azslParser::Uint:
      case azslParser::Uint16_t:
      case azslParser::Uint32_t:
      case azslParser::Uint64_t:
      case azslParser::Dword: {
        enterOuterAlt(_localctx, 1);
        setState(954);
        scalarType();
        break;
      }

      case azslParser::Bool1:
      case azslParser::Bool2:
      case azslParser::Bool3:
      case azslParser::Bool4:
      case azslParser::Double1:
      case azslParser::Double2:
      case azslParser::Double3:
      case azslParser::Double4:
      case azslParser::Float1:
      case azslParser::Float2:
      case azslParser::Float3:
      case azslParser::Float4:
      case azslParser::Half1:
      case azslParser::Half2:
      case azslParser::Half3:
      case azslParser::Half4:
      case azslParser::Int1:
      case azslParser::Int2:
      case azslParser::Int3:
      case azslParser::Int4:
      case azslParser::Uint1:
      case azslParser::Uint2:
      case azslParser::Uint3:
      case azslParser::Uint4:
      case azslParser::Dword1:
      case azslParser::Dword2:
      case azslParser::Dword3:
      case azslParser::Dword4:
      case azslParser::Vector: {
        enterOuterAlt(_localctx, 2);
        setState(955);
        vectorType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScalarOrVectorOrMatrixTypeContext ------------------------------------------------------------------

azslParser::ScalarOrVectorOrMatrixTypeContext::ScalarOrVectorOrMatrixTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::ScalarTypeContext* azslParser::ScalarOrVectorOrMatrixTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

azslParser::VectorTypeContext* azslParser::ScalarOrVectorOrMatrixTypeContext::vectorType() {
  return getRuleContext<azslParser::VectorTypeContext>(0);
}

azslParser::MatrixTypeContext* azslParser::ScalarOrVectorOrMatrixTypeContext::matrixType() {
  return getRuleContext<azslParser::MatrixTypeContext>(0);
}


size_t azslParser::ScalarOrVectorOrMatrixTypeContext::getRuleIndex() const {
  return azslParser::RuleScalarOrVectorOrMatrixType;
}

void azslParser::ScalarOrVectorOrMatrixTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalarOrVectorOrMatrixType(this);
}

void azslParser::ScalarOrVectorOrMatrixTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalarOrVectorOrMatrixType(this);
}

azslParser::ScalarOrVectorOrMatrixTypeContext* azslParser::scalarOrVectorOrMatrixType() {
  ScalarOrVectorOrMatrixTypeContext *_localctx = _tracker.createInstance<ScalarOrVectorOrMatrixTypeContext>(_ctx, getState());
  enterRule(_localctx, 178, azslParser::RuleScalarOrVectorOrMatrixType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(961);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::Bool:
      case azslParser::Double:
      case azslParser::Float:
      case azslParser::Half:
      case azslParser::Int:
      case azslParser::Int16_t:
      case azslParser::Int32_t:
      case azslParser::Int64_t:
      case azslParser::Uint:
      case azslParser::Uint16_t:
      case azslParser::Uint32_t:
      case azslParser::Uint64_t:
      case azslParser::Dword: {
        enterOuterAlt(_localctx, 1);
        setState(958);
        scalarType();
        break;
      }

      case azslParser::Bool1:
      case azslParser::Bool2:
      case azslParser::Bool3:
      case azslParser::Bool4:
      case azslParser::Double1:
      case azslParser::Double2:
      case azslParser::Double3:
      case azslParser::Double4:
      case azslParser::Float1:
      case azslParser::Float2:
      case azslParser::Float3:
      case azslParser::Float4:
      case azslParser::Half1:
      case azslParser::Half2:
      case azslParser::Half3:
      case azslParser::Half4:
      case azslParser::Int1:
      case azslParser::Int2:
      case azslParser::Int3:
      case azslParser::Int4:
      case azslParser::Uint1:
      case azslParser::Uint2:
      case azslParser::Uint3:
      case azslParser::Uint4:
      case azslParser::Dword1:
      case azslParser::Dword2:
      case azslParser::Dword3:
      case azslParser::Dword4:
      case azslParser::Vector: {
        enterOuterAlt(_localctx, 2);
        setState(959);
        vectorType();
        break;
      }

      case azslParser::Bool1x1:
      case azslParser::Bool1x2:
      case azslParser::Bool1x3:
      case azslParser::Bool1x4:
      case azslParser::Bool2x1:
      case azslParser::Bool2x2:
      case azslParser::Bool2x3:
      case azslParser::Bool2x4:
      case azslParser::Bool3x1:
      case azslParser::Bool3x2:
      case azslParser::Bool3x3:
      case azslParser::Bool3x4:
      case azslParser::Bool4x1:
      case azslParser::Bool4x2:
      case azslParser::Bool4x3:
      case azslParser::Bool4x4:
      case azslParser::Double1x1:
      case azslParser::Double1x2:
      case azslParser::Double1x3:
      case azslParser::Double1x4:
      case azslParser::Double2x1:
      case azslParser::Double2x2:
      case azslParser::Double2x3:
      case azslParser::Double2x4:
      case azslParser::Double3x1:
      case azslParser::Double3x2:
      case azslParser::Double3x3:
      case azslParser::Double3x4:
      case azslParser::Double4x1:
      case azslParser::Double4x2:
      case azslParser::Double4x3:
      case azslParser::Double4x4:
      case azslParser::Float1x1:
      case azslParser::Float1x2:
      case azslParser::Float1x3:
      case azslParser::Float1x4:
      case azslParser::Float2x1:
      case azslParser::Float2x2:
      case azslParser::Float2x3:
      case azslParser::Float2x4:
      case azslParser::Float3x1:
      case azslParser::Float3x2:
      case azslParser::Float3x3:
      case azslParser::Float3x4:
      case azslParser::Float4x1:
      case azslParser::Float4x2:
      case azslParser::Float4x3:
      case azslParser::Float4x4:
      case azslParser::Half1x1:
      case azslParser::Half1x2:
      case azslParser::Half1x3:
      case azslParser::Half1x4:
      case azslParser::Half2x1:
      case azslParser::Half2x2:
      case azslParser::Half2x3:
      case azslParser::Half2x4:
      case azslParser::Half3x1:
      case azslParser::Half3x2:
      case azslParser::Half3x3:
      case azslParser::Half3x4:
      case azslParser::Half4x1:
      case azslParser::Half4x2:
      case azslParser::Half4x3:
      case azslParser::Half4x4:
      case azslParser::Int1x1:
      case azslParser::Int1x2:
      case azslParser::Int1x3:
      case azslParser::Int1x4:
      case azslParser::Int2x1:
      case azslParser::Int2x2:
      case azslParser::Int2x3:
      case azslParser::Int2x4:
      case azslParser::Int3x1:
      case azslParser::Int3x2:
      case azslParser::Int3x3:
      case azslParser::Int3x4:
      case azslParser::Int4x1:
      case azslParser::Int4x2:
      case azslParser::Int4x3:
      case azslParser::Int4x4:
      case azslParser::Matrix:
      case azslParser::Uint1x1:
      case azslParser::Uint1x2:
      case azslParser::Uint1x3:
      case azslParser::Uint1x4:
      case azslParser::Uint2x1:
      case azslParser::Uint2x2:
      case azslParser::Uint2x3:
      case azslParser::Uint2x4:
      case azslParser::Uint3x1:
      case azslParser::Uint3x2:
      case azslParser::Uint3x3:
      case azslParser::Uint3x4:
      case azslParser::Uint4x1:
      case azslParser::Uint4x2:
      case azslParser::Uint4x3:
      case azslParser::Uint4x4:
      case azslParser::Dword1x1:
      case azslParser::Dword1x2:
      case azslParser::Dword1x3:
      case azslParser::Dword1x4:
      case azslParser::Dword2x1:
      case azslParser::Dword2x2:
      case azslParser::Dword2x3:
      case azslParser::Dword2x4:
      case azslParser::Dword3x1:
      case azslParser::Dword3x2:
      case azslParser::Dword3x3:
      case azslParser::Dword3x4:
      case azslParser::Dword4x1:
      case azslParser::Dword4x2:
      case azslParser::Dword4x3:
      case azslParser::Dword4x4: {
        enterOuterAlt(_localctx, 3);
        setState(960);
        matrixType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatrixTypeContext ------------------------------------------------------------------

azslParser::MatrixTypeContext::MatrixTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MatrixTypeContext::Matrix() {
  return getToken(azslParser::Matrix, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool1x1() {
  return getToken(azslParser::Bool1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool1x2() {
  return getToken(azslParser::Bool1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool1x3() {
  return getToken(azslParser::Bool1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool1x4() {
  return getToken(azslParser::Bool1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool2x1() {
  return getToken(azslParser::Bool2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool2x2() {
  return getToken(azslParser::Bool2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool2x3() {
  return getToken(azslParser::Bool2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool2x4() {
  return getToken(azslParser::Bool2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool3x1() {
  return getToken(azslParser::Bool3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool3x2() {
  return getToken(azslParser::Bool3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool3x3() {
  return getToken(azslParser::Bool3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool3x4() {
  return getToken(azslParser::Bool3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool4x1() {
  return getToken(azslParser::Bool4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool4x2() {
  return getToken(azslParser::Bool4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool4x3() {
  return getToken(azslParser::Bool4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Bool4x4() {
  return getToken(azslParser::Bool4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int1x1() {
  return getToken(azslParser::Int1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int1x2() {
  return getToken(azslParser::Int1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int1x3() {
  return getToken(azslParser::Int1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int1x4() {
  return getToken(azslParser::Int1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int2x1() {
  return getToken(azslParser::Int2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int2x2() {
  return getToken(azslParser::Int2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int2x3() {
  return getToken(azslParser::Int2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int2x4() {
  return getToken(azslParser::Int2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int3x1() {
  return getToken(azslParser::Int3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int3x2() {
  return getToken(azslParser::Int3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int3x3() {
  return getToken(azslParser::Int3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int3x4() {
  return getToken(azslParser::Int3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int4x1() {
  return getToken(azslParser::Int4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int4x2() {
  return getToken(azslParser::Int4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int4x3() {
  return getToken(azslParser::Int4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Int4x4() {
  return getToken(azslParser::Int4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint1x1() {
  return getToken(azslParser::Uint1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint1x2() {
  return getToken(azslParser::Uint1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint1x3() {
  return getToken(azslParser::Uint1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint1x4() {
  return getToken(azslParser::Uint1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint2x1() {
  return getToken(azslParser::Uint2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint2x2() {
  return getToken(azslParser::Uint2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint2x3() {
  return getToken(azslParser::Uint2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint2x4() {
  return getToken(azslParser::Uint2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint3x1() {
  return getToken(azslParser::Uint3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint3x2() {
  return getToken(azslParser::Uint3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint3x3() {
  return getToken(azslParser::Uint3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint3x4() {
  return getToken(azslParser::Uint3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint4x1() {
  return getToken(azslParser::Uint4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint4x2() {
  return getToken(azslParser::Uint4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint4x3() {
  return getToken(azslParser::Uint4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Uint4x4() {
  return getToken(azslParser::Uint4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword1x1() {
  return getToken(azslParser::Dword1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword1x2() {
  return getToken(azslParser::Dword1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword1x3() {
  return getToken(azslParser::Dword1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword1x4() {
  return getToken(azslParser::Dword1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword2x1() {
  return getToken(azslParser::Dword2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword2x2() {
  return getToken(azslParser::Dword2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword2x3() {
  return getToken(azslParser::Dword2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword2x4() {
  return getToken(azslParser::Dword2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword3x1() {
  return getToken(azslParser::Dword3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword3x2() {
  return getToken(azslParser::Dword3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword3x3() {
  return getToken(azslParser::Dword3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword3x4() {
  return getToken(azslParser::Dword3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword4x1() {
  return getToken(azslParser::Dword4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword4x2() {
  return getToken(azslParser::Dword4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword4x3() {
  return getToken(azslParser::Dword4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Dword4x4() {
  return getToken(azslParser::Dword4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half1x1() {
  return getToken(azslParser::Half1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half1x2() {
  return getToken(azslParser::Half1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half1x3() {
  return getToken(azslParser::Half1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half1x4() {
  return getToken(azslParser::Half1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half2x1() {
  return getToken(azslParser::Half2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half2x2() {
  return getToken(azslParser::Half2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half2x3() {
  return getToken(azslParser::Half2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half2x4() {
  return getToken(azslParser::Half2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half3x1() {
  return getToken(azslParser::Half3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half3x2() {
  return getToken(azslParser::Half3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half3x3() {
  return getToken(azslParser::Half3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half3x4() {
  return getToken(azslParser::Half3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half4x1() {
  return getToken(azslParser::Half4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half4x2() {
  return getToken(azslParser::Half4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half4x3() {
  return getToken(azslParser::Half4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Half4x4() {
  return getToken(azslParser::Half4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float1x1() {
  return getToken(azslParser::Float1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float1x2() {
  return getToken(azslParser::Float1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float1x3() {
  return getToken(azslParser::Float1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float1x4() {
  return getToken(azslParser::Float1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float2x1() {
  return getToken(azslParser::Float2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float2x2() {
  return getToken(azslParser::Float2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float2x3() {
  return getToken(azslParser::Float2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float2x4() {
  return getToken(azslParser::Float2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float3x1() {
  return getToken(azslParser::Float3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float3x2() {
  return getToken(azslParser::Float3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float3x3() {
  return getToken(azslParser::Float3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float3x4() {
  return getToken(azslParser::Float3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float4x1() {
  return getToken(azslParser::Float4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float4x2() {
  return getToken(azslParser::Float4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float4x3() {
  return getToken(azslParser::Float4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Float4x4() {
  return getToken(azslParser::Float4x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double1x1() {
  return getToken(azslParser::Double1x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double1x2() {
  return getToken(azslParser::Double1x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double1x3() {
  return getToken(azslParser::Double1x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double1x4() {
  return getToken(azslParser::Double1x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double2x1() {
  return getToken(azslParser::Double2x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double2x2() {
  return getToken(azslParser::Double2x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double2x3() {
  return getToken(azslParser::Double2x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double2x4() {
  return getToken(azslParser::Double2x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double3x1() {
  return getToken(azslParser::Double3x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double3x2() {
  return getToken(azslParser::Double3x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double3x3() {
  return getToken(azslParser::Double3x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double3x4() {
  return getToken(azslParser::Double3x4, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double4x1() {
  return getToken(azslParser::Double4x1, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double4x2() {
  return getToken(azslParser::Double4x2, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double4x3() {
  return getToken(azslParser::Double4x3, 0);
}

tree::TerminalNode* azslParser::MatrixTypeContext::Double4x4() {
  return getToken(azslParser::Double4x4, 0);
}


size_t azslParser::MatrixTypeContext::getRuleIndex() const {
  return azslParser::RuleMatrixType;
}

void azslParser::MatrixTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatrixType(this);
}

void azslParser::MatrixTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatrixType(this);
}

azslParser::MatrixTypeContext* azslParser::matrixType() {
  MatrixTypeContext *_localctx = _tracker.createInstance<MatrixTypeContext>(_ctx, getState());
  enterRule(_localctx, 180, azslParser::RuleMatrixType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(963);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2305807824849993600) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & -36026598029197313) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & 8319) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & 4397979467775) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericMatrixPredefinedTypeContext ------------------------------------------------------------------

azslParser::GenericMatrixPredefinedTypeContext::GenericMatrixPredefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::Matrix() {
  return getToken(azslParser::Matrix, 0);
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::Less() {
  return getToken(azslParser::Less, 0);
}

azslParser::ScalarTypeContext* azslParser::GenericMatrixPredefinedTypeContext::scalarType() {
  return getRuleContext<azslParser::ScalarTypeContext>(0);
}

std::vector<tree::TerminalNode *> azslParser::GenericMatrixPredefinedTypeContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

std::vector<tree::TerminalNode *> azslParser::GenericMatrixPredefinedTypeContext::IntegerLiteral() {
  return getTokens(azslParser::IntegerLiteral);
}

tree::TerminalNode* azslParser::GenericMatrixPredefinedTypeContext::IntegerLiteral(size_t i) {
  return getToken(azslParser::IntegerLiteral, i);
}


size_t azslParser::GenericMatrixPredefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleGenericMatrixPredefinedType;
}

void azslParser::GenericMatrixPredefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericMatrixPredefinedType(this);
}

void azslParser::GenericMatrixPredefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericMatrixPredefinedType(this);
}

azslParser::GenericMatrixPredefinedTypeContext* azslParser::genericMatrixPredefinedType() {
  GenericMatrixPredefinedTypeContext *_localctx = _tracker.createInstance<GenericMatrixPredefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 182, azslParser::RuleGenericMatrixPredefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(965);
    match(azslParser::Matrix);
    setState(966);
    match(azslParser::Less);
    setState(967);
    scalarType();
    setState(968);
    match(azslParser::Comma);
    setState(969);
    antlrcpp::downCast<GenericMatrixPredefinedTypeContext *>(_localctx)->Rows_ = match(azslParser::IntegerLiteral);
    setState(970);
    match(azslParser::Comma);
    setState(971);
    antlrcpp::downCast<GenericMatrixPredefinedTypeContext *>(_localctx)->Cols_ = match(azslParser::IntegerLiteral);
    setState(972);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RegisterAllocationContext ------------------------------------------------------------------

azslParser::RegisterAllocationContext::RegisterAllocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::RegisterAllocationContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

tree::TerminalNode* azslParser::RegisterAllocationContext::Register() {
  return getToken(azslParser::Register, 0);
}

tree::TerminalNode* azslParser::RegisterAllocationContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::RegisterAllocationContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::RegisterAllocationContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::RegisterAllocationContext::getRuleIndex() const {
  return azslParser::RuleRegisterAllocation;
}

void azslParser::RegisterAllocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRegisterAllocation(this);
}

void azslParser::RegisterAllocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRegisterAllocation(this);
}

azslParser::RegisterAllocationContext* azslParser::registerAllocation() {
  RegisterAllocationContext *_localctx = _tracker.createInstance<RegisterAllocationContext>(_ctx, getState());
  enterRule(_localctx, 184, azslParser::RuleRegisterAllocation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(974);
    match(azslParser::Colon);
    setState(975);
    match(azslParser::Register);
    setState(976);
    match(azslParser::LeftParen);
    setState(977);
    antlrcpp::downCast<RegisterAllocationContext *>(_localctx)->Address = match(azslParser::Identifier);
    setState(978);
    match(azslParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SamplerStatePropertyContext ------------------------------------------------------------------

azslParser::SamplerStatePropertyContext::SamplerStatePropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SamplerStatePropertyContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::SamplerStatePropertyContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

tree::TerminalNode* azslParser::SamplerStatePropertyContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::ExpressionContext* azslParser::SamplerStatePropertyContext::expression() {
  return getRuleContext<azslParser::ExpressionContext>(0);
}


size_t azslParser::SamplerStatePropertyContext::getRuleIndex() const {
  return azslParser::RuleSamplerStateProperty;
}

void azslParser::SamplerStatePropertyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSamplerStateProperty(this);
}

void azslParser::SamplerStatePropertyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSamplerStateProperty(this);
}

azslParser::SamplerStatePropertyContext* azslParser::samplerStateProperty() {
  SamplerStatePropertyContext *_localctx = _tracker.createInstance<SamplerStatePropertyContext>(_ctx, getState());
  enterRule(_localctx, 186, azslParser::RuleSamplerStateProperty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(980);
    antlrcpp::downCast<SamplerStatePropertyContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(981);
    antlrcpp::downCast<SamplerStatePropertyContext *>(_localctx)->EqualsToken = match(azslParser::Assign);
    setState(982);
    antlrcpp::downCast<SamplerStatePropertyContext *>(_localctx)->Expr = expression(0);
    setState(983);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

azslParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::LiteralContext::True() {
  return getToken(azslParser::True, 0);
}

tree::TerminalNode* azslParser::LiteralContext::False() {
  return getToken(azslParser::False, 0);
}

tree::TerminalNode* azslParser::LiteralContext::FloatLiteral() {
  return getToken(azslParser::FloatLiteral, 0);
}

tree::TerminalNode* azslParser::LiteralContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}

std::vector<tree::TerminalNode *> azslParser::LiteralContext::StringLiteral() {
  return getTokens(azslParser::StringLiteral);
}

tree::TerminalNode* azslParser::LiteralContext::StringLiteral(size_t i) {
  return getToken(azslParser::StringLiteral, i);
}


size_t azslParser::LiteralContext::getRuleIndex() const {
  return azslParser::RuleLiteral;
}

void azslParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void azslParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

azslParser::LiteralContext* azslParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 188, azslParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(994);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::True: {
        enterOuterAlt(_localctx, 1);
        setState(985);
        match(azslParser::True);
        break;
      }

      case azslParser::False: {
        enterOuterAlt(_localctx, 2);
        setState(986);
        match(azslParser::False);
        break;
      }

      case azslParser::FloatLiteral: {
        enterOuterAlt(_localctx, 3);
        setState(987);
        match(azslParser::FloatLiteral);
        break;
      }

      case azslParser::IntegerLiteral: {
        enterOuterAlt(_localctx, 4);
        setState(988);
        match(azslParser::IntegerLiteral);
        break;
      }

      case azslParser::StringLiteral: {
        enterOuterAlt(_localctx, 5);
        setState(990); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(989);
                  match(azslParser::StringLiteral);
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(992); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeadingTypeFunctionSignatureContext ------------------------------------------------------------------

azslParser::LeadingTypeFunctionSignatureContext::LeadingTypeFunctionSignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TypeContext* azslParser::LeadingTypeFunctionSignatureContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::ColonColon() {
  return getToken(azslParser::ColonColon, 0);
}

azslParser::GenericParameterListContext* azslParser::LeadingTypeFunctionSignatureContext::genericParameterList() {
  return getRuleContext<azslParser::GenericParameterListContext>(0);
}

azslParser::FunctionParamsContext* azslParser::LeadingTypeFunctionSignatureContext::functionParams() {
  return getRuleContext<azslParser::FunctionParamsContext>(0);
}

tree::TerminalNode* azslParser::LeadingTypeFunctionSignatureContext::Override() {
  return getToken(azslParser::Override, 0);
}

azslParser::HlslSemanticContext* azslParser::LeadingTypeFunctionSignatureContext::hlslSemantic() {
  return getRuleContext<azslParser::HlslSemanticContext>(0);
}

azslParser::UserDefinedTypeContext* azslParser::LeadingTypeFunctionSignatureContext::userDefinedType() {
  return getRuleContext<azslParser::UserDefinedTypeContext>(0);
}


size_t azslParser::LeadingTypeFunctionSignatureContext::getRuleIndex() const {
  return azslParser::RuleLeadingTypeFunctionSignature;
}

void azslParser::LeadingTypeFunctionSignatureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeadingTypeFunctionSignature(this);
}

void azslParser::LeadingTypeFunctionSignatureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeadingTypeFunctionSignature(this);
}

azslParser::LeadingTypeFunctionSignatureContext* azslParser::leadingTypeFunctionSignature() {
  LeadingTypeFunctionSignatureContext *_localctx = _tracker.createInstance<LeadingTypeFunctionSignatureContext>(_ctx, getState());
  enterRule(_localctx, 190, azslParser::RuleLeadingTypeFunctionSignature);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(996);
    type();
    setState(1000);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      setState(997);
      antlrcpp::downCast<LeadingTypeFunctionSignatureContext *>(_localctx)->ClassName = userDefinedType();
      setState(998);
      match(azslParser::ColonColon);
      break;
    }

    default:
      break;
    }
    setState(1002);
    antlrcpp::downCast<LeadingTypeFunctionSignatureContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(1004);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Less) {
      setState(1003);
      genericParameterList();
    }
    setState(1006);
    match(azslParser::LeftParen);
    setState(1008);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -97) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 153122387330662335) != 0) || ((((_la - 336) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 336)) & 34368126977) != 0)) {
      setState(1007);
      functionParams();
    }
    setState(1010);
    match(azslParser::RightParen);
    setState(1012);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Override) {
      setState(1011);
      match(azslParser::Override);
    }
    setState(1015);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(1014);
      hlslSemantic();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HlslFunctionDefinitionContext ------------------------------------------------------------------

azslParser::HlslFunctionDefinitionContext::HlslFunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::LeadingTypeFunctionSignatureContext* azslParser::HlslFunctionDefinitionContext::leadingTypeFunctionSignature() {
  return getRuleContext<azslParser::LeadingTypeFunctionSignatureContext>(0);
}

azslParser::BlockContext* azslParser::HlslFunctionDefinitionContext::block() {
  return getRuleContext<azslParser::BlockContext>(0);
}


size_t azslParser::HlslFunctionDefinitionContext::getRuleIndex() const {
  return azslParser::RuleHlslFunctionDefinition;
}

void azslParser::HlslFunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHlslFunctionDefinition(this);
}

void azslParser::HlslFunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHlslFunctionDefinition(this);
}

azslParser::HlslFunctionDefinitionContext* azslParser::hlslFunctionDefinition() {
  HlslFunctionDefinitionContext *_localctx = _tracker.createInstance<HlslFunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 192, azslParser::RuleHlslFunctionDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1017);
    leadingTypeFunctionSignature();
    setState(1018);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HlslFunctionDeclarationContext ------------------------------------------------------------------

azslParser::HlslFunctionDeclarationContext::HlslFunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::LeadingTypeFunctionSignatureContext* azslParser::HlslFunctionDeclarationContext::leadingTypeFunctionSignature() {
  return getRuleContext<azslParser::LeadingTypeFunctionSignatureContext>(0);
}

tree::TerminalNode* azslParser::HlslFunctionDeclarationContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::HlslFunctionDeclarationContext::getRuleIndex() const {
  return azslParser::RuleHlslFunctionDeclaration;
}

void azslParser::HlslFunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHlslFunctionDeclaration(this);
}

void azslParser::HlslFunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHlslFunctionDeclaration(this);
}

azslParser::HlslFunctionDeclarationContext* azslParser::hlslFunctionDeclaration() {
  HlslFunctionDeclarationContext *_localctx = _tracker.createInstance<HlslFunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 194, azslParser::RuleHlslFunctionDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1020);
    leadingTypeFunctionSignature();
    setState(1021);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserDefinedTypeContext ------------------------------------------------------------------

azslParser::UserDefinedTypeContext::UserDefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::IdExpressionContext* azslParser::UserDefinedTypeContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}

azslParser::AnyStructuredTypeDefinitionContext* azslParser::UserDefinedTypeContext::anyStructuredTypeDefinition() {
  return getRuleContext<azslParser::AnyStructuredTypeDefinitionContext>(0);
}


size_t azslParser::UserDefinedTypeContext::getRuleIndex() const {
  return azslParser::RuleUserDefinedType;
}

void azslParser::UserDefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserDefinedType(this);
}

void azslParser::UserDefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserDefinedType(this);
}

azslParser::UserDefinedTypeContext* azslParser::userDefinedType() {
  UserDefinedTypeContext *_localctx = _tracker.createInstance<UserDefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 196, azslParser::RuleUserDefinedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1025);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::ColonColon:
      case azslParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1023);
        idExpression();
        break;
      }

      case azslParser::Class:
      case azslParser::Enum:
      case azslParser::Interface:
      case azslParser::Struct: {
        enterOuterAlt(_localctx, 2);
        setState(1024);
        anyStructuredTypeDefinition();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssociatedTypeDeclarationContext ------------------------------------------------------------------

azslParser::AssociatedTypeDeclarationContext::AssociatedTypeDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AssociatedTypeDeclarationContext::KW_AssociatedType() {
  return getToken(azslParser::KW_AssociatedType, 0);
}

tree::TerminalNode* azslParser::AssociatedTypeDeclarationContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::AssociatedTypeDeclarationContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

azslParser::GenericConstraintContext* azslParser::AssociatedTypeDeclarationContext::genericConstraint() {
  return getRuleContext<azslParser::GenericConstraintContext>(0);
}


size_t azslParser::AssociatedTypeDeclarationContext::getRuleIndex() const {
  return azslParser::RuleAssociatedTypeDeclaration;
}

void azslParser::AssociatedTypeDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssociatedTypeDeclaration(this);
}

void azslParser::AssociatedTypeDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssociatedTypeDeclaration(this);
}

azslParser::AssociatedTypeDeclarationContext* azslParser::associatedTypeDeclaration() {
  AssociatedTypeDeclarationContext *_localctx = _tracker.createInstance<AssociatedTypeDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 198, azslParser::RuleAssociatedTypeDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1027);
    match(azslParser::KW_AssociatedType);
    setState(1028);
    antlrcpp::downCast<AssociatedTypeDeclarationContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(1030);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(1029);
      genericConstraint();
    }
    setState(1032);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedefStatementContext ------------------------------------------------------------------

azslParser::TypedefStatementContext::TypedefStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TypedefStatementContext::KW_Typedef() {
  return getToken(azslParser::KW_Typedef, 0);
}

tree::TerminalNode* azslParser::TypedefStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

azslParser::TypeContext* azslParser::TypedefStatementContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

tree::TerminalNode* azslParser::TypedefStatementContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::TypedefStatementContext::getRuleIndex() const {
  return azslParser::RuleTypedefStatement;
}

void azslParser::TypedefStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedefStatement(this);
}

void azslParser::TypedefStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedefStatement(this);
}

azslParser::TypedefStatementContext* azslParser::typedefStatement() {
  TypedefStatementContext *_localctx = _tracker.createInstance<TypedefStatementContext>(_ctx, getState());
  enterRule(_localctx, 200, azslParser::RuleTypedefStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1034);
    match(azslParser::KW_Typedef);
    setState(1035);
    antlrcpp::downCast<TypedefStatementContext *>(_localctx)->ExistingType = type();
    setState(1036);
    antlrcpp::downCast<TypedefStatementContext *>(_localctx)->NewTypeName = match(azslParser::Identifier);
    setState(1037);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypealiasStatementContext ------------------------------------------------------------------

azslParser::TypealiasStatementContext::TypealiasStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TypealiasStatementContext::KW_TypeAlias() {
  return getToken(azslParser::KW_TypeAlias, 0);
}

tree::TerminalNode* azslParser::TypealiasStatementContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::TypealiasStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::TypealiasStatementContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

azslParser::TypeContext* azslParser::TypealiasStatementContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}


size_t azslParser::TypealiasStatementContext::getRuleIndex() const {
  return azslParser::RuleTypealiasStatement;
}

void azslParser::TypealiasStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypealiasStatement(this);
}

void azslParser::TypealiasStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypealiasStatement(this);
}

azslParser::TypealiasStatementContext* azslParser::typealiasStatement() {
  TypealiasStatementContext *_localctx = _tracker.createInstance<TypealiasStatementContext>(_ctx, getState());
  enterRule(_localctx, 202, azslParser::RuleTypealiasStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1039);
    match(azslParser::KW_TypeAlias);
    setState(1040);
    antlrcpp::downCast<TypealiasStatementContext *>(_localctx)->NewTypeName = match(azslParser::Identifier);
    setState(1041);
    match(azslParser::Assign);
    setState(1042);
    antlrcpp::downCast<TypealiasStatementContext *>(_localctx)->ExistingType = type();
    setState(1043);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAliasingDefinitionStatementContext ------------------------------------------------------------------

azslParser::TypeAliasingDefinitionStatementContext::TypeAliasingDefinitionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::TypealiasStatementContext* azslParser::TypeAliasingDefinitionStatementContext::typealiasStatement() {
  return getRuleContext<azslParser::TypealiasStatementContext>(0);
}

azslParser::TypedefStatementContext* azslParser::TypeAliasingDefinitionStatementContext::typedefStatement() {
  return getRuleContext<azslParser::TypedefStatementContext>(0);
}


size_t azslParser::TypeAliasingDefinitionStatementContext::getRuleIndex() const {
  return azslParser::RuleTypeAliasingDefinitionStatement;
}

void azslParser::TypeAliasingDefinitionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAliasingDefinitionStatement(this);
}

void azslParser::TypeAliasingDefinitionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAliasingDefinitionStatement(this);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::typeAliasingDefinitionStatement() {
  TypeAliasingDefinitionStatementContext *_localctx = _tracker.createInstance<TypeAliasingDefinitionStatementContext>(_ctx, getState());
  enterRule(_localctx, 204, azslParser::RuleTypeAliasingDefinitionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1047);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::KW_TypeAlias: {
        enterOuterAlt(_localctx, 1);
        setState(1045);
        typealiasStatement();
        break;
      }

      case azslParser::KW_Typedef: {
        enterOuterAlt(_localctx, 2);
        setState(1046);
        typedefStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeofExpressionContext ------------------------------------------------------------------

azslParser::TypeofExpressionContext::TypeofExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::TypeofExpressionContext::KW_Typeof() {
  return getToken(azslParser::KW_Typeof, 0);
}

tree::TerminalNode* azslParser::TypeofExpressionContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::TypeofExpressionContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

azslParser::TypeContext* azslParser::TypeofExpressionContext::type() {
  return getRuleContext<azslParser::TypeContext>(0);
}

azslParser::ExpressionExtContext* azslParser::TypeofExpressionContext::expressionExt() {
  return getRuleContext<azslParser::ExpressionExtContext>(0);
}

tree::TerminalNode* azslParser::TypeofExpressionContext::ColonColon() {
  return getToken(azslParser::ColonColon, 0);
}

azslParser::IdExpressionContext* azslParser::TypeofExpressionContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}


size_t azslParser::TypeofExpressionContext::getRuleIndex() const {
  return azslParser::RuleTypeofExpression;
}

void azslParser::TypeofExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeofExpression(this);
}

void azslParser::TypeofExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeofExpression(this);
}

azslParser::TypeofExpressionContext* azslParser::typeofExpression() {
  TypeofExpressionContext *_localctx = _tracker.createInstance<TypeofExpressionContext>(_ctx, getState());
  enterRule(_localctx, 206, azslParser::RuleTypeofExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1049);
    match(azslParser::KW_Typeof);
    setState(1050);
    match(azslParser::LeftParen);
    setState(1053);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(1051);
      antlrcpp::downCast<TypeofExpressionContext *>(_localctx)->Expr = expressionExt(0);
      break;
    }

    case 2: {
      setState(1052);
      type();
      break;
    }

    default:
      break;
    }
    setState(1055);
    match(azslParser::RightParen);
    setState(1058);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(1056);
      match(azslParser::ColonColon);
      setState(1057);
      antlrcpp::downCast<TypeofExpressionContext *>(_localctx)->SubQualification = idExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericParameterListContext ------------------------------------------------------------------

azslParser::GenericParameterListContext::GenericParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericParameterListContext::Less() {
  return getToken(azslParser::Less, 0);
}

std::vector<azslParser::GenericTypeDefinitionContext *> azslParser::GenericParameterListContext::genericTypeDefinition() {
  return getRuleContexts<azslParser::GenericTypeDefinitionContext>();
}

azslParser::GenericTypeDefinitionContext* azslParser::GenericParameterListContext::genericTypeDefinition(size_t i) {
  return getRuleContext<azslParser::GenericTypeDefinitionContext>(i);
}

tree::TerminalNode* azslParser::GenericParameterListContext::Greater() {
  return getToken(azslParser::Greater, 0);
}

std::vector<tree::TerminalNode *> azslParser::GenericParameterListContext::Comma() {
  return getTokens(azslParser::Comma);
}

tree::TerminalNode* azslParser::GenericParameterListContext::Comma(size_t i) {
  return getToken(azslParser::Comma, i);
}


size_t azslParser::GenericParameterListContext::getRuleIndex() const {
  return azslParser::RuleGenericParameterList;
}

void azslParser::GenericParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericParameterList(this);
}

void azslParser::GenericParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericParameterList(this);
}

azslParser::GenericParameterListContext* azslParser::genericParameterList() {
  GenericParameterListContext *_localctx = _tracker.createInstance<GenericParameterListContext>(_ctx, getState());
  enterRule(_localctx, 208, azslParser::RuleGenericParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1060);
    match(azslParser::Less);
    setState(1061);
    genericTypeDefinition();
    setState(1066);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::Comma) {
      setState(1062);
      match(azslParser::Comma);
      setState(1063);
      genericTypeDefinition();
      setState(1068);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1069);
    match(azslParser::Greater);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericTypeDefinitionContext ------------------------------------------------------------------

azslParser::GenericTypeDefinitionContext::GenericTypeDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericTypeDefinitionContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}

azslParser::GenericConstraintContext* azslParser::GenericTypeDefinitionContext::genericConstraint() {
  return getRuleContext<azslParser::GenericConstraintContext>(0);
}


size_t azslParser::GenericTypeDefinitionContext::getRuleIndex() const {
  return azslParser::RuleGenericTypeDefinition;
}

void azslParser::GenericTypeDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericTypeDefinition(this);
}

void azslParser::GenericTypeDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericTypeDefinition(this);
}

azslParser::GenericTypeDefinitionContext* azslParser::genericTypeDefinition() {
  GenericTypeDefinitionContext *_localctx = _tracker.createInstance<GenericTypeDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 210, azslParser::RuleGenericTypeDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1071);
    antlrcpp::downCast<GenericTypeDefinitionContext *>(_localctx)->GenericTypeName = match(azslParser::Identifier);
    setState(1073);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(1072);
      genericConstraint();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericConstraintContext ------------------------------------------------------------------

azslParser::GenericConstraintContext::GenericConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::GenericConstraintContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

azslParser::UserDefinedTypeContext* azslParser::GenericConstraintContext::userDefinedType() {
  return getRuleContext<azslParser::UserDefinedTypeContext>(0);
}


size_t azslParser::GenericConstraintContext::getRuleIndex() const {
  return azslParser::RuleGenericConstraint;
}

void azslParser::GenericConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericConstraint(this);
}

void azslParser::GenericConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericConstraint(this);
}

azslParser::GenericConstraintContext* azslParser::genericConstraint() {
  GenericConstraintContext *_localctx = _tracker.createInstance<GenericConstraintContext>(_ctx, getState());
  enterRule(_localctx, 212, azslParser::RuleGenericConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1075);
    match(azslParser::Colon);
    setState(1076);
    userDefinedType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LanguageDefinedConstraintContext ------------------------------------------------------------------

azslParser::LanguageDefinedConstraintContext::LanguageDefinedConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::LanguageDefinedConstraintContext::KW_Fundamental() {
  return getToken(azslParser::KW_Fundamental, 0);
}


size_t azslParser::LanguageDefinedConstraintContext::getRuleIndex() const {
  return azslParser::RuleLanguageDefinedConstraint;
}

void azslParser::LanguageDefinedConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLanguageDefinedConstraint(this);
}

void azslParser::LanguageDefinedConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLanguageDefinedConstraint(this);
}

azslParser::LanguageDefinedConstraintContext* azslParser::languageDefinedConstraint() {
  LanguageDefinedConstraintContext *_localctx = _tracker.createInstance<LanguageDefinedConstraintContext>(_ctx, getState());
  enterRule(_localctx, 214, azslParser::RuleLanguageDefinedConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1078);
    match(azslParser::KW_Fundamental);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

azslParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::HlslFunctionDeclarationContext* azslParser::FunctionDeclarationContext::hlslFunctionDeclaration() {
  return getRuleContext<azslParser::HlslFunctionDeclarationContext>(0);
}


size_t azslParser::FunctionDeclarationContext::getRuleIndex() const {
  return azslParser::RuleFunctionDeclaration;
}

void azslParser::FunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDeclaration(this);
}

void azslParser::FunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDeclaration(this);
}

azslParser::FunctionDeclarationContext* azslParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 216, azslParser::RuleFunctionDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1080);
    hlslFunctionDeclaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributedFunctionDeclarationContext ------------------------------------------------------------------

azslParser::AttributedFunctionDeclarationContext::AttributedFunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::FunctionDeclarationContext* azslParser::AttributedFunctionDeclarationContext::functionDeclaration() {
  return getRuleContext<azslParser::FunctionDeclarationContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AttributedFunctionDeclarationContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AttributedFunctionDeclarationContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AttributedFunctionDeclarationContext::getRuleIndex() const {
  return azslParser::RuleAttributedFunctionDeclaration;
}

void azslParser::AttributedFunctionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributedFunctionDeclaration(this);
}

void azslParser::AttributedFunctionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributedFunctionDeclaration(this);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::attributedFunctionDeclaration() {
  AttributedFunctionDeclarationContext *_localctx = _tracker.createInstance<AttributedFunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 218, azslParser::RuleAttributedFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1085);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(1082);
      attributeSpecifierAny();
      setState(1087);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1088);
    functionDeclaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDefinitionContext ------------------------------------------------------------------

azslParser::FunctionDefinitionContext::FunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::HlslFunctionDefinitionContext* azslParser::FunctionDefinitionContext::hlslFunctionDefinition() {
  return getRuleContext<azslParser::HlslFunctionDefinitionContext>(0);
}


size_t azslParser::FunctionDefinitionContext::getRuleIndex() const {
  return azslParser::RuleFunctionDefinition;
}

void azslParser::FunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDefinition(this);
}

void azslParser::FunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDefinition(this);
}

azslParser::FunctionDefinitionContext* azslParser::functionDefinition() {
  FunctionDefinitionContext *_localctx = _tracker.createInstance<FunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 220, azslParser::RuleFunctionDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1090);
    hlslFunctionDefinition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributedFunctionDefinitionContext ------------------------------------------------------------------

azslParser::AttributedFunctionDefinitionContext::AttributedFunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::FunctionDefinitionContext* azslParser::AttributedFunctionDefinitionContext::functionDefinition() {
  return getRuleContext<azslParser::FunctionDefinitionContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AttributedFunctionDefinitionContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AttributedFunctionDefinitionContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AttributedFunctionDefinitionContext::getRuleIndex() const {
  return azslParser::RuleAttributedFunctionDefinition;
}

void azslParser::AttributedFunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributedFunctionDefinition(this);
}

void azslParser::AttributedFunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributedFunctionDefinition(this);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::attributedFunctionDefinition() {
  AttributedFunctionDefinitionContext *_localctx = _tracker.createInstance<AttributedFunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 222, azslParser::RuleAttributedFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1095);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(1092);
      attributeSpecifierAny();
      setState(1097);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1098);
    functionDefinition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompilerExtensionStatementContext ------------------------------------------------------------------

azslParser::CompilerExtensionStatementContext::CompilerExtensionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_print_message() {
  return getToken(azslParser::KW_ext_print_message, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::LeftParen() {
  return getToken(azslParser::LeftParen, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::RightParen() {
  return getToken(azslParser::RightParen, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::StringLiteral() {
  return getToken(azslParser::StringLiteral, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_print_symbol() {
  return getToken(azslParser::KW_ext_print_symbol, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::Comma() {
  return getToken(azslParser::Comma, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_prtsym_fully_qualified() {
  return getToken(azslParser::KW_ext_prtsym_fully_qualified, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_prtsym_least_qualified() {
  return getToken(azslParser::KW_ext_prtsym_least_qualified, 0);
}

tree::TerminalNode* azslParser::CompilerExtensionStatementContext::KW_ext_prtsym_constint_value() {
  return getToken(azslParser::KW_ext_prtsym_constint_value, 0);
}

azslParser::IdExpressionContext* azslParser::CompilerExtensionStatementContext::idExpression() {
  return getRuleContext<azslParser::IdExpressionContext>(0);
}

azslParser::TypeofExpressionContext* azslParser::CompilerExtensionStatementContext::typeofExpression() {
  return getRuleContext<azslParser::TypeofExpressionContext>(0);
}


size_t azslParser::CompilerExtensionStatementContext::getRuleIndex() const {
  return azslParser::RuleCompilerExtensionStatement;
}

void azslParser::CompilerExtensionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompilerExtensionStatement(this);
}

void azslParser::CompilerExtensionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompilerExtensionStatement(this);
}

azslParser::CompilerExtensionStatementContext* azslParser::compilerExtensionStatement() {
  CompilerExtensionStatementContext *_localctx = _tracker.createInstance<CompilerExtensionStatementContext>(_ctx, getState());
  enterRule(_localctx, 224, azslParser::RuleCompilerExtensionStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1116);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::KW_ext_print_message: {
        enterOuterAlt(_localctx, 1);
        setState(1100);
        match(azslParser::KW_ext_print_message);
        setState(1101);
        match(azslParser::LeftParen);
        setState(1102);
        antlrcpp::downCast<CompilerExtensionStatementContext *>(_localctx)->Message = match(azslParser::StringLiteral);
        setState(1103);
        match(azslParser::RightParen);
        setState(1104);
        match(azslParser::Semi);
        break;
      }

      case azslParser::KW_ext_print_symbol: {
        enterOuterAlt(_localctx, 2);
        setState(1105);
        match(azslParser::KW_ext_print_symbol);
        setState(1106);
        match(azslParser::LeftParen);
        setState(1109);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case azslParser::ColonColon:
          case azslParser::Identifier: {
            setState(1107);
            idExpression();
            break;
          }

          case azslParser::KW_Typeof: {
            setState(1108);
            typeofExpression();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1111);
        match(azslParser::Comma);
        setState(1112);
        _la = _input->LA(1);
        if (!(((((_la - 366) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 366)) & 7) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1113);
        match(azslParser::RightParen);
        setState(1114);
        match(azslParser::Semi);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgDefinitionContext ------------------------------------------------------------------

azslParser::SrgDefinitionContext::SrgDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SrgDefinitionContext::ShaderResourceGroup() {
  return getToken(azslParser::ShaderResourceGroup, 0);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<tree::TerminalNode *> azslParser::SrgDefinitionContext::Identifier() {
  return getTokens(azslParser::Identifier);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::Identifier(size_t i) {
  return getToken(azslParser::Identifier, i);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::Partial() {
  return getToken(azslParser::Partial, 0);
}

tree::TerminalNode* azslParser::SrgDefinitionContext::Colon() {
  return getToken(azslParser::Colon, 0);
}

std::vector<azslParser::SrgMemberDeclarationContext *> azslParser::SrgDefinitionContext::srgMemberDeclaration() {
  return getRuleContexts<azslParser::SrgMemberDeclarationContext>();
}

azslParser::SrgMemberDeclarationContext* azslParser::SrgDefinitionContext::srgMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::SrgMemberDeclarationContext>(i);
}


size_t azslParser::SrgDefinitionContext::getRuleIndex() const {
  return azslParser::RuleSrgDefinition;
}

void azslParser::SrgDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgDefinition(this);
}

void azslParser::SrgDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgDefinition(this);
}

azslParser::SrgDefinitionContext* azslParser::srgDefinition() {
  SrgDefinitionContext *_localctx = _tracker.createInstance<SrgDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 226, azslParser::RuleSrgDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1119);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Partial) {
      setState(1118);
      match(azslParser::Partial);
    }
    setState(1121);
    match(azslParser::ShaderResourceGroup);
    setState(1122);
    antlrcpp::downCast<SrgDefinitionContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(1125);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == azslParser::Colon) {
      setState(1123);
      match(azslParser::Colon);
      setState(1124);
      antlrcpp::downCast<SrgDefinitionContext *>(_localctx)->Semantic = match(azslParser::Identifier);
    }
    setState(1127);
    match(azslParser::LeftBrace);
    setState(1131);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917527996379168766) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -562950104416263) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -26389219639297) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -97) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & 153122387330662335) != 0) || ((((_la - 336) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 336)) & 34371272705) != 0)) {
      setState(1128);
      srgMemberDeclaration();
      setState(1133);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1134);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributedSrgDefinitionContext ------------------------------------------------------------------

azslParser::AttributedSrgDefinitionContext::AttributedSrgDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::SrgDefinitionContext* azslParser::AttributedSrgDefinitionContext::srgDefinition() {
  return getRuleContext<azslParser::SrgDefinitionContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AttributedSrgDefinitionContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AttributedSrgDefinitionContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AttributedSrgDefinitionContext::getRuleIndex() const {
  return azslParser::RuleAttributedSrgDefinition;
}

void azslParser::AttributedSrgDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributedSrgDefinition(this);
}

void azslParser::AttributedSrgDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributedSrgDefinition(this);
}

azslParser::AttributedSrgDefinitionContext* azslParser::attributedSrgDefinition() {
  AttributedSrgDefinitionContext *_localctx = _tracker.createInstance<AttributedSrgDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 228, azslParser::RuleAttributedSrgDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1139);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(1136);
      attributeSpecifierAny();
      setState(1141);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1142);
    srgDefinition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgMemberDeclarationContext ------------------------------------------------------------------

azslParser::SrgMemberDeclarationContext::SrgMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::StructDefinitionStatementContext* azslParser::SrgMemberDeclarationContext::structDefinitionStatement() {
  return getRuleContext<azslParser::StructDefinitionStatementContext>(0);
}

azslParser::AttributedFunctionDeclarationContext* azslParser::SrgMemberDeclarationContext::attributedFunctionDeclaration() {
  return getRuleContext<azslParser::AttributedFunctionDeclarationContext>(0);
}

azslParser::AttributedFunctionDefinitionContext* azslParser::SrgMemberDeclarationContext::attributedFunctionDefinition() {
  return getRuleContext<azslParser::AttributedFunctionDefinitionContext>(0);
}

azslParser::VariableDeclarationStatementContext* azslParser::SrgMemberDeclarationContext::variableDeclarationStatement() {
  return getRuleContext<azslParser::VariableDeclarationStatementContext>(0);
}

azslParser::EnumDefinitionStatementContext* azslParser::SrgMemberDeclarationContext::enumDefinitionStatement() {
  return getRuleContext<azslParser::EnumDefinitionStatementContext>(0);
}

azslParser::TypeAliasingDefinitionStatementContext* azslParser::SrgMemberDeclarationContext::typeAliasingDefinitionStatement() {
  return getRuleContext<azslParser::TypeAliasingDefinitionStatementContext>(0);
}

azslParser::AttributeSpecifierAnyContext* azslParser::SrgMemberDeclarationContext::attributeSpecifierAny() {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(0);
}


size_t azslParser::SrgMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSrgMemberDeclaration;
}

void azslParser::SrgMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgMemberDeclaration(this);
}

void azslParser::SrgMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgMemberDeclaration(this);
}

azslParser::SrgMemberDeclarationContext* azslParser::srgMemberDeclaration() {
  SrgMemberDeclarationContext *_localctx = _tracker.createInstance<SrgMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 230, azslParser::RuleSrgMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1151);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1144);
      structDefinitionStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1145);
      attributedFunctionDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1146);
      attributedFunctionDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1147);
      variableDeclarationStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1148);
      enumDefinitionStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1149);
      typeAliasingDefinitionStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1150);
      attributeSpecifierAny();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgSemanticContext ------------------------------------------------------------------

azslParser::SrgSemanticContext::SrgSemanticContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SrgSemanticContext::ShaderResourceGroupSemantic() {
  return getToken(azslParser::ShaderResourceGroupSemantic, 0);
}

azslParser::SrgSemanticBodyDeclarationContext* azslParser::SrgSemanticContext::srgSemanticBodyDeclaration() {
  return getRuleContext<azslParser::SrgSemanticBodyDeclarationContext>(0);
}

tree::TerminalNode* azslParser::SrgSemanticContext::Identifier() {
  return getToken(azslParser::Identifier, 0);
}


size_t azslParser::SrgSemanticContext::getRuleIndex() const {
  return azslParser::RuleSrgSemantic;
}

void azslParser::SrgSemanticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgSemantic(this);
}

void azslParser::SrgSemanticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgSemantic(this);
}

azslParser::SrgSemanticContext* azslParser::srgSemantic() {
  SrgSemanticContext *_localctx = _tracker.createInstance<SrgSemanticContext>(_ctx, getState());
  enterRule(_localctx, 232, azslParser::RuleSrgSemantic);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1153);
    match(azslParser::ShaderResourceGroupSemantic);
    setState(1154);
    antlrcpp::downCast<SrgSemanticContext *>(_localctx)->Name = match(azslParser::Identifier);
    setState(1155);
    srgSemanticBodyDeclaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributedSrgSemanticContext ------------------------------------------------------------------

azslParser::AttributedSrgSemanticContext::AttributedSrgSemanticContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::SrgSemanticContext* azslParser::AttributedSrgSemanticContext::srgSemantic() {
  return getRuleContext<azslParser::SrgSemanticContext>(0);
}

std::vector<azslParser::AttributeSpecifierAnyContext *> azslParser::AttributedSrgSemanticContext::attributeSpecifierAny() {
  return getRuleContexts<azslParser::AttributeSpecifierAnyContext>();
}

azslParser::AttributeSpecifierAnyContext* azslParser::AttributedSrgSemanticContext::attributeSpecifierAny(size_t i) {
  return getRuleContext<azslParser::AttributeSpecifierAnyContext>(i);
}


size_t azslParser::AttributedSrgSemanticContext::getRuleIndex() const {
  return azslParser::RuleAttributedSrgSemantic;
}

void azslParser::AttributedSrgSemanticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributedSrgSemantic(this);
}

void azslParser::AttributedSrgSemanticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributedSrgSemantic(this);
}

azslParser::AttributedSrgSemanticContext* azslParser::attributedSrgSemantic() {
  AttributedSrgSemanticContext *_localctx = _tracker.createInstance<AttributedSrgSemanticContext>(_ctx, getState());
  enterRule(_localctx, 234, azslParser::RuleAttributedSrgSemantic);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1160);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::LeftBracket

    || _la == azslParser::LeftDoubleBracket) {
      setState(1157);
      attributeSpecifierAny();
      setState(1162);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1163);
    srgSemantic();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgSemanticBodyDeclarationContext ------------------------------------------------------------------

azslParser::SrgSemanticBodyDeclarationContext::SrgSemanticBodyDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SrgSemanticBodyDeclarationContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::SrgSemanticBodyDeclarationContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<azslParser::SrgSemanticMemberDeclarationContext *> azslParser::SrgSemanticBodyDeclarationContext::srgSemanticMemberDeclaration() {
  return getRuleContexts<azslParser::SrgSemanticMemberDeclarationContext>();
}

azslParser::SrgSemanticMemberDeclarationContext* azslParser::SrgSemanticBodyDeclarationContext::srgSemanticMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::SrgSemanticMemberDeclarationContext>(i);
}


size_t azslParser::SrgSemanticBodyDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSrgSemanticBodyDeclaration;
}

void azslParser::SrgSemanticBodyDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgSemanticBodyDeclaration(this);
}

void azslParser::SrgSemanticBodyDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgSemanticBodyDeclaration(this);
}

azslParser::SrgSemanticBodyDeclarationContext* azslParser::srgSemanticBodyDeclaration() {
  SrgSemanticBodyDeclarationContext *_localctx = _tracker.createInstance<SrgSemanticBodyDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 236, azslParser::RuleSrgSemanticBodyDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1165);
    match(azslParser::LeftBrace);
    setState(1169);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == azslParser::FrequencyId

    || _la == azslParser::ShaderVariantFallback) {
      setState(1166);
      srgSemanticMemberDeclaration();
      setState(1171);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1172);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrgSemanticMemberDeclarationContext ------------------------------------------------------------------

azslParser::SrgSemanticMemberDeclarationContext::SrgSemanticMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SrgSemanticMemberDeclarationContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::SrgSemanticMemberDeclarationContext::Semi() {
  return getToken(azslParser::Semi, 0);
}

tree::TerminalNode* azslParser::SrgSemanticMemberDeclarationContext::FrequencyId() {
  return getToken(azslParser::FrequencyId, 0);
}

azslParser::LiteralContext* azslParser::SrgSemanticMemberDeclarationContext::literal() {
  return getRuleContext<azslParser::LiteralContext>(0);
}

tree::TerminalNode* azslParser::SrgSemanticMemberDeclarationContext::ShaderVariantFallback() {
  return getToken(azslParser::ShaderVariantFallback, 0);
}


size_t azslParser::SrgSemanticMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSrgSemanticMemberDeclaration;
}

void azslParser::SrgSemanticMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrgSemanticMemberDeclaration(this);
}

void azslParser::SrgSemanticMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrgSemanticMemberDeclaration(this);
}

azslParser::SrgSemanticMemberDeclarationContext* azslParser::srgSemanticMemberDeclaration() {
  SrgSemanticMemberDeclarationContext *_localctx = _tracker.createInstance<SrgSemanticMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 238, azslParser::RuleSrgSemanticMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1184);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::FrequencyId: {
        enterOuterAlt(_localctx, 1);
        setState(1174);
        antlrcpp::downCast<SrgSemanticMemberDeclarationContext *>(_localctx)->Frequency = match(azslParser::FrequencyId);
        setState(1175);
        match(azslParser::Assign);
        setState(1176);
        antlrcpp::downCast<SrgSemanticMemberDeclarationContext *>(_localctx)->FrequencyValue = literal();
        setState(1177);
        match(azslParser::Semi);
        break;
      }

      case azslParser::ShaderVariantFallback: {
        enterOuterAlt(_localctx, 2);
        setState(1179);
        antlrcpp::downCast<SrgSemanticMemberDeclarationContext *>(_localctx)->VariantFallback = match(azslParser::ShaderVariantFallback);
        setState(1180);
        match(azslParser::Assign);
        setState(1181);
        antlrcpp::downCast<SrgSemanticMemberDeclarationContext *>(_localctx)->VariantFallbackValue = literal();
        setState(1182);
        match(azslParser::Semi);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SamplerBodyDeclarationContext ------------------------------------------------------------------

azslParser::SamplerBodyDeclarationContext::SamplerBodyDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::SamplerBodyDeclarationContext::LeftBrace() {
  return getToken(azslParser::LeftBrace, 0);
}

tree::TerminalNode* azslParser::SamplerBodyDeclarationContext::RightBrace() {
  return getToken(azslParser::RightBrace, 0);
}

std::vector<azslParser::SamplerMemberDeclarationContext *> azslParser::SamplerBodyDeclarationContext::samplerMemberDeclaration() {
  return getRuleContexts<azslParser::SamplerMemberDeclarationContext>();
}

azslParser::SamplerMemberDeclarationContext* azslParser::SamplerBodyDeclarationContext::samplerMemberDeclaration(size_t i) {
  return getRuleContext<azslParser::SamplerMemberDeclarationContext>(i);
}


size_t azslParser::SamplerBodyDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSamplerBodyDeclaration;
}

void azslParser::SamplerBodyDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSamplerBodyDeclaration(this);
}

void azslParser::SamplerBodyDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSamplerBodyDeclaration(this);
}

azslParser::SamplerBodyDeclarationContext* azslParser::samplerBodyDeclaration() {
  SamplerBodyDeclarationContext *_localctx = _tracker.createInstance<SamplerBodyDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 240, azslParser::RuleSamplerBodyDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1186);
    match(azslParser::LeftBrace);
    setState(1190);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 272) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 272)) & 8191) != 0)) {
      setState(1187);
      samplerMemberDeclaration();
      setState(1192);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1193);
    match(azslParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SamplerMemberDeclarationContext ------------------------------------------------------------------

azslParser::SamplerMemberDeclarationContext::SamplerMemberDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

azslParser::MaxAnisotropyOptionContext* azslParser::SamplerMemberDeclarationContext::maxAnisotropyOption() {
  return getRuleContext<azslParser::MaxAnisotropyOptionContext>(0);
}

azslParser::MinFilterOptionContext* azslParser::SamplerMemberDeclarationContext::minFilterOption() {
  return getRuleContext<azslParser::MinFilterOptionContext>(0);
}

azslParser::MagFilterOptionContext* azslParser::SamplerMemberDeclarationContext::magFilterOption() {
  return getRuleContext<azslParser::MagFilterOptionContext>(0);
}

azslParser::MipFilterOptionContext* azslParser::SamplerMemberDeclarationContext::mipFilterOption() {
  return getRuleContext<azslParser::MipFilterOptionContext>(0);
}

azslParser::ReductionTypeOptionContext* azslParser::SamplerMemberDeclarationContext::reductionTypeOption() {
  return getRuleContext<azslParser::ReductionTypeOptionContext>(0);
}

azslParser::ComparisonFunctionOptionContext* azslParser::SamplerMemberDeclarationContext::comparisonFunctionOption() {
  return getRuleContext<azslParser::ComparisonFunctionOptionContext>(0);
}

azslParser::AddressUOptionContext* azslParser::SamplerMemberDeclarationContext::addressUOption() {
  return getRuleContext<azslParser::AddressUOptionContext>(0);
}

azslParser::AddressVOptionContext* azslParser::SamplerMemberDeclarationContext::addressVOption() {
  return getRuleContext<azslParser::AddressVOptionContext>(0);
}

azslParser::AddressWOptionContext* azslParser::SamplerMemberDeclarationContext::addressWOption() {
  return getRuleContext<azslParser::AddressWOptionContext>(0);
}

azslParser::MinLodOptionContext* azslParser::SamplerMemberDeclarationContext::minLodOption() {
  return getRuleContext<azslParser::MinLodOptionContext>(0);
}

azslParser::MaxLodOptionContext* azslParser::SamplerMemberDeclarationContext::maxLodOption() {
  return getRuleContext<azslParser::MaxLodOptionContext>(0);
}

azslParser::MipLodBiasOptionContext* azslParser::SamplerMemberDeclarationContext::mipLodBiasOption() {
  return getRuleContext<azslParser::MipLodBiasOptionContext>(0);
}

azslParser::BorderColorOptionContext* azslParser::SamplerMemberDeclarationContext::borderColorOption() {
  return getRuleContext<azslParser::BorderColorOptionContext>(0);
}


size_t azslParser::SamplerMemberDeclarationContext::getRuleIndex() const {
  return azslParser::RuleSamplerMemberDeclaration;
}

void azslParser::SamplerMemberDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSamplerMemberDeclaration(this);
}

void azslParser::SamplerMemberDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSamplerMemberDeclaration(this);
}

azslParser::SamplerMemberDeclarationContext* azslParser::samplerMemberDeclaration() {
  SamplerMemberDeclarationContext *_localctx = _tracker.createInstance<SamplerMemberDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 242, azslParser::RuleSamplerMemberDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1208);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case azslParser::MAX_ANISOTROPY: {
        enterOuterAlt(_localctx, 1);
        setState(1195);
        maxAnisotropyOption();
        break;
      }

      case azslParser::MIN_FILTER: {
        enterOuterAlt(_localctx, 2);
        setState(1196);
        minFilterOption();
        break;
      }

      case azslParser::MAG_FILTER: {
        enterOuterAlt(_localctx, 3);
        setState(1197);
        magFilterOption();
        break;
      }

      case azslParser::MIP_FILTER: {
        enterOuterAlt(_localctx, 4);
        setState(1198);
        mipFilterOption();
        break;
      }

      case azslParser::REDUCTION_TYPE: {
        enterOuterAlt(_localctx, 5);
        setState(1199);
        reductionTypeOption();
        break;
      }

      case azslParser::COMPARISON_FUNC: {
        enterOuterAlt(_localctx, 6);
        setState(1200);
        comparisonFunctionOption();
        break;
      }

      case azslParser::ADDRESS_U: {
        enterOuterAlt(_localctx, 7);
        setState(1201);
        addressUOption();
        break;
      }

      case azslParser::ADDRESS_V: {
        enterOuterAlt(_localctx, 8);
        setState(1202);
        addressVOption();
        break;
      }

      case azslParser::ADDRESS_W: {
        enterOuterAlt(_localctx, 9);
        setState(1203);
        addressWOption();
        break;
      }

      case azslParser::MIN_LOD: {
        enterOuterAlt(_localctx, 10);
        setState(1204);
        minLodOption();
        break;
      }

      case azslParser::MAX_LOD: {
        enterOuterAlt(_localctx, 11);
        setState(1205);
        maxLodOption();
        break;
      }

      case azslParser::MIP_LOD_BIAS: {
        enterOuterAlt(_localctx, 12);
        setState(1206);
        mipLodBiasOption();
        break;
      }

      case azslParser::BORDER_COLOR: {
        enterOuterAlt(_localctx, 13);
        setState(1207);
        borderColorOption();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MaxAnisotropyOptionContext ------------------------------------------------------------------

azslParser::MaxAnisotropyOptionContext::MaxAnisotropyOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MaxAnisotropyOptionContext::MAX_ANISOTROPY() {
  return getToken(azslParser::MAX_ANISOTROPY, 0);
}

tree::TerminalNode* azslParser::MaxAnisotropyOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::MaxAnisotropyOptionContext::IntegerLiteral() {
  return getToken(azslParser::IntegerLiteral, 0);
}

tree::TerminalNode* azslParser::MaxAnisotropyOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MaxAnisotropyOptionContext::getRuleIndex() const {
  return azslParser::RuleMaxAnisotropyOption;
}

void azslParser::MaxAnisotropyOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMaxAnisotropyOption(this);
}

void azslParser::MaxAnisotropyOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMaxAnisotropyOption(this);
}

azslParser::MaxAnisotropyOptionContext* azslParser::maxAnisotropyOption() {
  MaxAnisotropyOptionContext *_localctx = _tracker.createInstance<MaxAnisotropyOptionContext>(_ctx, getState());
  enterRule(_localctx, 244, azslParser::RuleMaxAnisotropyOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1210);
    match(azslParser::MAX_ANISOTROPY);
    setState(1211);
    match(azslParser::Assign);
    setState(1212);
    match(azslParser::IntegerLiteral);
    setState(1213);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MinFilterOptionContext ------------------------------------------------------------------

azslParser::MinFilterOptionContext::MinFilterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MinFilterOptionContext::MIN_FILTER() {
  return getToken(azslParser::MIN_FILTER, 0);
}

tree::TerminalNode* azslParser::MinFilterOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::FilterModeEnumContext* azslParser::MinFilterOptionContext::filterModeEnum() {
  return getRuleContext<azslParser::FilterModeEnumContext>(0);
}

tree::TerminalNode* azslParser::MinFilterOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MinFilterOptionContext::getRuleIndex() const {
  return azslParser::RuleMinFilterOption;
}

void azslParser::MinFilterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMinFilterOption(this);
}

void azslParser::MinFilterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMinFilterOption(this);
}

azslParser::MinFilterOptionContext* azslParser::minFilterOption() {
  MinFilterOptionContext *_localctx = _tracker.createInstance<MinFilterOptionContext>(_ctx, getState());
  enterRule(_localctx, 246, azslParser::RuleMinFilterOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1215);
    match(azslParser::MIN_FILTER);
    setState(1216);
    match(azslParser::Assign);
    setState(1217);
    filterModeEnum();
    setState(1218);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MagFilterOptionContext ------------------------------------------------------------------

azslParser::MagFilterOptionContext::MagFilterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MagFilterOptionContext::MAG_FILTER() {
  return getToken(azslParser::MAG_FILTER, 0);
}

tree::TerminalNode* azslParser::MagFilterOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::FilterModeEnumContext* azslParser::MagFilterOptionContext::filterModeEnum() {
  return getRuleContext<azslParser::FilterModeEnumContext>(0);
}

tree::TerminalNode* azslParser::MagFilterOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MagFilterOptionContext::getRuleIndex() const {
  return azslParser::RuleMagFilterOption;
}

void azslParser::MagFilterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMagFilterOption(this);
}

void azslParser::MagFilterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMagFilterOption(this);
}

azslParser::MagFilterOptionContext* azslParser::magFilterOption() {
  MagFilterOptionContext *_localctx = _tracker.createInstance<MagFilterOptionContext>(_ctx, getState());
  enterRule(_localctx, 248, azslParser::RuleMagFilterOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1220);
    match(azslParser::MAG_FILTER);
    setState(1221);
    match(azslParser::Assign);
    setState(1222);
    filterModeEnum();
    setState(1223);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MipFilterOptionContext ------------------------------------------------------------------

azslParser::MipFilterOptionContext::MipFilterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MipFilterOptionContext::MIP_FILTER() {
  return getToken(azslParser::MIP_FILTER, 0);
}

tree::TerminalNode* azslParser::MipFilterOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::FilterModeEnumContext* azslParser::MipFilterOptionContext::filterModeEnum() {
  return getRuleContext<azslParser::FilterModeEnumContext>(0);
}

tree::TerminalNode* azslParser::MipFilterOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MipFilterOptionContext::getRuleIndex() const {
  return azslParser::RuleMipFilterOption;
}

void azslParser::MipFilterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMipFilterOption(this);
}

void azslParser::MipFilterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMipFilterOption(this);
}

azslParser::MipFilterOptionContext* azslParser::mipFilterOption() {
  MipFilterOptionContext *_localctx = _tracker.createInstance<MipFilterOptionContext>(_ctx, getState());
  enterRule(_localctx, 250, azslParser::RuleMipFilterOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1225);
    match(azslParser::MIP_FILTER);
    setState(1226);
    match(azslParser::Assign);
    setState(1227);
    filterModeEnum();
    setState(1228);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReductionTypeOptionContext ------------------------------------------------------------------

azslParser::ReductionTypeOptionContext::ReductionTypeOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ReductionTypeOptionContext::REDUCTION_TYPE() {
  return getToken(azslParser::REDUCTION_TYPE, 0);
}

tree::TerminalNode* azslParser::ReductionTypeOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::ReductionTypeEnumContext* azslParser::ReductionTypeOptionContext::reductionTypeEnum() {
  return getRuleContext<azslParser::ReductionTypeEnumContext>(0);
}

tree::TerminalNode* azslParser::ReductionTypeOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::ReductionTypeOptionContext::getRuleIndex() const {
  return azslParser::RuleReductionTypeOption;
}

void azslParser::ReductionTypeOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReductionTypeOption(this);
}

void azslParser::ReductionTypeOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReductionTypeOption(this);
}

azslParser::ReductionTypeOptionContext* azslParser::reductionTypeOption() {
  ReductionTypeOptionContext *_localctx = _tracker.createInstance<ReductionTypeOptionContext>(_ctx, getState());
  enterRule(_localctx, 252, azslParser::RuleReductionTypeOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1230);
    match(azslParser::REDUCTION_TYPE);
    setState(1231);
    match(azslParser::Assign);
    setState(1232);
    reductionTypeEnum();
    setState(1233);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonFunctionOptionContext ------------------------------------------------------------------

azslParser::ComparisonFunctionOptionContext::ComparisonFunctionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ComparisonFunctionOptionContext::COMPARISON_FUNC() {
  return getToken(azslParser::COMPARISON_FUNC, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::ComparisonFunctionEnumContext* azslParser::ComparisonFunctionOptionContext::comparisonFunctionEnum() {
  return getRuleContext<azslParser::ComparisonFunctionEnumContext>(0);
}

tree::TerminalNode* azslParser::ComparisonFunctionOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::ComparisonFunctionOptionContext::getRuleIndex() const {
  return azslParser::RuleComparisonFunctionOption;
}

void azslParser::ComparisonFunctionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonFunctionOption(this);
}

void azslParser::ComparisonFunctionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonFunctionOption(this);
}

azslParser::ComparisonFunctionOptionContext* azslParser::comparisonFunctionOption() {
  ComparisonFunctionOptionContext *_localctx = _tracker.createInstance<ComparisonFunctionOptionContext>(_ctx, getState());
  enterRule(_localctx, 254, azslParser::RuleComparisonFunctionOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1235);
    match(azslParser::COMPARISON_FUNC);
    setState(1236);
    match(azslParser::Assign);
    setState(1237);
    comparisonFunctionEnum();
    setState(1238);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddressUOptionContext ------------------------------------------------------------------

azslParser::AddressUOptionContext::AddressUOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AddressUOptionContext::ADDRESS_U() {
  return getToken(azslParser::ADDRESS_U, 0);
}

tree::TerminalNode* azslParser::AddressUOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::AddressModeEnumContext* azslParser::AddressUOptionContext::addressModeEnum() {
  return getRuleContext<azslParser::AddressModeEnumContext>(0);
}

tree::TerminalNode* azslParser::AddressUOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::AddressUOptionContext::getRuleIndex() const {
  return azslParser::RuleAddressUOption;
}

void azslParser::AddressUOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddressUOption(this);
}

void azslParser::AddressUOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddressUOption(this);
}

azslParser::AddressUOptionContext* azslParser::addressUOption() {
  AddressUOptionContext *_localctx = _tracker.createInstance<AddressUOptionContext>(_ctx, getState());
  enterRule(_localctx, 256, azslParser::RuleAddressUOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1240);
    match(azslParser::ADDRESS_U);
    setState(1241);
    match(azslParser::Assign);
    setState(1242);
    addressModeEnum();
    setState(1243);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddressVOptionContext ------------------------------------------------------------------

azslParser::AddressVOptionContext::AddressVOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AddressVOptionContext::ADDRESS_V() {
  return getToken(azslParser::ADDRESS_V, 0);
}

tree::TerminalNode* azslParser::AddressVOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::AddressModeEnumContext* azslParser::AddressVOptionContext::addressModeEnum() {
  return getRuleContext<azslParser::AddressModeEnumContext>(0);
}

tree::TerminalNode* azslParser::AddressVOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::AddressVOptionContext::getRuleIndex() const {
  return azslParser::RuleAddressVOption;
}

void azslParser::AddressVOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddressVOption(this);
}

void azslParser::AddressVOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddressVOption(this);
}

azslParser::AddressVOptionContext* azslParser::addressVOption() {
  AddressVOptionContext *_localctx = _tracker.createInstance<AddressVOptionContext>(_ctx, getState());
  enterRule(_localctx, 258, azslParser::RuleAddressVOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1245);
    match(azslParser::ADDRESS_V);
    setState(1246);
    match(azslParser::Assign);
    setState(1247);
    addressModeEnum();
    setState(1248);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddressWOptionContext ------------------------------------------------------------------

azslParser::AddressWOptionContext::AddressWOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AddressWOptionContext::ADDRESS_W() {
  return getToken(azslParser::ADDRESS_W, 0);
}

tree::TerminalNode* azslParser::AddressWOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::AddressModeEnumContext* azslParser::AddressWOptionContext::addressModeEnum() {
  return getRuleContext<azslParser::AddressModeEnumContext>(0);
}

tree::TerminalNode* azslParser::AddressWOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::AddressWOptionContext::getRuleIndex() const {
  return azslParser::RuleAddressWOption;
}

void azslParser::AddressWOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddressWOption(this);
}

void azslParser::AddressWOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddressWOption(this);
}

azslParser::AddressWOptionContext* azslParser::addressWOption() {
  AddressWOptionContext *_localctx = _tracker.createInstance<AddressWOptionContext>(_ctx, getState());
  enterRule(_localctx, 260, azslParser::RuleAddressWOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1250);
    match(azslParser::ADDRESS_W);
    setState(1251);
    match(azslParser::Assign);
    setState(1252);
    addressModeEnum();
    setState(1253);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MinLodOptionContext ------------------------------------------------------------------

azslParser::MinLodOptionContext::MinLodOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MinLodOptionContext::MIN_LOD() {
  return getToken(azslParser::MIN_LOD, 0);
}

tree::TerminalNode* azslParser::MinLodOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::MinLodOptionContext::FloatLiteral() {
  return getToken(azslParser::FloatLiteral, 0);
}

tree::TerminalNode* azslParser::MinLodOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MinLodOptionContext::getRuleIndex() const {
  return azslParser::RuleMinLodOption;
}

void azslParser::MinLodOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMinLodOption(this);
}

void azslParser::MinLodOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMinLodOption(this);
}

azslParser::MinLodOptionContext* azslParser::minLodOption() {
  MinLodOptionContext *_localctx = _tracker.createInstance<MinLodOptionContext>(_ctx, getState());
  enterRule(_localctx, 262, azslParser::RuleMinLodOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1255);
    match(azslParser::MIN_LOD);
    setState(1256);
    match(azslParser::Assign);
    setState(1257);
    match(azslParser::FloatLiteral);
    setState(1258);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MaxLodOptionContext ------------------------------------------------------------------

azslParser::MaxLodOptionContext::MaxLodOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MaxLodOptionContext::MAX_LOD() {
  return getToken(azslParser::MAX_LOD, 0);
}

tree::TerminalNode* azslParser::MaxLodOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::MaxLodOptionContext::FloatLiteral() {
  return getToken(azslParser::FloatLiteral, 0);
}

tree::TerminalNode* azslParser::MaxLodOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MaxLodOptionContext::getRuleIndex() const {
  return azslParser::RuleMaxLodOption;
}

void azslParser::MaxLodOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMaxLodOption(this);
}

void azslParser::MaxLodOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMaxLodOption(this);
}

azslParser::MaxLodOptionContext* azslParser::maxLodOption() {
  MaxLodOptionContext *_localctx = _tracker.createInstance<MaxLodOptionContext>(_ctx, getState());
  enterRule(_localctx, 264, azslParser::RuleMaxLodOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1260);
    match(azslParser::MAX_LOD);
    setState(1261);
    match(azslParser::Assign);
    setState(1262);
    match(azslParser::FloatLiteral);
    setState(1263);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MipLodBiasOptionContext ------------------------------------------------------------------

azslParser::MipLodBiasOptionContext::MipLodBiasOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::MipLodBiasOptionContext::MIP_LOD_BIAS() {
  return getToken(azslParser::MIP_LOD_BIAS, 0);
}

tree::TerminalNode* azslParser::MipLodBiasOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

tree::TerminalNode* azslParser::MipLodBiasOptionContext::FloatLiteral() {
  return getToken(azslParser::FloatLiteral, 0);
}

tree::TerminalNode* azslParser::MipLodBiasOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::MipLodBiasOptionContext::getRuleIndex() const {
  return azslParser::RuleMipLodBiasOption;
}

void azslParser::MipLodBiasOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMipLodBiasOption(this);
}

void azslParser::MipLodBiasOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMipLodBiasOption(this);
}

azslParser::MipLodBiasOptionContext* azslParser::mipLodBiasOption() {
  MipLodBiasOptionContext *_localctx = _tracker.createInstance<MipLodBiasOptionContext>(_ctx, getState());
  enterRule(_localctx, 266, azslParser::RuleMipLodBiasOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1265);
    match(azslParser::MIP_LOD_BIAS);
    setState(1266);
    match(azslParser::Assign);
    setState(1267);
    match(azslParser::FloatLiteral);
    setState(1268);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BorderColorOptionContext ------------------------------------------------------------------

azslParser::BorderColorOptionContext::BorderColorOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BorderColorOptionContext::BORDER_COLOR() {
  return getToken(azslParser::BORDER_COLOR, 0);
}

tree::TerminalNode* azslParser::BorderColorOptionContext::Assign() {
  return getToken(azslParser::Assign, 0);
}

azslParser::BorderColorEnumContext* azslParser::BorderColorOptionContext::borderColorEnum() {
  return getRuleContext<azslParser::BorderColorEnumContext>(0);
}

tree::TerminalNode* azslParser::BorderColorOptionContext::Semi() {
  return getToken(azslParser::Semi, 0);
}


size_t azslParser::BorderColorOptionContext::getRuleIndex() const {
  return azslParser::RuleBorderColorOption;
}

void azslParser::BorderColorOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBorderColorOption(this);
}

void azslParser::BorderColorOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBorderColorOption(this);
}

azslParser::BorderColorOptionContext* azslParser::borderColorOption() {
  BorderColorOptionContext *_localctx = _tracker.createInstance<BorderColorOptionContext>(_ctx, getState());
  enterRule(_localctx, 268, azslParser::RuleBorderColorOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1270);
    match(azslParser::BORDER_COLOR);
    setState(1271);
    match(azslParser::Assign);
    setState(1272);
    borderColorEnum();
    setState(1273);
    match(azslParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterModeEnumContext ------------------------------------------------------------------

azslParser::FilterModeEnumContext::FilterModeEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::FilterModeEnumContext::FILTER_MODE_POINT() {
  return getToken(azslParser::FILTER_MODE_POINT, 0);
}

tree::TerminalNode* azslParser::FilterModeEnumContext::FILTER_MODE_LINEAR() {
  return getToken(azslParser::FILTER_MODE_LINEAR, 0);
}


size_t azslParser::FilterModeEnumContext::getRuleIndex() const {
  return azslParser::RuleFilterModeEnum;
}

void azslParser::FilterModeEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterModeEnum(this);
}

void azslParser::FilterModeEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterModeEnum(this);
}

azslParser::FilterModeEnumContext* azslParser::filterModeEnum() {
  FilterModeEnumContext *_localctx = _tracker.createInstance<FilterModeEnumContext>(_ctx, getState());
  enterRule(_localctx, 270, azslParser::RuleFilterModeEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1275);
    _la = _input->LA(1);
    if (!(_la == azslParser::FILTER_MODE_POINT

    || _la == azslParser::FILTER_MODE_LINEAR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReductionTypeEnumContext ------------------------------------------------------------------

azslParser::ReductionTypeEnumContext::ReductionTypeEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ReductionTypeEnumContext::REDUCTION_TYPE_FILTER() {
  return getToken(azslParser::REDUCTION_TYPE_FILTER, 0);
}

tree::TerminalNode* azslParser::ReductionTypeEnumContext::REDUCTION_TYPE_COMPARISON() {
  return getToken(azslParser::REDUCTION_TYPE_COMPARISON, 0);
}

tree::TerminalNode* azslParser::ReductionTypeEnumContext::REDUCTION_TYPE_MINIMUM() {
  return getToken(azslParser::REDUCTION_TYPE_MINIMUM, 0);
}

tree::TerminalNode* azslParser::ReductionTypeEnumContext::REDUCTION_TYPE_MAXIMUM() {
  return getToken(azslParser::REDUCTION_TYPE_MAXIMUM, 0);
}


size_t azslParser::ReductionTypeEnumContext::getRuleIndex() const {
  return azslParser::RuleReductionTypeEnum;
}

void azslParser::ReductionTypeEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReductionTypeEnum(this);
}

void azslParser::ReductionTypeEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReductionTypeEnum(this);
}

azslParser::ReductionTypeEnumContext* azslParser::reductionTypeEnum() {
  ReductionTypeEnumContext *_localctx = _tracker.createInstance<ReductionTypeEnumContext>(_ctx, getState());
  enterRule(_localctx, 272, azslParser::RuleReductionTypeEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1277);
    _la = _input->LA(1);
    if (!(((((_la - 287) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 287)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddressModeEnumContext ------------------------------------------------------------------

azslParser::AddressModeEnumContext::AddressModeEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_WRAP() {
  return getToken(azslParser::ADDRESS_MODE_WRAP, 0);
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_MIRROR() {
  return getToken(azslParser::ADDRESS_MODE_MIRROR, 0);
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_CLAMP() {
  return getToken(azslParser::ADDRESS_MODE_CLAMP, 0);
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_BORDER() {
  return getToken(azslParser::ADDRESS_MODE_BORDER, 0);
}

tree::TerminalNode* azslParser::AddressModeEnumContext::ADDRESS_MODE_MIRROR_ONCE() {
  return getToken(azslParser::ADDRESS_MODE_MIRROR_ONCE, 0);
}


size_t azslParser::AddressModeEnumContext::getRuleIndex() const {
  return azslParser::RuleAddressModeEnum;
}

void azslParser::AddressModeEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddressModeEnum(this);
}

void azslParser::AddressModeEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddressModeEnum(this);
}

azslParser::AddressModeEnumContext* azslParser::addressModeEnum() {
  AddressModeEnumContext *_localctx = _tracker.createInstance<AddressModeEnumContext>(_ctx, getState());
  enterRule(_localctx, 274, azslParser::RuleAddressModeEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1279);
    _la = _input->LA(1);
    if (!(((((_la - 291) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 291)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonFunctionEnumContext ------------------------------------------------------------------

azslParser::ComparisonFunctionEnumContext::ComparisonFunctionEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_NEVER() {
  return getToken(azslParser::COMPARISON_FUNCTION_NEVER, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_LESS() {
  return getToken(azslParser::COMPARISON_FUNCTION_LESS, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_EQUAL() {
  return getToken(azslParser::COMPARISON_FUNCTION_EQUAL, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_LESS_EQUAL() {
  return getToken(azslParser::COMPARISON_FUNCTION_LESS_EQUAL, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_GREATER() {
  return getToken(azslParser::COMPARISON_FUNCTION_GREATER, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_NOT_EQUAL() {
  return getToken(azslParser::COMPARISON_FUNCTION_NOT_EQUAL, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_GREATER_EQUAL() {
  return getToken(azslParser::COMPARISON_FUNCTION_GREATER_EQUAL, 0);
}

tree::TerminalNode* azslParser::ComparisonFunctionEnumContext::COMPARISON_FUNCTION_ALWAYS() {
  return getToken(azslParser::COMPARISON_FUNCTION_ALWAYS, 0);
}


size_t azslParser::ComparisonFunctionEnumContext::getRuleIndex() const {
  return azslParser::RuleComparisonFunctionEnum;
}

void azslParser::ComparisonFunctionEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonFunctionEnum(this);
}

void azslParser::ComparisonFunctionEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonFunctionEnum(this);
}

azslParser::ComparisonFunctionEnumContext* azslParser::comparisonFunctionEnum() {
  ComparisonFunctionEnumContext *_localctx = _tracker.createInstance<ComparisonFunctionEnumContext>(_ctx, getState());
  enterRule(_localctx, 276, azslParser::RuleComparisonFunctionEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1281);
    _la = _input->LA(1);
    if (!(((((_la - 296) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 296)) & 255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BorderColorEnumContext ------------------------------------------------------------------

azslParser::BorderColorEnumContext::BorderColorEnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* azslParser::BorderColorEnumContext::BORDER_COLOR_OPAQUE_BLACK() {
  return getToken(azslParser::BORDER_COLOR_OPAQUE_BLACK, 0);
}

tree::TerminalNode* azslParser::BorderColorEnumContext::BORDER_COLOR_TRANSPARENT_BLACK() {
  return getToken(azslParser::BORDER_COLOR_TRANSPARENT_BLACK, 0);
}

tree::TerminalNode* azslParser::BorderColorEnumContext::BORDER_COLOR_OPAQUE_WHITE() {
  return getToken(azslParser::BORDER_COLOR_OPAQUE_WHITE, 0);
}


size_t azslParser::BorderColorEnumContext::getRuleIndex() const {
  return azslParser::RuleBorderColorEnum;
}

void azslParser::BorderColorEnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBorderColorEnum(this);
}

void azslParser::BorderColorEnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<azslParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBorderColorEnum(this);
}

azslParser::BorderColorEnumContext* azslParser::borderColorEnum() {
  BorderColorEnumContext *_localctx = _tracker.createInstance<BorderColorEnumContext>(_ctx, getState());
  enterRule(_localctx, 278, azslParser::RuleBorderColorEnum);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1283);
    _la = _input->LA(1);
    if (!(((((_la - 304) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 304)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool azslParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 43: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 44: return expressionExtSempred(antlrcpp::downCast<ExpressionExtContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool azslParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 3);
    case 1: return precpred(_ctx, 10);
    case 2: return precpred(_ctx, 9);
    case 3: return precpred(_ctx, 8);
    case 4: return precpred(_ctx, 5);
    case 5: return precpred(_ctx, 2);
    case 6: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool azslParser::expressionExtSempred(ExpressionExtContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void azslParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  azslparserParserInitialize();
#else
  ::antlr4::internal::call_once(azslparserParserOnceFlag, azslparserParserInitialize);
#endif
}
